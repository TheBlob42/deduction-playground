cmdhistory=["(sign)" "(\:const sign)" "(map \#(first %) sign)" "(map \#(second %) sign)" "(map \#(first %) (\:const sign))" "(signature sign)" "(keyword c)" "(keyword \\"c\\")" "(map \#(keyword %) (\:const sign))" "(assoc {} (\:c \:d \:e))" "(defn test \\n  [t]\\n  (keyword t) [\:bla 1])" "(test \\"c\\")" "(defn test \\r\\n     [t]\\r\\n     ((keyword t) [\:bla 1]))" "(test \\"c\\")" "(defn test \\r\\n     [t]\\r\\n     {(keyword t) [\:bla 1]})" "(test \\"c\\")" "(signature sign)" "(map \#({(keyword %) [\:const 0]}) (\:const sign))" "(map \#(into [] (keyword %) 1) (\:const sign))" " (map \#(into [] [(keyword %) 1]) (\:const sign))" " (map \#([(keyword %) 1]) (\:const sign))" "(zipmap (map \#(keyword %) (\:const sign)) (map \#(into [] [\:const 0]) (\:const sign)))" "(map \#(hash-map (keyword %) [\:const 0]) (\:const sign))" "(into {} (map \#(hash-map (keyword %) [\:const 0]) (\:const sign)))" "(signature sign)" "(partition 2 (\:func sign))" "(map \#(hash-map (keyword (first %)) (second %)) (partition 2 (\:func sign)))" "(signature sign)" "(\:const sign)" "(valid-signature? sign)" "(signature sign)" "(sign)" "(\:const sign)" "form" "(form)" "(formula sign form)" "(meta (formula sign form))" "(defn item [itm]\\n  (fn [in]\\n    (if (empty? in)\\n      [nil in]\\n      (if (\= (first in) itm)\\n        [[itm] (rest in)]\\n        [nil in]))))" "((item 2) [2 3 4])" "((item 2) [1 2 3 4])" "((item 2) [])" "(defn por [& parsers]\\n  (fn [in]\\n    (loop [ps parsers]\\n      (if (empty? ps)\\n        [nil in]\\n        (let [[res1 in1] ((first ps) in)]\\n          (if res1 [res1 in1] (recur (rest ps))))))))" "((por (item 2) (item 3)) [1 2 3])" "((por (item 2) (item 3)) [2 3])" "((por (item 2) (item 3)) [3 2 1])" "((por (item 2) (item 3)) [])" "(map \#(% [3 2 1]) [(item 2) (item 3)])" "(filter \#(first %) (map \#(% [3 2 1]) [(item 2) (item 3)]))" "(defn por [& parsers]\\n  (fn [in]\\n    (let [res (filter \#(first %) (map \#(% in) parsers))]\\n      (if (empty? res) [nil in] (first res)))))" "(pipe [(item 2) (item 3)] [3 2 1])" "(pipe [(item 2) (item 3) (item 2)] [3 2 1])" "((pand (item 2) (item 3)) [1 2 3])" "((pand (item 2) (item 3)) [2 3 1])" "((pand (item 2) (item 3)) [2 1 3])" "((pand-lazy (item 2) (item 3)) [1 2 3])" "((pand-lazy (item 2) (item 3)) [2 3 1])" "((pand-lazy (item 2) (item 3)) [2 1 3])" "(const? \\"c\\")" "(const? \\"x\\")" "(str f)" "(s/split f \#\\" \\")" "f" "(s/split (str f) \#\\" \\")" "(or-symbol? [\\"(or\\" \\"(P\\" \\"x)\\"])" "((is? \:const) (s/split (str c) \#\\" \\"))" "((is? \:const) \\"c\\")" "((is? \:const) [\\"c\\" \\"x\\"])" "(keyword \\"c\\")" "((is? \:const) [\\"c\\" \\"x\\"])" "((is? \:const) [\\"t\\" \\"c\\" \\"x\\"])" "((pand-lazy (is? \:const) (is? \:pred)) [\\"c\\" \\"P\\"])" "((pand-lazy (is? \:const) (is? \:pred)) [\\"t\\" \\"c\\" \\"P\\"])" "((pand-lazy (is? \:const) (is? \:pred)) [\\"c\\" \\"P\\" \\"asd\\" \\"a\\"])" "(first '(a b c))" "(second f)" "((item true) true)" "((item true) '(true))" "((form-parser \\"I\\"))" "(def t '(and true true))" "(form-parser t)" "((form-parser t))" "(form-parser t)" "(first '(and t t))" "(form-parser t)" "(def t '(and true true true))" "(form-parser t)" "(def t '(and true true false))" "(form-parser t)" "(def t '(and true true true true))" "(form-parser t)" "(def t '(and true true (and true false)))" "(form-parser t)" "(def t '(and true (and true false)))" "(form-parser t)" "(second '(and (and t)))" "(def t '(and true (and true true)))" "(form-parser t)" "(def test (pand (item 'and) (item true) (item 'and) (item true)))" "(test t)" "(def t1 (pand (item 'and) (item true)))" "(t1 t)" "(form-parser '((and true true)))" "t" "(first '((and)))" "(first '((and )))" "(list? '(and))" "(list? (first '(and)))" "(list? (first '((and))))" "(last '(a b c))" "(f-parser t)" "(def t '(and true true true))" "(f-parser t)" "(str '(and))" "(first (str '(and)))" "(def s (str '(and true true)))" "s" "(s/split \\"(ad(\\" \#\\"(\\")" "(s/split \\"(ad(\\" \#\\"(\\\\(\\\\)\\\\s)*\\")" "(s/split \\"(ad(\\" \#\\"a\\")" "(replace (str '(and true true)) \#\\"(\\" \\"( \\")" "(s/replace (str '(and true true)) \#\\"(\\" \\"( \\")" "(s/replace (str '(and true true)) \#\\"\\\\(|\\\\)\\" {\\"(\\" \\"( \\" \\")\\" \\" )\\"})" "(s/split (s/replace (str '(and true true)) \#\\"\\\\(|\\\\)\\" {\\"(\\" \\"( \\" \\")\\" \\" )\\"}) \#\\" \\")" "(form-to-string '(and true (and true true)))" "(f-parser (form-to-string form))" "(f-parser (form-to-string '(and true true)))" "((item \\"(\\") \\"(\\")" "(form-to-string form)" "((item \\"(\\") (form-to-string form))" "(form-parser (form-to-string form))" "(form-parser (form-to-string '(and true true)))" "((pand (item \\"(\\") (item \\"and\\")) [\\"(\\" \\"and\\" \\"asdds\\"])" "(f-parser (form-to-string '(and true true)))" "(f-parser (form-to-string '(and true false)))" "(f-parser (form-to-string '(and true true)))" "(f-parser (form-to-string form))" "(f-parser (form-to-string '(and true true true true) form))" "(f-parser (form-to-string '(and true true true true)))" "(f-parser (form-to-string '(and true true true true true true)))" "(f-parser (form-to-string '(and true true true (and true true) form)))" "(f-parser (form-to-string '(and true true true (and true true))))" "(f-parser (form-to-string '(and true true true (and true true) true)))" "(def v (with-meta [1 2 3] \\"hallo\\"))" "(def v (with-meta [1 2 3] {\:test \\"bla\\"}))" "v" "(meta v)" "(def f '(and true (f c c)))" "(f-parser (form-to-string f))" "(func-parser (form-to-string '(f c c)))" "(form-to-string '(f c c))" "((is? \:func) \\"f\\")" "((is? \:func) [\\"f\\" \\"c\\" \\"c\\" \\")\\"])" "(meta ((is? \:func) [\\"f\\" \\"c\\" \\"c\\" \\")\\"]))" "((mexact (is? \:const)) ((is? \:func) [\\"f\\" \\"c\\" \\"c\\" \\")\\"]))" "(doall ((mexact (is? \:const)) ((is? \:func) [\\"f\\" \\"c\\" \\"c\\" \\")\\"])))" "(first ((mexact (is? \:const)) ((is? \:func) [\\"f\\" \\"c\\" \\"c\\" \\")\\"])))" "(def e (mexact (is? \:const)))" "((e (with-meta [\\"c\\" \\"c\\"] {\:arity 2})))" "(e (with-meta [\\"c\\" \\"c\\"] {\:arity 2}))" "((e (with-meta [\\"c\\" \\"c\\"] {\:arity 2})))" "(e (with-meta [\\"c\\" \\"c\\"] {\:arity 2}))" "((exact 2 (is? \:const)) [\\"c\\" \\"c\\"])" "((mexact (is? \:const)) (with-meta [\\"c\\" \\"c\\"] {\:arity 2}))" "(first ((mexact (is? \:const)) (with-meta [\\"c\\" \\"c\\"] {\:arity 2})))" "(take 3 (cycle [1]))" "((mexact (is? \:const)) (with-meta [\\"c\\" \\"c\\"] {\:arity 2}))" "(first ((mexact (is? \:const)) (with-meta [\\"c\\" \\"c\\"] {\:arity 2})))" "((mexact (is? \:const)) (with-meta [\\"c\\" \\"c\\"] {\:arity 2}))" "(first ((mexact (is? \:const)) (with-meta [\\"c\\" \\"c\\"] {\:arity 2})))" "(((mexact (is? \:const)) (with-meta [\\"c\\" \\"c\\"] {\:arity 2})) [\\"c\\" \\"c\\"])" "(((mexact (is? \:const)) (with-meta [\\"c\\" \\"c\\"] {\:arity 2})) [\\"c\\" \\"c\\" \\"c\\"])" "((mexact (is? \:const)) (with-meta [\\"c\\" \\"c\\"] {\:arity 2}))" "(func-parser (form-to-string '(f c c)))" "(func-parser [\\"(\\" \\"f\\" \\"c\\" \\"c\\" \\")\\"])" "(func-parser [\\"(\\" \\"f\\"])" "(func-parser [\\"(\\"])" "(func-parser [\\"(\\" \\"f\\"])" "((is? \:func) [\\"f\\"])" "((is? \:func) [[\\"(\\"] (\\"f\\")])" "(pipe [(item 2) (item 3)] [2 3])" "((is? \:func) [\\"f\\"])" "(\:a {\:b 2})" "(func-parser [\\"(\\" \\"f\\"])" "((is? \:func) [\\"f\\"])" "(meta (second ((is? \:func) [\\"f\\"])))" "(func-parser [\\"(\\" \\"f\\" \\"c\\" \\"c\\"])" "((mexact (is? \:const)) (\\"c\\" \\"c\\"))" "((mexact (is? \:const)) (with-meta (\\"c\\" \\"c\\") {\:arity 2}))" "((mexact (is? \:const)) (with-meta '(\\"c\\" \\"c\\") {\:arity 2}))" "(func-parser [\\"(\\" \\"f\\" \\"c\\" \\"c\\"])" "(func-parser [\\"(\\" ])" "(func-parser [\\"(\\" \\"f\\"])" "(func-parser [\\"(\\" \\"f\\" \\"c\\" \\"c\\"])" "((is? \:func) [\\"f\\"])" "(def f '(f c c))" "(def fs (form-to-string f))" "fs" "(func-parser fs)" "(with-meta [1 2 3] {\:a 1})" "(meta (with-meta [1 2 3] {\:a 1}))" "(meta (second (with-meta [1 2 3] {\:a 1})))" "(def b (with-meta [1 2 3] {\:a 1}))" "(meta (with-meta (second b) (meta b)))" "(meta (with-meta (rest b) (meta b)))" "(func-parser fs)" "(t [\\"f\\" \\"c\\" \\"c\\"])" "((t \:func (is? \:const)) [\\"f\\" \\"c\\" \\"c\\"])" "(func-parser fs)" "((t \:func (is? \:const)) [\\"f\\" \\"c\\" \\"c\\"])" "(func-parser fs)" "((t \:func (is? \:const)) [\\"f\\" \\"c\\" \\"c\\"])" "(func-parser fs)" "fs" "(func-parser fs)" "(func-parser fs)\=" "(func-parser fs)" "(def s (form-to-string '(f f c)))" "s" "(func-parser s)" "(func-parser fs)" "(func-parser (form-to-string '(f )))" "(func-parser (form-to-string '(f2 )))" "(form-to-string '(f2))" "(func-parser (form-to-string '(f2)))" "(part-of-sign? \\"c\\")" "(part-of-sign? \\"g\\")" "(first nil)" "((is? \:const) \\"c\\")" "((is? \:const) [\\"c\\"])" "(def g (form-to-string '(f c (f c c))))" "g" "(term-parser g)" "(term-parser (g))" "((term-parser g))" "(func-parser g)" "(declare b-parser)" "(defn a-parser [in] ((pand (item \\\\a) (many b-parser)) in))" "(defn b-parser [in] ((pand (item \\\\b) (many a-parser)) in))" "(a-parser (seq \\"abba\\"))" "(term-parser g)" "g" "(term-parser [\\"c\\"])" "(term-parser g)" "(form-to-string '(f c (f c c)))" "(def g (form-to-string '(f c (f c c))))" "g" "(term-parser g)" "(term-parser (form-to-string '(f c (f c c c))))" "(def g (form-to-string '(f c (f c c))))" "g" "(func-parser g)" "(def p (form-to-string '(P (f c c))))" "p" "(pred-parser p)" "(def p2 (form-to-string '(P c)))" "p" "p2" "(pred-parser p2)" "(def p3 (form-to-string '(P3)))" "p3" "(pred-parser p3)" "(def p3 (form-to-string '(P2)))" "p3" "(pred-parser p3)" "p2" "(pred-parser p2)" "((is-with-arity? \:pred term-parser) [\\"P\\"])" "((is-with-arity? \:pred term-parser) [\\"P\\" \\"c\\"])" "((is-with-arity? \:pred (is? \:const)) [\\"P\\" \\"c\\"])" "((is-with-arity? \:func (is? \:const)) [\\"f\\" \\"c\\" \\"c\\"])" "((is-with-arity? \:func (is? \:const)) [\\"f3\\" \\"c\\"])" "((is-with-arity? \:func (is? \:const)) [\\"f3\\" \\"c\\" \\"c\\" \\"c\\"])" "((is-with-arity? \:func (is? \:const)) [\\"f3\\" \\"c\\" \\"c\\" \\"c\\" \\"c\\"])" "((is-with-arity? \:func (is? \:const)) [\\"f3\\" \\"c\\"])" "((is-with-arity? \:pred (is? \:const)) [\\"P\\" \\"c\\"])" "p" "(pred-parser p)" "(def p2 (form-to-string '(P2 c (f c c))))" "p2" "(pred-parser p2)" "(pred-parser p)" "(def f (form-to-string '(and (P c) (or (not (P (f c c))) true))))" "f" "(form-parser f)" "(form-parser [\\"true\\"])" "(form-parser f)" "(form-parser [\\"true\\"])" "(form-parser f)" "(form-parser [\\"true\\"])" "(form-parser [\\"(\\" \\"P\\" \\"c\\" \\")\\"])" "(def t (form-to-string '(not (P c))))" "t" "(form-parser t)" "((item \\"not\\") [\\"not\\"])" "(def t2 (form-to-string '(not true)))" "(form-parser t2)" "((pand-lazy (item \\"(\\") (item \\"not\\")) [\\"(\\" \\"not\\"])" "((pand-lazy (item \\"(\\") (item \\"not\\") form-parser) [\\"(\\" \\"not\\" \\"true\\"])" "((pand-lazy (item \\"(\\") (item \\"not\\") form-parser (item \\")\\")) [\\"(\\" \\"not\\" \\"true\\" \\")\\"])" "t2" "(form-parser t2)" "((por (item 2) (item 3)) [3])" "((pand (item 2) (item 3)) [2 3])" "(cons [2] [3])" "(cons [2] [3] [4])" "(cons [3] [3 4])" "(def a1 [2])" "(def a2 [3])" "(def a3 [4])" "(concat a1 a2 a3)" "f" "f2" "f3" "(form-parser t2)" "((pand (item 2) (item 3) [2 3 4]))" "((pand (item 2) (item 3)) [2 3 4])" "(doall ((pand-lazy (item 2) (item 3)) [2 3 4]))" "((por (item 2) (item 3)) [2 3 4])" "(form-parser t2)" "t2" "(form-parser t2)" "((por (pand-lazy (item 2) (item 3)) (item 4)) [2 3 4])" "(form-parser [\\"(\\" \\"not\\" \\"true\\" \\")\\"])" "((pand-lazy (item \\"(\\") (item \\"not\\")) [\\"(\\" \\"not\\"])" "(form-parser [\\"(\\" \\"not\\" \\"true\\"])" "(form-parser t2)" "((por pred-parser (item \\"true\\")) [\\"(\\" \\"P\\" \\"c\\" \\")\\"])" "((por pred-parser (item \\"true\\")) [\\"true\\"])" "(form-parser t2)" "(def t3 (form-to-string '(and (not true) false)))" "t2" "t3" "(form-parser t3)" "(def t4 (form-to-string '(not (and true false))))" "t4" "(form-parser t4)" "(def t5 (form-to-string '(and (P (f c c)) true)))" "(form-parser t5)" "(def f (form-to-string '(and (not (P c)) (P (f c (f c c))))))" "(form-parser f)" "(def f2 (form-to-string '(and (not (P c c)) true)))" "(form-parser f2)" "(form-parser f)" "(form-parser f2)" "((pand (item 2) (item 3) (item 4)) [2 3 5])" "((pand-hl (item 2) (item 3) (item 4)) [2 3 5])" "((pand-lazy (item 2) (item 3) (item 4)) [2 3 5])" " ((pand-hl (item 2) (item 3) (item 4)) [2 3 5])" "((pand-hl (item 2) (item 3) (item 4)) [2 3 5])" "f" "(form-parser f)" "f2" "(form-parser f2)" "(def f (form-to-string '(or (and true (P c)) (not (P (f c c))))))" "(form-parser f)" "(form-parser [\\"true\\"])" "(def f2 (form-to-string '(and (P (f c c)) true)))" "(form-parser f2)" "f" "(def f3 (form-to-string '(or (P c) false)))" "(form-parser f3)" "(form-parser f)" "(def f4 (form-to-string '(or (and true false) (not true))))" "(form-parser f4)" "f2" "(def f5 (form-to-string '(or (and true true) true)))" "(form-parser f5)" "(def f6 (form-to-string '(not (or true true))))" "(form-parser f6)" "(def f7 (form-to-string '(and (not true) false)))" "(form-parser f7)" "(form-parser f)" "((item 2) [2 3])" "((item 2) [2])" "'(and 3 (not 3)" "(def t (form-to-string '(c \= c)))" "t" "(equals-parser t)" "(def t2 (form-to-string '(and (not (P c)) ((f c c) \= c))))" "(form-parser t2)" "(def t (form-to-string '(\= c (f c c))))" "(equals-parser t)" "(def t (form-to-string '(and (not (P c)) (\= (f c c) c))))" "(form-parser t)" "(def t (form-to-string '(\= c c)))" "(form-parser t)" "(equals-parser t)" "(form-parser t)" "(def t (form-to-string '(and (not true) (\= c c))))" "(form-parser t)" "(form-to-string '(forall [x] (P c)))" "(var-parser [\\"x\\"])" "(var-parser [\\"c\\"])" "(form-to-string '(forall [x] (P x)))" "(def f (form-to-string '(or (P x) false)))" "(form-parser f)" "(pred-parser [\\"(\\" \\"P\\" \\"x\\" \\")\\"])" "(def f (form-to-string '(and (P x) true)))" "(form-parser f)" "(def f (form-to-string '(forall [x] (P x))))" "(form-parser f)" "(forall-parser f)" "(p [2 3])" "(p [2 4])" "(p [1 2])" "(p [2 3 5])" "(p [5])" "(p [1 2 5])" "(p [2 3 5])" "(p [2 3 1 2 5])" "(p [1 2 5])" "(p [1 2 2 3 1 2])" "(p [1 2 2 3 5])" "(p [1 2 2 3 4])" "(p [1 2 2 3 1 4])" "(p [1 2 1 2 5])" "(p [1 2 5])" "((item 2) [1 2 5])" "((item 2) (1 2 5))" "((item 2) '(1 2 5))" "((item 1) [1 2 5])" "((item 1) '(2 5))" "((item 2) '(2 5))" "((pand-lazy (item 1) (item 2) (item 5)) [1 2 5])" "(pipe (item 1) [1 2])" "(doall (pipe (item 1) [1 2]))" "(pipe [(item 1)] [1 2])" "((item 1) [1 2])" "(cons 2 3)" "(cons [1 2] [ 3 4])" "(cons [1 2] (cons [3 4] [5 6]))" "(p [1 2 5])" "(por \\n  (item 2)\\n  bullshit)" "(declare bullshit)" "((por\\n   (item 2)\\n   (bullshit)) [2])" "((por (item 2) (fn [in] (assert false))) [2 3])" "(p [1 1 5])" "(c [1 1 5])" "(c [5])" "(c [1 5])" "(c [1 1 5])" "(c [1 5])" "(c [1 1 5])" "(c [ 1 1 5])" "(p [1 2 5])" "(c [1 1 2 5])" "(p [1 1 1 2 5])" "(p [1 1 2 5])" "(p [1 2 5])" "(c [1 2 5])" "(p [1 1 2 5])" "(c [1 1 2 5])" "(c [1 1 1 1 1 1 2])" "(c [1 2 1 2 5])" "(c [1 2 1 2 3])" "(p [1 2 1 2])" "(p [1 2])" "(c [1 2])" "(declare x)" "(def a (+ x 10))" "(defn a [] (+ x 10))" "a" "(a)" "(def x 5)" "(a)" "(def b (a))" "b" "(declare y)" "(def a ((fn [] (+ 10 y))))" "(p [1 2])" "(c [1 2])" "(p [1 2])" "p" "(o [1 2])" "(p [1 2])" "(c [1 2])" "(p [1 2])" "(c [1 2])" "(c [ 1 2 2 2 5])" "(c [1 2 2 3])" "(def f (form-to-string '(and (or (not true) false) true)))" "(form-parser f)" "(def f2 (form-to-string '(and (or (not true false) true) true)))" "(form-parser f2)" "(form-parser f)" "(form-parser f2)" "(form-parser f)" "(form-parser f2)" "(form-parser f)" "(c [1 2])" "(c [1 1 5 2 2])" "(c [1 1 5 2])" "(c [1 1 5 1 2])" "(c [1 1 5 5 2 2])" "(c [1 5 5 2])" "(c [1 1 5 5 2 2])" "(c [1 1 5 5 2 5 2])" "(form-parser [\\"(\\" \\"and\\" \\"(\\" \\"not\\" \\"true\\" \\")\\" \\"false\\" \\")\\"])" "(c [1 2 1 2 5])" "(c [1 1 2 2 5])" "(c [2 2 1 1 5])" "(f [\\"(\\" \\"and\\" \\"(\\" \\"or\\" \\"t\\" \\"t\\" \\")\\" \\"t\\" \\")\\"])" "(f [\\"and\\" \\"or\\" \\"t\\" \\"t\\" \\"t\\"])" "(f [\\"and\\" \\"or\\" \\"t\\" \\"t\\" \\"t\\" \\")\\"])" "(f [\\"and\\" \\"or\\" \\"t\\" \\"t\\" \\")\\" \\"t\\" \\")\\"])" "(f [\\"(\\" \\"and\\" \\"(\\" \\"or\\" \\"t\\" \\"t\\" \\")\\" \\"t\\" \\")\\"])" "(f [\\"(and\\" \\"(or\\" \\"t\\" \\"t\\" \\")\\" \\"t\\" \\")\\"])" "((pand-lazy (item \\"(\\") (item \\"and\\") (item \\")\\")) [\\"(\\" \\"and\\" \\"(\\"])" "(f [\\"(\\" \\"and\\" \\"(\\" \\"or\\" \\"t\\" \\"t\\" \\")\\" \\"t\\" \\")\\"])" "(f [\\"(\\" \\"and\\" \\"(\\" \\"or\\" \\"t\\" \\"t\\" \\"t\\" \\")\\" \\"t\\" \\")\\"])" "(f [\\"(\\" \\"or\\" \\"(\\" \\"and\\" \\"t\\" \\"t\\" \\")\\" \\"t\\" \\")\\"])" "(fts '(and (or true false) (not true)))" "(pForm (fts '(and (or true false) (not true))))" "(pForm (fts '(and (or true false) (not true false))))" "(pForm (fts '(and (P c) (or true false))))" "(pForm (fts '(and (or true false) (not true))))" "(pForm (fts '(and (not true) true)))" "(pForm (fts '(or (and true false) (not false))))" "(pForm (fts '(and (or (P c) true) (not false))))" "(pForm (fts '(or (P c) true)))" "(pForm (fts '(and (or (P c) true) false)))" "(pForm [\\"true\\"])" "(pForm (fts '(and (or (P c) true) false)))" "(pForm (fts '(and (or (P c) true) false)))\\r\\nOR" "(pForm (fts '(and (or (P c) true) false)))" "(pForm (fts '(and (or (P c) true) false)))\\r\\nOR" "(pForm (fts '(and (or (P c) true) false)))" "(pForm (fts '(and (or false (P c)) (not false))))" "(pForm (fts '(not (and true (or (P c) false)))))" "(pForm (fts '(and (or (P c) true) (not false))))" "(pForm (fts '(and (or (P c) false) (not true))))" "(pForm (fts '(and (or (P c c c ) false) (not true))))" "((just-check \:const) [\\"c\\"])" "(pPred (fts '(P c)))" "(pPred (fts '(P c c)))" "(pForm (fts '(or (and (P c) true) (not false))))" "(pForm (fts '(or (and (P c c ) true) (not false))))" "((item 2) [2])" "debug" "@debug" "(enDebug)" "diDebug" "(diDebug)" "@debug" "((item 2) [2])" "(enDebug)" "((item 2) [2])" "(pFunc [\\"(\\" \\"f\\" \\"c\\" \\"c\\" \\")\\"])" "(diDebug)" "(pFunc [\\"(\\" \\"f\\" \\"c\\" \\"c\\" \\"c\\" \\")\\"])" "(diDebug)" "(pFunc [\\"(\\" \\"f\\" \\"c\\" \\"c\\" \\"p\\" \\")\\"])" "(pPred (fts '(P (f c c))))" "(enDebug)" "(pPred (fts '(P (f c c))))" "(diDebug)" "(pPred (fts '(P (f c c))))" "(pForm (fts '(forall [x] (P c))))" "(enDebug)" "(pForm (fts '(forall [x] (P c))))" "((more pVar) [x x c])" "((more pVar) [\\"x\\" \\"x\\" \\"c\\"])" "((more pVar) [\\"x\\" \\"x\\" \\"c\\" \\"x\\"])" "((more pVar) [\\"c\\"])" "(pForm (fts '(forall [x] (P c))))" "((pand-lazy (pand (item \\"(\\") (item \\"forall\\")) (item \\"[\\") (more pVar) (item \\"]\\") pForm (item \\")\\"))\\n  (fts '(forall [x] (P c))))" "(pForm (fts '(forall [x] (P c))))" "((pand-lazy (more (item 2)) (item 3)) [2 2 2 2 3])" "((pand-lazy (more (item 2)) (item 3)) [3])" "(pForm (fts '(forall [x] (P c))))" "(pForm (fts '(forall [x y z] (P (f c c)))))" "(pForm (fts '(exist [x z] (and (P c) (not true)))))" "(pForm (fts '(forall [x] (and (\= x c) (P z)))))" "(pEquals (fts '(\= c x)))" "(pForm (fts '(forall [x] (and (\= x c) (P z)))))" "(add-variable \\"x\\" \:unbound)" "variables" "@variables" "(add-variable \\"y\\" \:bound)" "(\:x @variables)" "(reset\! variables {})" "(add-variable \\"x\\" \:bound)" "(\:x @variables)" "(\:bound @variables)" "(reset\! variables {})" "(add-variable \\"x\\" \:bound)" "(add-variable \\"x\\" \:unbound)" "(doc add-variable)" "(use '(clojure.repl))" "(doc map)" "(use '(clojure.repl repl))" "(use '[clojure.repl \:refer \:all])" "(doc map)" "(doc add-variable)" "(defn bla [x] \\"blabla\\" (+ x 10))" "(doc bla)" "(meta add-variable)" "@variables" "(add-variable \\"x\\" \:bound)" "(add-variable \\"x\\" \:unbound)" "(add-variable \\"X\\" \:bound)" "@variables" "(doc add-variable)" "((keyword \\"x\\") sign)" "((keyword \\"c\\") sign)" "((is-variable? true) [\\"x\\"])" "@variables" "(reset\! variables {})" "((is-variable? true) [\\"x\\"])" "((is-variable? false) [\\"x\\"])" "(is-variable? [\\"x\\"])" "((is-variable?) [\\"x\\"])" "((is-variable?) [\\"y\\"])" "@variables" "(pForm (fts '(forall [x] (and (P x) (or z (f c z))))))" "@variables" "(pForm (fts '(forall [x] (and (P x) true))))" "@variables" "(reset\! variables {})" "(pForm (fts '(exist [x y] (and (P x) (or (P (f z y)) (\= z x))))))" "@variables" "(reset\! variables {})" "(pForm (fts '(forall [x] (and (\= x c) (P (f c x))))))" "(pForm (fts '(forall [x] (P (f x c)))))" "(pForm (fts '(P (f c c))))" "(pTerm (fts '(f c c)))" "@variables" "(pFunc (fts '(f c c)))" "((por (is? \:const) pFunc) (fts '(f c c)))" "(pTerm (fts '(f c c)))" "((por \\r\\n     (is? \:const)\\r\\n     (is-variable?)\\r\\n     pFunc) (fts '(f c c)))" "((por \\r\\n        (is? \:const)\\r\\n        pFunc) (fts '(f c c)))" "((is-variable?) (fts '(f c c)))" "(reset\! variables {})" "(pForm (fts '(forall [x] (and (P (f c x)) (P z)))))" "@variables" "(pForm (fts '(forall [x] (and (P (f c x)) (P z)))))" "@variables" "(add-variable \\"z\\" \:unbound)" "@variables" "(reset\! variables {})" "(pForm (fts '(forall [x] (and (P (f c x)) (P z)))))" "@variables" "(diDebug)" "(pForm (fts '(true)))" "((optional (item 2)) [2])" "((pand (optional (item 2)) (item 3)) [2 3])" "((pand (optional (item \\"(\\")) (item \\"true\\") (optional \\")\\")) [\\"(\\" \\"true\\"])" "((optional (item \\"(\\")) [\\"(\\"])" "((pand (optional (item \\"(\\")) (item \\"true\\")) [\\"(\\" \\"true\\"])" "(pForm (fts '(true)))" "(pForm (fts '(and true false)))" "(pForm (fts '(true)))" "(pForm (fts '(false)))" "(pForm (fts '(and false true)))" "(pForm (fts '(P c)))" "(pForm (fts '(P (f c c))))" "(pForm (fts '(P c c)))" "(pForm (fts '(P2 c c)))" "(pForm (fts '(P x)))" "@variables" "(r)" "(pForm (fts '(P2 x y)))" "@variables" "(r)" "(pForm (fts '(\= c c)))" "(pForm (fts '(\= c c c)))" "(pForm (fts '(\= x z)))" "@variables" "(r)" "(pForm (fts '(\= (f c x) z)))" "@variables" "(r)" "(pForm (fts '(and true x)))" "@variables" "(pForm (fts '(and (or true (not false)) (or (and true (not false)) true))))" "(pForm (fts '(forall [x y] \\n                     (and (P2 (f x z) ) (not c)))))" "@variables" "(r)" "(pForm (fts '(exist [x] (and (P x) (not (P2 (f x z)))))))" "@variables" "(r)" "(formula '(and (not (P x)) true))" "@variables" "(formula '(exist [x] (P x)))" "(formula '(forall [x] (P2 x z)))" "(formula '(forall [x] (and (P x) (P2 (f c z) x))) sign)" "(diDebug)" "(formula '(forall [x] (and (P x) (P2 (f c z) x))) sign)" "(use '[clojure.repl \:refer \:all])" "(doc map)" "(doc add-variable\!)" "(doc swap\!)" "(def s {\:c [\:const 0]\\n        \:P [\:pred 1]\\n        \:f [\:func 2]})" "(formula form s)" "s" "form" "(def s {\:c [\:const 0]\\n        \:P [\:pref 1]\\n        \:f [\:func 2]})" "(formula form s)" "form" "s" "(split-form form)" "(parse-formula s (split-form form))" "(parse-formula s (split-form '(and true (P c))))" "(parse-formula s (split-form '(forall [x] (and (or (P z) false)\\n                                               (P (f x c))))))" "(formula '(forall [x] (and (P x) (or (P (f c z)))))\\n         {\:c [\:const 0]\\n          \:P [\:pred 1]\\n          \:f [\:func 2]})" "(def s {\:c [\:const 0]\\r\\n             \:P [\:pred 1]\\r\\n             \:f [\:func 2]})" "(parse-formula s '(forall [x] (and (P x) (or (P (f c z))))))" "(split-form '(forall [x] (and (P x) (or (P (f c z))))))" "(formula '(forall [x] (and (P x) (or (P (f c z)) true))) s)" "(def s (signature {\:const [\\"c\\"]\\n                   \:pred [\\"P\\" 1 \\"Q\\" 2]\\n                   \:func [\\"f\\" 2 \\"g\\" 3]}))" "s" "(def f '(exist [x] (and (P x) (or (Q c x) (P (f z x))))))" "(formula f s)" "(meta (formula f s))" "(def s (signature {\:const [\\"c\\"]\\n                   \:pred [\\"P\\" 1 \\"Q\\" 2]\\n                   \:func [\\"f\\" 2 \\"g\\" 3]}))" "s" "(def f '(exist [y] (and (P y) (Q (f c y) (g c y x)))))" "f" "(meta (formula f s))" "(def f '(forall [x] (P x)))" "(def s (signature {\:pred [\\"P\\" 1]}))" "(meta (formula f s))" "sign" "(distinct? '[d d e g h])" "(distinct? (seq '[d d eg j]))" "(seq '[d f g])" "(apply distinct? '[d d g])" "(apply distinct? '[d e g])" "(keyword p)" "(keyword 'P)" "(signature sign)" "(def x (signature sign))" "(\:Q x)" "(def x '{q [\:pred 0]})" "x" "('q x)" "(\:q x)" "(q x)" "(signature sign)" "(vals sign)" "(flatten (vals sign))" "(merge [1 2 3] [4 5])" "(concat [1 3 4] [5 6])" "(concat [1 1 1] nil [2 3])" "(\:func sign)" "(take-nth 2 (\:func sign))" "(apply distinct? (concat (\:const sign) (take-nth 2 (\:func sign))\\n                         (take-nth 2 (\:pred sign))))" "(apply distinct? (concat (\:const sign) (take-nth 2 (\:func sign))\\r\\n                            (take-nth 2 (\:pred sign))))" "(signature sign)" "(reduce into {} [1 2 3])" "(reduce concat [] [[1 2] [3 4]])" "(into {} [1 2 3 4])" "(symbol? x)" "(symbol? 'x)" "keywords" "(contains? keywords 'forall)" "(atom? 'x)" "(expr? 'forall)" "'true?" "'true" "true" "(symbol? true)" "(symbol? 'true)" "(def a '(and a b))" "(first a)" "(\= (first a) and)" "(\= (first a) 'and)" "(defn t [a]\\n  (cond \\n    (nil? a) true\\n    (\= (first a) 1) (t (rest a))\\n    (\= (first a) 2) (throw (IllegalStateException. \\"ERROR\\"))))" "(t [1 1 2])" "(t [1 1 1 ])" "(t nil)" "(defn t [a]\\r\\n     (cond \\r\\n       (nil? (first a)) true\\r\\n       (\= (first a) 1) (t (rest a))\\r\\n       (\= (first a) 2) (throw (IllegalStateException. \\"ERROR\\"))))" "(t [1 1 1 ])" "(wff? '(1 2 3))" "(wff? \\"asd\\")" "(wff? 'x)" "(wff? '(and true false))" "(wff' '(or true))" "(wff? '(or true))" "(\= (first '(\= true false)) '\=)" "(wff? '(and true))" "(wff? '(or true))" "(wff? '(and or or))" "(wff? '(and true or))" "(wff? '(and true true))" "(first true)" "(true)" "(wff? '(and true true))" "(rest true)" "(wff? '(and))" "(wff? 'true)" "(wff? '(bla))" "(second '(and bla 2))" "(third '(a d b))" "(wff? '(and (and true false) false))" "(wff? '(and true (and true false false)))" "(rest '(and 1 3 4))" "(wff? '(and true (and false false true)))" "(wff? '(and true (and false (and true true))))" "(wff? '(and true (and false (and true true false))))^" "(wff? '(and (or true false) (and true (or false true))))" "(wff? '(and (or true false true) (and true (or false true))))" "(wff? '(and true (and false true true) true))" "(defn is1 [p] (if (\= p 1) true false))" "(is1 3)" "(is1 1)" "(every? is1 (1 1 1 1))" "(every? is1 '(1 1 1))" "(every? is1 '(1 1 1 1 2))" "(wff? '(and true (and true false) false))" "(wff? '(and true false bla))" "(rest '(and true false bla))" "(every? subform '(true false))" "(every? subform '(true false bla))" "(str bla)" "(str 'bla)" "(wff? '(and true false bla))\#" "(wff? '(and true false bla))" "'(bla b g)" "(seq? ())" "(seq? [])" "(seq? {})" "(seq? \#{})" "(seq? 'g)" "(wff? '(and true false bla))" "(wff? '(and true (yeah true false)))" "(wff? '(and true (eef true false)))" "(not true true)" "(every? subform '())" "(wff? '(and ))" "(\= true and)" "(\= true 'and)" "(\= true ())" "(rest '(and ))" "(subform ())" "(subform '())" "(every? subform ())" "(wff? '(and ))" "(count (rest '(and)))" "(< 0 2)" "(< 2 0)" "(wff? '(and ))" "(wff? '(and true (and false)))" "(wff? '(and true (forall [x y] (or false (not true))) false))" "(wff? '(and true (forall [] (or false (not true))) false))" "(defn f [i] (if (\= i 1) true false))" "(f 3)" "(f 1)" "(take 3 (iterate f))" "(take 3 (iterate 'f))" "(take 3 (cycle 'f))" "(take 3 (cycle '(f)))" "(apply f (1 1 1))" "(apply f '(1 1 1))" "(is-with-arity? (P 1) \:pred f)" "(is-with-arity? '(P 1) \:pred 'f)" "(is? 'P \:pred)" "(is? 'f2 \:func)" "(f 1)" "(f 2)" "(every? 'f (rest '(P 1)))" "(rest '(P 1))" "(every? f (1))" "(every? f '(1))" "(every? f (rest '(P 1)))" "(is-with-arity? '(P 1) \:pred f)" "(is-with-arity? '(P 1 1) \:pred f)" "(is-with-arity? '(c) \:const f)" "(is-with-arity? '(x) \:pred f)" "(def x {\:a 1 \:b 2})" "(contains? x \:c)" "(contains? x \:a)" "(is? c \:const)" "(is? 'c \:const)" "(is? 'P \:pred)" "(is? 'c \:pred)" "(is? 'x \:pred)" "(is? 'c \:const)" "(if (is? 'c \:const) \\"ba\\")" "(is-with-arity? '(P 1) \:pred f)" "(is-with-arity? '(P 1 1) \:pred f)" "(is-with-arity? '(X 1) \:pred f)" "(function '(f c x))" "(term 'x)" "(if (\= 2 3) true)" "(function '(f c x))" "(function '(f P x))" "(function '(f B B))" "(is? 'P \:const)" "(function '(f P x))" "(term 'P)" "(symbol? 'P)" "(or (is? 'P \:const) (variable? 'P))" "(and (symbol? phi) \\r\\n               (or (is? phi \:const) \\r\\n                   (variable? phi)))" "(and (symbol? 'P) \\r\\n               (or (is? 'P \:const) \\r\\n                   (variable? 'P)))" "(def phi 'P)" "(or (and (symbol? phi) \\r\\n               (or (is? phi \:const) \\r\\n                   (variable? phi)))\\r\\n          (function phi))" " (and (symbol? phi) \\r\\n               (or (is? phi \:const) \\r\\n                   (variable? phi)))" "(or (and (symbol? phi) \\r\\n               (or (is? phi \:const) \\r\\n                   (variable? phi)))\\r\\n          (function 'phi))" "'phi" "(first phi)" "(term '(f P c))" "(function '(f P c))" "(function '(f c c))" "(pred '(P (f c x)))" "(predicate '(P (f c x)))" "(function '(f c x))" "(function '(f c P))" "(function '(f c x))" "(function '(f c c c))" "(is-with-arity? '(f c c) \:func term)" "(def f '(f c c c))" "(is-with-arity? f \:func term)" "(function '(f P c))" "(function '(f c c c))" "(function '(f (c c) c))" "(function '(f c c P))" "(function '(f P c))" "(term '(f c c c))" "(predicate '(P c c))" "(predicate '(P f))" "(subform '(forall [x] (P c)))" "(subform '(and (P (f P c)) true))" "(subform '(p c))" "(subform '(P c c))" "(subform '(P f))" "(subform '(P c))" "(and (symbol? 'f) (or (is? 'f \:const) (variable? 'f)))" "(list? 'f)" "(is-with-arity? (P f) \:pred term)" "(is-with-arity? '(P f) \:pred term)" "(second ((keyword (first '(P f))) sign))" "(\= (count (rest '(P f)) 1))" "(\= (count (rest '(P f))) 1)" "(every? term (rest '(P f)))" "(every? term 'f)" "(rest '(P f))" "(defn is1 [x] (if (\= x 1) true false))" "(every? is1 (1))" "(every? is1 '(1))" "(every? is1 (1 1 1))" "(function '(f c c))" "(predicate '(P f))" "(is-with-arity? '(P f) phi \:pred \#(term % phi))" "(is-with-arity? '(P f) \:pred \#(term % phi))" "(is-with-arity? '(P f) \:pred \#(term % '(P f)))" "(subform '(and (P (f c x)) true))" "(is? 'f \:func)" "(subform '(and (P (f c x)) true))" "(subform '(P (f c x)))" "(is? (first '(P (f c x))) \:pred)" "(term '(f c x))" "(is? '(f c x) phi \:func)" "(is? '(f c x) \:func)" "(term '(f c x))" "(subform '(and (P (f c x)) true))" "(subform '(exist [x y] (or (P c) (and (not (P (f x (f c c)))) false))))" "(and (\= 1 1) (\= 1 2) (throw (Exception. (str \\"asdkladkjasd\\"))))" "(and (\= 1 1) (\= 1 1) (throw (Exception. (str \\"asdkladkjasd\\"))))" "(time (subform '(exist [x y] (or (P c) (and (not (P (f x (f c c)))) false)))))" "(subform '(exist [x y] (or (P c) (and (not (P (f x (f c c)))) false))))" "(predicate '(exist [x]))" "(is? '(exist [x]) \:pred)" "(is? (first '(exist [x]) \:pred))" "(is? (first '(exist [x])) \:pred)" "(subform '(exist [x y] (or (P c) (and (not (P (f x (f c c)))) false))))" "(term '(f c (f P c)))" "(subform '(exist [P] (P x)))" "(subform '(forall [P x] (P x)))" "(subform '(forall [x P] '(P x)))" "(subform '(\= c (f x c)))" "(subform '(or (\= (f c x) y) (P y)))" "(defn t\\n  [i & [b]]\\n  (println i (if b (str \\" + \\" b))))" "(t \\"ha\\")" "(if (\= 1 2) true)" "(defn t\\r\\n     [i & [b]]\\r\\n     (println i (if b (str \\" + \\" b) \\"\\")))" "(t \\"asd\\")" "(t \\"asd\\" \\"asd\\")" "(term '(f P c))" "(term 'P)"]
eclipse.preferences.version=1
