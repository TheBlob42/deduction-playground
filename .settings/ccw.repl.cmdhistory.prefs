cmdhistory=["(clojure.core/list (clojure.core/into [] \\r\\n                                          ((clojure.core/list (clojure.core/concat (clojure.core/list (quote actual)) (clojure.core/list x))) \\r\\n                                            (clojure.core/list (clojure.core/concat (clojure.core/list (quote substitution)) (clojure.core/list phi) (clojure.core/list x) (clojure.core/list e))))))" "(clojure.core/list (clojure.core/into [] \\r\\n                                          ((clojure.core/list (clojure.core/concat (clojure.core/list (quote actual)) (clojure.core/list 'x))) \\r\\n                                            (clojure.core/list (clojure.core/concat (clojure.core/list (quote substitution)) (clojure.core/list 'phi) (clojure.core/list 'x) (clojure.core/list 'e))))))" "(clojure.core/into [] \\r\\n                                          ((clojure.core/list (clojure.core/concat (clojure.core/list (quote actual)) (clojure.core/list x))) \\r\\n                                            (clojure.core/list (clojure.core/concat (clojure.core/list (quote substitution)) (clojure.core/list phi) (clojure.core/list x) (clojure.core/list e)))))" "(clojure.core/into [] \\r\\n                                          ((clojure.core/list (clojure.core/concat (clojure.core/list (quote actual)) (clojure.core/list x))) \\r\\n                                            (clojure.core/list (clojure.core/concat (clojure.core/list (quote substitution)) (clojure.core/list 'phi) (clojure.core/list 'x) (clojure.core/list 'e)))))" "(clojure.core/into [] \\r\\n                                             ((clojure.core/list (clojure.core/concat (clojure.core/list (quote actual)) (clojure.core/list 'x))) \\r\\n                                               (clojure.core/list (clojure.core/concat (clojure.core/list (quote substitution)) (clojure.core/list 'phi) (clojure.core/list 'x) (clojure.core/list 'e)))))" "(into [] '((1) (2)))" "(into [] '(((1)) ((2))))" "(into [] '(1) '(2))" "(vector '((1) (2)))" "(apply vector '((1) (2)))" "(gen-term '(infer [(actual x)\\r\\n                                        (substitution phi x e)] X))" "(clojure.core/seq (clojure.core/concat (clojure.core/list (quote infer)) \\n                                       (clojure.core/list (clojure.core/apply clojure.core/vector \\n                                                                              ((clojure.core/list (clojure.core/concat (clojure.core/list (quote actual)) \\n                                                                                                                       (clojure.core/list 'x))) (clojure.core/list (clojure.core/concat (clojure.core/list (quote substitution)) (clojure.core/list 'phi) (clojure.core/list 'x) (clojure.core/list 'e)))))) (clojure.core/list 'X)))" "(get-term-arg '[(not a)])" "(clojure.core/list (clojure.core/apply clojure.core/vector ((clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list 'a))))))" "(clojure.core/apply clojure.core/vector ((clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list 'a)))))" "((clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list 'a))))" "(clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list 'a)))" "(get-term-arg '[(not a)])" "(clojure.core/list (clojure.core/apply clojure.core/vector (clojure.core/concat ((clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) \\n                                                                                                                         (clojure.core/list 'a)))))))" "(clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list 'a))" "(get-term-arg '[(not a)])" "(clojure.core/apply clojure.core/vector (clojure.core/concat ((clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list 'a))))))" "(clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list 'a)))" "(get-term-arg '(not a))" "(clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list 'a)))" "(gen-term '(infer (actual x0)\\r\\n                      (substitution phi x0 x)))" "(clojure.core/seq (clojure.core/concat (clojure.core/list (quote infer)) (clojure.core/list (clojure.core/concat (clojure.core/list (quote actual)) (clojure.core/list 'x0))) (clojure.core/list \\n                                                                                                                                                                                (clojure.core/concat (clojure.core/list (quote substitution)) (clojure.core/list 'phi) (clojure.core/list 'x0) (clojure.core/list 'x)))))" "(gen-term '(forall [x] (P x)))" "(clojure.core/seq (clojure.core/concat (clojure.core/list (quote forall)) (clojure.core/apply clojure.core/vector (clojure.core/concat ((clojure.core/list 'x)))) (clojure.core/list (clojure.core/concat (clojure.core/list \\n                                                                                                                                                                                                            (quote P)) (clojure.core/list 'x)))))" "(map \#(inc %) [1 2 3])" "(concat (map \#(inc %) [1 2 3]))" "(get-term-arg '[x y])" "(clojure.core/apply clojure.core/vector ((clojure.core/list 'x) (clojure.core/list 'y)))" "(apply vector '((1) (2)))" "((clojure.core/list 'x) (clojure.core/list 'y))" "(get-term-arg '[x y])" "(clojure.core/apply clojure.core/vector [(clojure.core/list x) (clojure.core/list y)])" "(clojure.core/apply clojure.core/vector [(clojure.core/list 'x) (clojure.core/list 'y)])" "(get-term-arg '[x (not y)])" "(clojure.core/apply clojure.core/vector [(clojure.core/list 'x) (clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list 'y)))])" "(get-term-arg '[x (not y)])" "(clojure.core/apply clojure.core/vector (clojure.core/concat ((clojure.core/list 'x) (clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list 'y))))))" "(def e '[(x) ((not y))])" "e" "(get-term-arg '[x (not x)])" "(get-term-arg '[x (not y)])" "[(clojure.core/list 'x) (clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list 'y)))]" "(reduce \#(conj %1 (first %2)) [] '[(x) ((not y))])" "(get-term-arg '[x (not x)])" "(concat [(clojure.core/list 'x) (clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list 'y)))])" "(apply vector '[(x) ((not x))])" "(apply \#(vector (first %)) '[(x) ((not x))])" "(map \#(first %) '[(x) ((not y))])" "(get-term-arg '[x (not y)])" "(conj (get-term-arg '[x (not y)]) 'concat)" "(vector (concat (clojure.core/list 'x) (clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list 'y)))))" "(apply vector (concat (clojure.core/list 'x) (clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list 'y)))))" "(get-term-arg '[x (not y)])" "(clojure.core/apply clojure.core/vector (clojure.core/conj ((clojure.core/list 'x) (clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) \\n                                                                                                                           (clojure.core/list 'y)))) clojure.core/concat))" "(clojure.core/conj ((clojure.core/list 'x) (clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) \\r\\n                                                                                                                              (clojure.core/list 'y)))) clojure.core/concat)" "(get-term-arg '[x (not y)])" "(clojure.core/apply clojure.core/vector (clojure.core/concat (clojure.core/list 'x) \\n                                                             (clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list 'y)))))" "r" "(run* [q] ((eval (make-rule r)) '(exists [x] (P x)) '(infer [(actual F)\\n                                                             (substitution (P x) F x)] X) q))" "(def r {\:name \\"forall-i\\"\\r\\n \:given      '[(infer (actual x0)\\r\\n                      (substitution phi x0 x))]\\r\\n \:conclusion '[(forall [x] phi)]})" "(run* [q] ((eval (make-rule r)) '(infer (actual F)\\n                                        (substitution (P x) F x)) q))" "(gen-term '(infer [(actual x0)\\r\\n                       (substitution phi x0 x)]\\r\\n                      X))" "(clojure.core/seq (clojure.core/concat (clojure.core/list (quote infer)) (clojure.core/apply clojure.core/vector (clojure.core/concat (clojure.core/list (clojure.core/concat (clojure.core/list (quote actual)) (clojure.core/list 'x0))) (clojure.core/list (clojure.core/concat (clojure.core/list (quote substitution)) (clojure.core/list 'phi) (clojure.core/list 'x0) \\n                                                                                                                                                                                                                                                                                   (clojure.core/list 'x))))) (clojure.core/list 'X)))" "(get-term-arg '(infer [(actual x) (subs phi a x)] b))" "(clojure.core/list (clojure.core/concat (clojure.core/list (quote infer)) (clojure.core/apply clojure.core/vector (clojure.core/concat (clojure.core/list (clojure.core/concat (clojure.core/list (quote actual)) (clojure.core/list 'x))) (clojure.core/list (clojure.core/concat (clojure.core/list (quote subs)) (clojure.core/list 'phi) (clojure.core/list 'a) \\n                                                                                                                                                                                                                                                                                   (clojure.core/list 'x))))) (clojure.core/list 'b)))" "(get-term-arg '[(actual x) (not b)])" "(clojure.core/apply clojure.core/vector (clojure.core/concat (clojure.core/list (clojure.core/concat (clojure.core/list (quote actual)) (clojure.core/list 'x))) (clojure.core/list (clojure.core/concat \\n                                                                                                                                                                                      (clojure.core/list (quote not)) (clojure.core/list 'b)))))" "(rest (infer [(a x) (s p x y)] b))" "(rest '(infer [(a x) (s p x y)] b))" "(get-term-arg '[(a x) (s p x y)])" "(clojure.core/apply clojure.core/vector (clojure.core/concat (clojure.core/list (clojure.core/concat (clojure.core/list (quote a)) (clojure.core/list 'x))) \\n                                                             (clojure.core/list (clojure.core/concat (clojure.core/list (quote s)) (clojure.core/list 'p) (clojure.core/list 'x) (clojure.core/list 'y)))))" "(map \#(get-term-arg %) (rest '(infer [(actual x0)\\r\\n                       (substitution phi x0 x)]\\r\\n                      X)))" "(gen-term '(infer [(actual x0)\\r\\n                       (substitution phi x0 x)]\\r\\n                      X))" "((clojure.core/list (quote infer)) (clojure.core/apply clojure.core/vector (clojure.core/concat (clojure.core/list (clojure.core/concat (clojure.core/list (quote actual)) (clojure.core/list 'x0))) (clojure.core/list (clojure.core/concat (clojure.core/list (quote substitution)) \\n                                                                                                                                                                                                                                             (clojure.core/list 'phi) (clojure.core/list 'x0) (clojure.core/list 'x))))) (clojure.core/list 'X))" "(concat (clojure.core/list (quote infer)) (clojure.core/apply clojure.core/vector (clojure.core/concat (clojure.core/list (clojure.core/concat (clojure.core/list (quote actual)) (clojure.core/list 'x0))) (clojure.core/list (clojure.core/concat (clojure.core/list (quote substitution)) \\r\\n                                                                                                                                                                                                                                                (clojure.core/list 'phi) (clojure.core/list 'x0) (clojure.core/list 'x))))) (clojure.core/list 'X))" "(gen-term '(infer [(actual x0)\\r\\n                       (substitution phi x0 x)]\\r\\n                      X))" "(clojure.core/seq (clojure.core/concat (clojure.core/list (quote infer)) (clojure.core/list (clojure.core/apply clojure.core/vector (clojure.core/concat (clojure.core/list (clojure.core/concat (clojure.core/list (quote actual)) (clojure.core/list 'x0))) (clojure.core/list (clojure.core/concat (clojure.core/list (quote substitution)) \\n                                                                                                                                                                                                                                                                                                      (clojure.core/list 'phi) (clojure.core/list 'x0) (clojure.core/list 'x)))))) (clojure.core/list 'X)))" "r" "(run* [q] ((eval (make-rule r)) '(infer (actual F) (substitution (P x) F x)) q))" "(def r {\:name \\"exists-e\\"\\r\\n \:given      '[(exists [x] phi)\\r\\n               (infer [(actual x0)\\r\\n                       (substitution phi x0 x)]\\r\\n                      X)]\\r\\n \:conclusion '[X]})" "(run* [q] ((eval (make-rule r)) '(exists [z] (P z)) '(infer \\n                                                       [(actual F)\\n                                                        (substitution (P z) F z)]\\n                                                       X) q))" "(def r {\:name \\"forall-i\\"\\r\\n \:given      '[(infer (actual x0)\\r\\n                      (substitution phi x0 x))]\\r\\n \:conclusion '[(forall [x] phi)]})" "(run* [q] ((eval (make-rule r)) '(infer (actual J) (substitution (P x) J x)) q))" "(def r {\:name \\"forall-e\\"\\r\\n \:given      '[(forall [x] phi)]\\r\\n \:conclusion '[(substitution phi t x)]})" "(run* [q] ((eval (make-rule r)) '(forall [y] (P y)) q))" "(run* [q] ((eval (make-rule r)) '(forall [y x] (P y x)) q))" "(def r {\:name \\"exists-i\\"\\r\\n \:given      '[(substitution phi t x)]\\r\\n \:conclusion '[(exists [x] phi)]})" "(run* [q] ((eval (make-rule r)) '(substitution (P x) t x) q))" "(gen-fresh-args '[(exists [x] phi)\\r\\n               (infer [(actual x0)\\r\\n                       (substitution phi x0 x)]\\r\\n                      X)] '[X])" "(def r {\:name \\"exists-e\\"\\r\\n \:given      '[(exists [x] phi)\\r\\n               (infer [(actual x0)\\r\\n                       (substitution phi x0 x)]\\r\\n                      X)]\\r\\n \:conclusion '[X]})" "(run* [q] ((eval (make-rule r)) '(exists [z] (P z))\\n                                '(infer [(actual F)\\n                                         (substitution (P z) F z)]\\n                                        X) q))" "(def r {\:name \\"exists-i\\"\\r\\n \:given      '[(substitution phi t x)]\\r\\n \:conclusion '[(exists [x] phi)]})" "(run* [q] ((eval (make-rule r)) '(substitution (P z) g z) q))" "(def r {\:name \\"and-i\\"\\r\\n \:given      '[a b]\\r\\n \:conclusion '[(and a b)]})" "(run* [q] ((eval (make-rule r)) 'g 'p q))" "(def r {\:name \\"and-e1\\"\\r\\n \:given      '[(and a b)]\\r\\n \:conclusion '[a]})" "(run* [q] ((eval (make-rule r)) '(and t z) q))" "(def r {\:name \\"and-e2\\"\\r\\n \:given      '[(and a b)]\\r\\n \:conclusion '[b]})" "(run* [q] ((eval (make-rule r)) '(and t z) q))" "(def r {\:name \\"or-i1\\"\\r\\n \:given      '[a]\\r\\n \:conclusion '[(or a b)]})" "(run* [q] ((eval (make-rule r)) 'l q))" "(def r {\:name \\"or-i2\\"\\r\\n \:given      '[a]\\r\\n \:conclusion '[(or b a)]})" "(run* [q] ((eval (make-rule r)) 'l q))" "(def r {\:name \\"or-e\\"\\r\\n \:given      '[(or a b)\\r\\n               (infer a X)\\r\\n               (infer b X)]\\r\\n \:conclusion '[X]})" "(run* [q] ((eval (make-rule r)) '(or x y)\\n                                '(infer x D)\\n                                '(inder y D) q))" "(run* [q] ((eval (make-rule r)) '(or x y)\\r\\n                                   '(infer x D)\\r\\n                                   '(infer y D) q))" "(def r {\:name \\"impl-i\\"\\r\\n \:given      '[(infer a b)]\\r\\n \:conclusion '[(impl a b)]})" "(run* [q] ((eval (make-rule r)) '(infer f g) q))" "(def r {\:name \\"impl-e\\"\\r\\n \:given      '[a (impl a b)]\\r\\n \:conclusion '[b]})" "(run* [q] ((eval (make-rule r)) 'g '(impl g h) q))" "(def r {\:name \\"not-i\\"\\r\\n \:given      '[(infer a contradiction)]\\r\\n \:conclusion '[(not a)]})" "(run* [q] ((eval (make-rule r)) '(infer g contradiction) q))" "(def r {\:name \\"not-e\\"\\r\\n \:given      '[a (not a)]\\r\\n \:conclusion '[contradiction]})" "(run* [q] ((eval (make-rule r)) 'g '(not g) q))" "(def r {\:name \\"raa\\"\\r\\n \:given      '[(infer (not a) contradiction)]\\r\\n \:conclusion '[a]})" "(run* [q] ((eval (make-rule r)) '(infer (not t) contradiction) q))" "(def r {\:name \\"efq\\"\\r\\n \:given      '[contradiction]\\r\\n \:conclusion '[a]})" "(run* [q] ((eval (make-rule r)) 'contradiction q))" "(def r {\:name \\"equal-i\\"\\r\\n \:given      '[]\\r\\n \:conclusion '[(\= t t)]})" "(run* [q] ((eval (make-rule r)) q))" "(def r {\:name \\"equal-e\\"\\r\\n \:given      '[(\= a b)\\r\\n               (substitution phi a x)]\\r\\n \:conclusion '[(substitution phi b x)]})" "(run* [q] ((eval (make-rule r)) '(\= e f) '(substitution (P x) f e x) q))" "(run* [q] ((eval (make-rule r)) '(\= e f) '(substitution (P x) e x) q))" "(def r {\:name \\"forall-i\\"\\r\\n \:given      '[(infer (actual x0)\\r\\n                      (substitution phi x0 x))]\\r\\n \:conclusion '[(forall [x] phi)]})" "(run* [q] ((eval (make-rule r)) '(infer (actual g) (substitution (P x) g x)) q))" "(def r {\:name \\"forall-e\\"\\r\\n \:given      '[(forall [x] phi)]\\r\\n \:conclusion '[(substitution phi t x)]})" "(run* [q] ((eval (make-rule r)) '(forall [z] (P z)) q))" "(def r {\:name \\"exists-i\\"\\r\\n \:given      '[(substitution phi t x)]\\r\\n \:conclusion '[(exists [x] phi)]})" "(run* [q] ((eval (make-rule r)) '(substitution (P x) f x) q))" "(def r {\:name \\"exists-e\\"\\r\\n \:given      '[(exists [x] phi)\\r\\n               (infer [(actual x0)\\r\\n                       (substitution phi x0 x)]\\r\\n                      X)]\\r\\n \:conclusion '[X]})" "(run* [q] ((eval (make-rule r)) '(exists [y] (P y))\\n                                '(infer [(actual D)\\n                                         (substitution (P y) D y)]\\n                                        Y) q))" "(def r {\:name \\"and-i\\"\\r\\n \:given      '[a b]\\r\\n \:conclusion '[(and a b)]})" "(run* [q] ((eval (make-rule r)) nil nil q))" "(run* [q] ((eval (make-rule r)) q 'b '(and a b)))" "(run* [q] ((eval (make-rule r)) 'a q '(and a b)))" "(def r {\:name \\"and-e1\\"\\r\\n \:given      '[(and a b)]\\r\\n \:conclusion '[a]})" "(run* [q] ((eval (make-rule r)) q '(and a b)))" "(run* [q] ((eval (make-rule r)) q 'a))" "(def r {\:name \\"or-i1\\"\\r\\n \:given      '[a]\\r\\n \:conclusion '[(or a b)]})" "(run* [q] ((eval (make-rule r)) q '(or a b)))" "(def r {\:name \\"or-i2\\"\\r\\n \:given      '[a]\\r\\n \:conclusion '[(or b a)]})" "(run* [q] ((eval (make-rule r)) q '(or a b)))" "(def r {\:name \\"or-e\\"\\r\\n \:given      '[(or a b)\\r\\n               (infer a X)\\r\\n               (infer b X)]\\r\\n \:conclusion '[X]})" "(run* [q] ((eval (make-rule r)) q q q 'X))" "(run* [q] ((eval (make-rule r)) q '(infer a X) '(infer b X) 'X))" "(defn n\\n  [c]\\n  `(\=\= ~'q ~(cond\\n              (contains? keywords c) (list `quote c)\\n              (symbol? c) c\\n              (list? c) (gen-term c))))" "(map \#(n %) '[a b])" "(map \#(n %) '[a contradiction (and a (not b))])" "(clojure.core/seq (clojure.core/concat (clojure.core/list (quote and)) \\n                                       (clojure.core/list 'a) (clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list 'b)))))" "(gen-result '[a b])" "(into [] (map \#(inc %) '(1 2 3)))" "(gen-result '[a b])" "(gen-logic-function '[(and a b)] '[ a b])" "(def r {\:name \\"test\\"\\r\\n \:given '[(and a b)]\\r\\n \:conclusion '[a b]})" "(run* [q] ((eval (make-rule r)) '(and x y) q))" "(run* [q]\\n      (conde \\n        [(\=\= q 1) (\=\= q 2)]))" "(run* [q]\\n      (conde\\n        [(\=\= q 1)]\\n        [(\=\= q 2)]))" "(run* [q]\\n      (fresh [a b]\\n             (\=\= '(and x y) `(~'and ~a b))\\n             (conde\\n               [(\=\= q a)]\\n               [(\=\= q b)])))" "(run* [q]\\r\\n         (fresh [a b]\\r\\n                (\=\= '(and x y) `(~'and ~a ~b))\\r\\n                (conde\\r\\n                  [(\=\= q a)]\\r\\n                  [(\=\= q b)])))" "(apply vector ('(and a b) '(and x y)))" "(apply vector '((and a b) (and x y)))" "(for [x '((1) (2))]\\n  (vector x))" "(conj '([(1)] [(2)]) `conde)" "(gen-result '[a b])" "r" "(run* [q] ((eval (make-rule r)) '(and f g) q))" "(def r {\:name \\"exists-i\\"\\r\\n \:given      '[(substitution phi t x)]\\r\\n \:conclusion '[(exists [x] phi)]})" "(run* [q] ((eval (make-rule r)) '(substitution (P x) t x) q))" "(def r {\:name \\"test\\"\\r\\n \:given '[(and a b)]\\r\\n \:conclusion '[a b]})" "(run* [q] ((eval (make-rule r)) q 'b))" "(run* [q] ((eval (make-rule r)) q 'a))" "(def r {\:name \\"equal-e\\"\\r\\n \:given      '[(\= a b)\\r\\n               (substitution phi a x)]\\r\\n \:conclusion '[(substitution phi b x)]})" "(run* [q] ((eval (make-rule r)) '(substitution (P x) F x) '(\= F D) q))" "(run* [q] ((eval (make-rule r)) '(\= F D) '(substitution (P x) F x) q))" "(make-rule r)" "(def r {\:name \\"and-i\\"\\r\\n \:given      '[a b]\\r\\n \:conclusion '[(and a b)]})" "(run* [q] ((eval (make-rule r)) q q '(and a b)))" "(run* [q u] ((eval (make-rule r)) q u '(and a b)))" "(def r {\:name \\"or-e\\"\\r\\n \:given      '[(or a b)\\r\\n               (infer a X)\\r\\n               (infer b X)]\\r\\n \:conclusion '[X]})" "(run* [q u z] ((eval (make-rule r)) q u z 'X))" "(def r {\:name \\"test\\"\\r\\n \:given '[(and a b)]\\r\\n \:conclusion '[a b]})" "(run* [q] ((eval (make-rule r)) '(and a b) q))" "(conj [1 2 3] 'q)" "(apply \#(conj [1 2 3] %) '(q u z))" "(apply conj [1 2 3] '(q u z))" "(take 3 (cycle 'q))" "(take 3 (cycle ['q]))" "(def conclusion '[a b])" "(map \#(symbol (str %1 %2)) (take (count conclusion) (cycle ['q])) (take (count conclusion (iterate inc 1))))" "(map \#(symbol (str %1 %2)) (take (count conclusion) (cycle ['q])) (take (count conclusion) (iterate inc 1)))" "(def e1 (map \#(symbol (str %1 %2)) (take (count conclusion) (cycle ['q])) (take (count conclusion) (iterate inc 1))))" "e1" "(gen-result1 conclusion e1)" "(def given '[(and a b)])" "(def e2 (gen-args given))" "e2" "(apply conj e2 e1)" "(concat '(a b) '(c d))" "(gen-logic-function given conclusion)" "(run* [q u] ((eval (make-rule r)) '(and e f) q u))" "(run* [q u] ((eval (make-rule r)) q 'a 'b))" "(run* [q] ((eval (make-rule r)) q 'a 'b))" "(def r {\:name \\"and-i\\"\\r\\n \:given      '[a b]\\r\\n \:conclusion '[(and a b)]})" "(run* [q] ((eval (make-rule r)) 'a 'r q))" "(run* [q u] ((eval (make-rule r)) q u '(and e f)))" "(slurp \\"rules.clj\\")" "(slurp \\"src/deduction_playground/rules.clj\\")" "(require [clojure.java.io \:as io])" "(read-rules)" "(read-test)" "(if (read-test) true false)" "(read-test)" "(read-rules)" "(read-rules1)" "(\:given (\:equal-i (read-rules1)))" "(eval (\:given (\:equal-i (read-rules1))))" "(\:given (\:exists-i (read-rules1)))" "(apply rule \\"asd\\" '[a b c])" "(apply-rule \\"asd\\" '[1 2 3])" "(concat [1 2 3] '(4 5 6))" "(apply-rule \\"test\\" '[(and x y)])" "(apply-rule \\"test\\" '(and x y))" "(def e1 ((keyword \\"test\\") rules))" "e1" "(map \#(symbol (str %1 %2)) \\r\\n                        (take (count (\:conclusion e1)) (cycle ['q]))\\r\\n                        (take (count (\:conclusion e1)) (iterate inc 1)))" "(apply-rule \\"test\\" '(and x y))" "(def r ((keyword \\"test\\") rules))" "r" "logic-args (map \#(symbol (str %1 %2)) \\r\\n                        (take (count (\:given r)) (cycle ['q]))\\r\\n                        (take (count (\:given r)) (iterate inc 1)))" "\\n(map \#(symbol (str %1 %2)) \\r\\n                        (take (count (\:given r)) (cycle ['q]))\\r\\n                        (take (count (\:given r)) (iterate inc 1)))" "(concat '((and a b)) '(q1))" "(apply str '((and a b) q1))" "(apply-rule \\"test\\" '(and x y))" "(apply-rule \\"and-i\\" 'a 'b)" "(apply-rule \\"test\\" '(and c x))" "(apply-rule \\"test\\" '(and c d))" "(apply-rule \\"test\\" '(and e d))" "(apply-rule \\"test\\" '(and e f))" "(eval (apply-rule \\"test\\" '(and e g)))" "(apply-rule \\"and-e1\\" '(and a b))" "(apply-rule \\"and-e1\\" '(and e f))" "(let [fn (eval `(fn [a] (+ a 10)))]\\n  (fn 15))" "(let [fn (eval `(fn [~'a] (+ ~'a 10)))]\\r\\n     (fn 15))" "(apply-rule \\"test\\" '(and e g))" "(run* [q1] ((eval (make-rule {\:name \\"test\\"\\r\\n \:given '[(and a b)]\\r\\n \:conclusion '[a b]})) '(and e g) q1))" "(def r {\:name \\"test\\"\\r\\n \:given '[(and a b)]\\r\\n \:conclusion '[a b]})" "(run* [q] ((eval (make-rule r)) '(and e gh) q))" "(def r {\:name \\"and-i\\"\\r\\n \:given      '[a b]\\r\\n \:conclusion '[(and a b)]})" "(run* [q] ((eval (make-rule r)) 'a 'e q))" "(apply-rule \\"and-i\\" 'a 'e)" "(apply-rule \\"and-i\\" 'a 'e )" "(apply-rule \\"and-i\\" 'g 'e)" "r" "(into [] (map \#(symbol (str %1 %2)) \\r\\n                                 (take (count (\:conclusion r)) (cycle ['q]))\\r\\n                                 (take (count (\:conclusion r)) (iterate inc 1))))" "(apply-rule \\"and-i\\" 'g 'e)" "(run* [q u] ((eval (make-rule {\:name \\"test\\"\\r\\n \:given '[(and a b)]\\r\\n \:conclusion '[a b]})) '(and e fg) q u))" "(run* [q] (apply (eval (make-rule {\:name \\"and-e1\\"\\r\\n \:given      '[(and a b)]\\r\\n \:conclusion '[a]})) '((and e f) q)))" "(run* [q] (apply (make-rule {\:name \\"and-e1\\"\\r\\n \:given      '[(and a b)]\\r\\n \:conclusion '[a]}) '((and e f) q)))" "(let [fn (make-rule {\:name \\"and-e1\\"\\r\\n \:given      '[(and a b)]\\r\\n \:conclusion '[a]})]\\n  (run* [q] (apply fn '((and e f) q))))" "(apply-rule \\"and-e1\\" '(and e f))" "(run* [q] (apply (eval (make-rule {\:name \\"and-e1\\"\\r\\n \:given      '[(and a b)]\\r\\n \:conclusion '[a]})) '[(and e f) q]))" "(run* [q] (apply (eval (make-rule {\:name \\"and-e1\\"\\r\\n    \:given      '[(and a b)]\\r\\n    \:conclusion '[a]})) ['(and e f) 'q]))" "(run* [q] (apply (eval (make-rule {\:name \\"and-e1\\"\\r\\n    \:given      '[(and a b)]\\r\\n    \:conclusion '[a]})) '(and e f) q))" "`(run* [q] (apply (eval (make-rule {\:name \\"and-e1\\"\\r\\n    \:given      '[(and a b)]\\r\\n    \:conclusion '[a]})) '[(and e f) q]))" "(eval `(run* [q] (apply (eval (make-rule {\:name \\"and-e1\\"\\r\\n    \:given      '[(and a b)]\\r\\n    \:conclusion '[a]})) '[(and e f) q])))" "(eval `(run* [~'q] (apply (eval (make-rule {\:name \\"and-e1\\"\\r\\n    \:given      '[(and a b)]\\r\\n    \:conclusion '[a]})) '[(and e f) q])))" "(eval `(run* [~'q] ~(apply (eval (make-rule {\:name \\"and-e1\\"\\r\\n    \:given      '[(and a b)]\\r\\n    \:conclusion '[a]})) '[(and e f) q])))" "(apply-rule \\"test\\" '(and e f))" "r" "(def r {\:given '[(and a b)] \:conclusion '[a]})" "r" "(let [largs [q1 q2]\\n      args '((and a b) q1 q2)]\\n  (eval `(run* ~largs ~(conj ~args (eval (make-rule ~r))))))" "(let [largs '[q1 q2]\\r\\n         args '((and a b) q1 q2)]\\r\\n     (eval `(run* ~largs ~(conj ~args (eval (make-rule ~r))))))" "(let [largs '[q1 q2]\\r\\n         args '((and a b) q1 q2)]\\r\\n     (eval `(run* ~largs ~(conj ~args `(eval (make-rule ~~r))))))" "`(run* [~'q] ((eval (make-rule ~r)) '(and e b) ~'q))" "`(run* [~q] ((eval (make-rule ~r)) `(~'and ~'e ~'f) ~'q))" "`(run* [~'q] ((eval (make-rule ~r)) `(~'and ~'e ~'f) ~'q))" "(eval `(run* [~q] ((eval (make-rule ~r)) `(~'and ~'e ~'f) ~'q)))" "(eval `(run* [~'q] ((eval (make-rule ~r)) `(~'and ~'e ~'f) ~'q)))" "(make-rule r)" "(conj '((and e b) q) (make-rule r))" "(conj (conj '((and e g) q) (make-rule r)) `eval)" "(run* [q]  (conj (conj '((and e g) q) (make-rule r)) `eval))" "(def g (conj '((and e d) q) (make-rule r)))" "g" "(eval g)" "(run* [q] (eval g))" "g" "(def g (make-rule r))" "g" "(eval g)" "(def h (eval g))" "(run* [q] (h '(and e f) q))" "(let [t (eval g)]\\n  (run* [q] (t '(and e f) q)))" "(let [t (eval g)\\n      q '[q]\\n      u '(and e d)]\\n  (eval `(run* ~q (t u ~'q))))" "(let [t (eval g)\\r\\n         q '[q]\\r\\n         u '(and e d)]\\r\\n     (eval `(run* ~q (~'t u ~'q))))" "(let [t (eval g)\\r\\n         q '[q]\\r\\n         u '(and e d)]\\r\\n     (eval `(run* ~q (~t u ~'q))))" "(let [t (eval g)\\r\\n         q '[q]\\r\\n         u '(and e d)]\\r\\n     (eval `(run* ~q (t ~u ~'q))))" "(let [t (eval g)\\r\\n         q '[q]\\r\\n         u '(and e d)]\\r\\n     (eval `(run* ~q (~t ~u ~'q))))" "(let [t (eval g)\\r\\n            q '[q]\\r\\n            u '(and e d)]\\r\\n        (eval `(run* ~q (~t ~`u ~'q))))" "(let [t (eval g)\\n      q '[q]\\n      u '(and e d)]\\n  (eval (list `run* q (list t u 'q))))" "(let [t (eval g)\\r\\n         q '[q]\\r\\n         u '(and e d)]\\r\\n     (list `run* q (list t u 'q)))" "(let [fn \#(+ % 10)]\\n  (eval (list fn 12)))" "(let [t (eval g)\\r\\n         q '[q]\\r\\n         u '(and e d)]\\r\\n     (eval (list `run* q (list t (list u) 'q))))" "(let [t (eval g)\\r\\n         q '[q]\\r\\n         u '(and e d)]\\r\\n     (eval (list `run* q (list t (quote u) 'q))))" "(let [t (eval g)\\r\\n            q '[q]\\r\\n            u '(and e d)]\\r\\n        (list `run* q (list t (quote u) 'q)))" "(let [t (eval g)\\r\\n            q '[q]\\r\\n            u '(and e d)]\\r\\n        (eval (list `run* q (list t (quote (list u)) 'q))))" "(let [t (eval g)\\r\\n            q '[q]\\r\\n            u '(and e d)]\\r\\n        (eval (list `run* q (list t '(and e d) 'q))))" "(let [t (eval g)\\r\\n            q '[q]\\r\\n            u '(and e d)]\\r\\n        (eval (list `run* q (list t ''(and e d) 'q))))" "(quote (list '(a e d)))" "(let [t (eval g)\\r\\n               q '[q]\\r\\n               u '(and e d)]\\r\\n           (eval (list `run* q (list t (quote (list u)) 'q))))" "(let [t (eval g)\\r\\n               q '[q]\\r\\n               u '(and e d)]\\r\\n           (eval (list `run* q (list t ''~u 'q))))" "(let [t (eval g)\\r\\n               q '[q]\\r\\n               u '(and e d)]\\r\\n           (eval (list `run* q (list t '~u 'q))))" "(let [t (eval g)\\r\\n               q '[q]\\r\\n               u '(and e d)]\\r\\n           (eval (list `run* q (list t `(quote ~u) 'q))))" " (let [t (eval g)\\r\\n                  q '[q]\\r\\n                  u '(and e d)\\n                  p '((and e d) q)]\\r\\n              (eval (list `run* q (conj p t))))" "(let [t (eval g)\\r\\n                     q '[q]\\r\\n                     u '(and e d)\\r\\n                     p '((and e d) q)]\\r\\n                 (eval (list `run* q (conj `(quote ~p) t))))" "(concat '(t) '((and e f) q))" "(let [t (eval g)\\r\\n                     q '[q]\\r\\n                     u '(and e d)\\r\\n                     p ((quote (and e d)) (quote q))]\\r\\n                 (eval (list `run* q (concat t p))))" "(let [t (eval g)\\r\\n                        q '[q]\\r\\n                        u '(and e d)\\r\\n                        p ((quote (and e d)) (quote q))]\\r\\n                    (list `run* q (concat t p)))" "(let [t (eval g)\\r\\n                        q '[q]\\r\\n                        u '(and e d)\\r\\n                        p ((quote (and e d)) (quote q))]\\r\\n                    (eval (list `run* q (list concat t p))))" "(let [t (eval g)\\r\\n                        q '[q]\\r\\n                        u '(and e d)\\r\\n                        p ((quote (and e d)) (quote q))]\\r\\n                    (eval (list `run* q (list t p))))" "(let [t (eval g)\\r\\n      q '[q]\\r\\n      u '(and e d)\\r\\n      p ((quote (and e d)) (quote q))]\\r\\n  (list `run* q (conj p t)))" "(let [t (eval g)\\r\\n         q '[q]\\r\\n         u '(and e d)\\r\\n         p ((quote (and e d)) (quote q))]\\r\\n     (list `run* q (conj `(quote ~p) t)))" "(let [t (eval g)\\r\\n         q '[q]\\r\\n         u '(and e d)\\r\\n         p ((and e d) q)]\\r\\n     (list `run* q (conj `(quote ~p) t)))" "(let [t (eval g)\\r\\n            q '[q]\\r\\n            u '(and e d)\\r\\n            p '((and e d) q)]\\r\\n        (list `run* q (conj `(quote ~p) t)))" "(let [t (eval g)\\r\\n               q '[q]\\r\\n               u '(and e d)\\r\\n               p '((and e d) q)]\\r\\n           (list `run* q (concat (list t) `(quote ~p) )))" "(let [t (eval g)\\r\\n      q '[q]\\r\\n      u '(and e d)\\r\\n      p '((and e d) q)\\n      p2 (map \#(`(quote ~%1)) p)]\\r\\n  (list `run* q (concat (list t) p2)))" "(let [t (eval g)\\r\\n         q '[q]\\r\\n         u '(and e d)\\r\\n         p '((and e d) q)\\r\\n         p2 (map \#(`(quote ~%1)) p)]\\r\\n     p2)" "(let [t (eval g)\\r\\n         q '[q]\\r\\n         u '(and e d)\\r\\n         p '((and e d) q)\\r\\n         p2 (map \#(list `(quote ~%1)) p)]\\r\\n     p2)" "(let [t (eval g)\\r\\n         q '[q]\\r\\n         u '(and e d)\\r\\n         p '((and e d) q)\\r\\n         p2 (map \#(quote %1) p)]\\r\\n     p2)" "(let [t (eval g)\\r\\n         q '[q]\\r\\n         u '(and e d)\\r\\n         p '((and e d) q)\\r\\n         p2 (map \#(quote ~%) p)]\\r\\n     p2)" "(let [t (eval g)\\r\\n         q '[q]\\r\\n         u '(and e d)\\r\\n         p '((and e d) q)\\r\\n         p2 (map \#(conj (list %) `quote) p)]\\r\\n     p2)" "(let [t (eval g)\\r\\n            q '[q]\\r\\n            u '(and e d)\\r\\n            p '((and e d) q)\\r\\n            p2 (map \#(conj (list %) `quote) p)]\\r\\n        (list `run* q (conj p2 t)))" "(let [t (eval g)\\r\\n               q '[q]\\r\\n               u '(and e d)\\r\\n               p '((and e d) q)\\r\\n               p2 (map \#(conj (list %) `quote) p)]\\r\\n           (eval (list `run* q (conj p2 t))))" "g" "(run* [q] ((eval g) (quote (and e f)) (quote q)))" "(let [t (eval g)\\r\\n               q '[q]\\r\\n               u '(and e d)\\r\\n               p '((and e d))\\r\\n               p2 (map \#(conj (list %) `quote) p)\\n               p3 (concat p2 (first q))]\\r\\n           (list `run* q (conj p3 t)))" "(run* [q] ((eval g) (quote (and e f)) q))" "(let [t (eval g)\\r\\n                  q '[q]\\r\\n                  u '(and e d)\\r\\n                  p '((and e d))\\r\\n                  p2 (map \#(conj (list %) `quote) p)]\\r\\n              p2)" "(let [t (eval g)\\r\\n                  q '[q]\\r\\n                  u '(and e d)\\r\\n                  p '((and e d))\\r\\n                  p2 (map \#(conj (list %) `quote) p)\\r\\n                  p3 (concat p2 '(q))]\\r\\n              (list `run* q (conj p3 t)))" "(let [t (eval g)\\r\\n                     q '[q]\\r\\n                     u '(and e d)\\r\\n                     p '((and e d))\\r\\n                     p2 (map \#(conj (list %) `quote) p)\\r\\n                     p3 (concat p2 '(q))]\\r\\n                 (eval (list `run* q (conj p3 t))))" " (let [t (eval g)\\r\\n       q '[q]\\r\\n       u '(and e d)\\r\\n       p '((and e d))\\r\\n       p2 (map \#(conj (list %) `quote) p)\\r\\n       p3 (concat p2 q)]\\r\\n   (eval (list `run* q (conj p3 t))))" "(def g (make-rule (\:and-e1 rules)))" "g" "(t \\"and-e1\\" '(and e d))" "(t \\"and-e1\\" '(and e d) 'a)" "(t \\"and-e1\\" '(and e d))" "(t \\"and-e1\\" '(and e f))" "(t \\"and-i\\" 'a 'e)" "(t \\"test\\" '(and e f))" "(apply-rule \\"forall-i\\" '(infer (actual F)\\n                               (substitution (P x) F x)))" "(apply-rule \\"test\\" '(and e f))" "(apply-rule \\"raa\\" '(infer (not r) contradiction))" "(apply-rule \\"and-i\\" 'e 'f 'a 'b)" "(apply-rule \\"or-i1\\" 'a 'b)" "(apply-rule \\"or-i2\\" 'g)" "(run* [q] ((eval (make-rule \\"or-i1\\")) q '(or e f)))" "(make-rule \\"or-i2\\")" "(string? \\"asdasd\\")" "(make-rule \\"or-i1\\")" "(make-rule \\"or-i2\\")" "(run* [q] ((eval (make-rule \\"or-i2\\")) q '(or e f)))" "(run* [q] ((eval (make-rule {\:given '[X]\\n                             \:conclusion '[(or a b)\\r\\n               (infer a X)\\r\\n               (infer b X)]})) 'F q))" "(make-rule {\:given '[X]\\r\\n                                \:conclusion '[(or a b)\\r\\n                  (infer a X)\\r\\n                  (infer b X)]})" "(run* [q u z] ((eval (make-rule {\:given '[X]\\r\\n                                \:conclusion '[(or a b)\\r\\n                  (infer a X)\\r\\n                  (infer b X)]})) 'F q u z))" "(apply-rule \\"or-e-backwards\\" 'F)" "(\= 'a 'a)" "(\= 'd 'b)" "(change-symb '(not a b) 'b 'c)" "(change-symb '(not e f) 'b 'g)" "(change-symb '(not _0 a) '_0 'b)" "(change-symb '(or (not a) b) 'a 'c)" "(replace '{_0 a} '(not (or _0) _0))" "(change-symb '(or _0 a g _0) '_0 'a)" "(source replace)" "(use 'clojure.repl)" "(source replace)" "(vector? '(not a b))" "(defn t\\n  [smap coll]\\n  (map \#(if (list? %)\\n          (t smap %)\\n          (if-let [e (find smap %)] (val e) %)) coll))" "(t '{_0 a} '(or (not _0) a))" "(t '{_0 a _1 b} '(or (not _0) (and (not _1) _0)))" "(t '{x F} '(forall [x] (and a x)))" "(map inc [1 2 3])" "(into [] (map inc [1 2 3]))" "(defn t\\n  [smap coll]\\n  (cond \\n    (list? coll)\\n    (map \#(if (coll? %)\\n            (t smap %)\\n            (if-let [e (find smap %)] (val e) %)) coll)\\n    \\n    (vector? coll)\\n    (into [] (map \#(if (coll? %)\\r\\n                     (t smap %)\\r\\n                     (if-let [e (find smap %)] (val e) %)) coll))))" "(t '{x F} '(forall [x] (P x)))" "(t '{x F} (forall [x (not y)] (and (P x) (not y))))" "(t '{x F} '(forall [x (not y)] (and (P x) (not y))))" "(t '{x E y F} '(forall [x (not y)] (and (P x) (not y))))" "(nreplace '{x E y F} '(forall [x (not y)] (and (P x) (not y))))" "(apply-rule \\"and-i\\" 'e 'f)" "(apply-rule \\"test\\" '(and e f))" "(apply-rule \\"or-e-backwards\\" 'F)" "(apply-rule \\"forall-i\\" '(infer (actual d) (substitution (P x) d x)))" "(proof '(infer (and a b)))" "(proof '(infer [a] (or a b)))" "(into [] '(1 2 3))" "(conj [1 2 3] [4 5])" "(concat [1 2 3] [4 5])" "(concat [1 2 3] 4 5)" "(concat '(1 2 3) [4 5])" "(proof '[a b] '(and a b))" "(proof '(infer [a b] (and a b)))" "(proof '(infer [(and a b) (or b c) a] (impl a c)))" "(step \\"\\" 1)" "(step \\"\\" 1 2 3)" "(step \\"\\" 1)" "(step \\"\\" 1 2 3)" "(step \\"\\")" "(log/count-given \\"and-i\\")" "(rest [1 2 3])" "(todo p)" "p" "(if (\= \:todo (\:body (first [{\:body a, \:rule \:premise} {\:body b, \:rule \:premise} {\:body \:todo, \:rule nil} {\:body (and a b), \:rule nil}]))) true)" "(if (\= \:todo (\:body (first '[{\:body a, \:rule \:premise} {\:body b, \:rule \:premise} {\:body \:todo, \:rule nil} {\:body (and a b), \:rule nil}]))) true)" "(\:body (first '[{\:body a, \:rule \:premise} {\:body b, \:rule \:premise} {\:body \:todo, \:rule nil} {\:body (and a b), \:rule nil}]))" "(\= \:todo 'a)" "(rest '[{\:body a, \:rule \:premise} {\:body b, \:rule \:premise} {\:body \:todo, \:rule nil} {\:body (and a b), \:rule nil}])" "(if (\= \:todo (\:body (first '({\:body b, \:rule \:premise} {\:body \:todo, \:rule nil} {\:body (and a b), \:rule nil})))) true)" "(if (\= \:todo (\:body (first '({\:body \:todo, \:rule nil} {\:body (and a b), \:rule nil})))) true)" "(todo p)" "(> 0 1)" "(> 1 0)" "(< 1 2)" "(count [1 2 3])" "(nth [1 2 3] 0)" "(step p \\"and-i\\" 1 2)" "(map \#(\:body (nth p (dec %))) '(1 2))" "(concat [p] '(a b))" "(step p \\"and-i\\" 1 2)" "(step p \\"and-i\\" 1 2 3)" "(step p \\"and-i\\" 1 5)" "(step p \\"and-i\\" 1 2)" "(> 2 1)" "(log/apply-rule \\"and-e1\\" '(and a b))" "(todo p)" "(def v [1 2 3 4 5 6 7])" "(concat (subvec v 0 3) (subvec v 3))" "(concat (subvec v 0 3) (subvec v 4))+" "(step p \\"and-i\\" 1 2)" "(step p2 \\"and-i\\" 1 2)" "(subvec p2 (todo p))" "(concat (subvec proof 0 (dec (todo proof))) [{\:body \:jkoghjffg\\r\\n                                                        \:rule rule}] (subvec proof (todo proof)))" "(concat (subvec proof 0 (dec (todo proof))) [{\:body \:blabla\\r\\n                                                        \:rule \\"asd\\"}] (subvec proof (todo proof)))" "(concat (subvec p2 0 (dec (todo p2))) [{\:body \:bla\\r\\n                                                        \:rule \\"asd\\"}] (subvec p2 (todo p2)))" "(subvec p2 0 (dec (todo p2)))" "(todo p2)" "(step p2 \\"and-i\\" 1 2)" "(step p \\"and-i\\" 1 2)" "(stp p2 \\"and-i\\" 1 2)" "(step p2 \\"and-i\\" 1 2)" "(str \\"asd\\" '(1 2 3))" "(distinct? '(1 2 3 1))" "(apply distinct? '(1 2 3 1))" "(apply distinct? '(1 2 3))" "(flatten [1 2 [4 5 [6 7]] 8])" "(flatten [1 2 3])" "(sort '(2 4 1 4 2 6 7))" "(scope \\"\\" '(6 2 (between 3 9)))" "(scope \\"\\" '( 1 2 (between 4 6) 8))" "(conj [1 2 3] [4 5])" "(conj \#{1 2} 3)" "(scope p3 '(2 3))" "(scope p3 '(1 6))" "(vector? (first [[{}] 6]))" "(list 'between 2 4)" "(\= '(a b c) '(a b  c))" "(<\= 6 5)" "(scope p3 '(2 5))" "(last '(between 3 5))" "(scope p3 '(1 6))" "(conj \#{} '(between 2 4))" "(scope p3 '(6))" "(subvec [1 2 3] 0)" "(scope p3 '(6))" "(scope p3 '(5))" "(scope p3 '(2))" "(scope p3 '(3))" "(\= 5 '(and 3 d))" "(<\= 3 (last '(between 3 5)))" "(scope p3 '(3))" "(<\= 3 (last '(between 3 5)))" "(<\= last (last elem))" "(scope p3 '(3))" "(scope p3 '(6))" "(scope p3 '(1 3 6))" "(scope1 [1 2 [3 4 5] 6])" "(scope1 '[a b [c d e] f])" "(scope1 '[a b [c d] e [f g [h i j] k] l m])" "(scope1 '[a b [[c d] [e f]]])" "(between 3 5)" "(in-scope? '(1 2 (between 3 5)))" "(in-scope? \\"\\" '(1 2 (between 3 5)))" "(step \\"\\" \\"\\" 1 2 (between 3 5))" "(scope1 '[a b [c d] e] 2)" "(contains? [1 2 [3 4]] 3)" "(scope-for [1 2 [3 4] 5] 3)" "(scope-for [1 2 [3 4] 5] 5)" "(scope-for [1 2 [3 4] [5 6] 7] 6)" "(subvec [1] 1)" "(scope-for (scope1 [1 2 [3 4] [5 6] 7]) 6)" "(in-scope? [1 2 [3 4] [5 6 [7 8]] 9] '(1 [3 4] 6))" "(in-scope? p3 '(1 3 4))" "(in-scope? p3 '(1 3 6))" "(step \\"\\" \\"\\")" "(empty? nil)" "(in-scope? p3 '(7))" "(in-scope? p3 '(6))" "(scope-for (scope1 '[a b [c d] e f]) [3 4])" "(inner-scope [1 2 [3 4] [5 6 7] 8] 5)" "(set [1 2 [3 4] [ 5 6 7] 8])" "(inner-scope [1 2 [3 4] [5 6 7] 8] 5)" "(inner-scope [1 2 [3 4] [5 6 7] 8] 8)" "(inner-scope [1 2 [3 4] [5 6 7] 8] 5)" "(inner-scope [1 2 [3 4] [5 6 7] 8] 4)" "(inner-scope [1 2 [3 4] [5 6 7] 8] 8)" "(inner-scope [1 2 [3 4] [5 6 7] 8 9 10] 8)" "(todo-in-scope p3 '(1 3))" " (todo-in-scope p3 '(1 3))" "(todo-in-scope p4 '(1))" "(todo-in-scope p4 '(1 2))" " (todo-in-scope p3 '(1))" " (todo-in-scope p4 '(1))" "(todo-in-scope p4 '(1))" "(nth [1 2] 3)" "(step p4 \\"or-i1\\" 2)" "(step p \\"and-i\\" 1 2)" "(use 'clojure.repl)" "(source nth)" "(flatten {\:a 1})" "(nth '(1 2 3) 2)" "(assoc-in [1 [2 3]] [1 0] 44)" "(source assoc-in)" "(update-in [1 [2 3]] [1 2] 44)" "(assoc-in [1 [2 3]] [1 2] 44)" "(find {\:a 1 \:b {\:c 2 \:d 3}} \:d)" "(scope-for-line p 7)" "(scope-for-line p 2)" "(scope-for-line p 3)" "(scope-for-line p 7)" "(time (scope-for-line p 7))" "(scope-for-line1 p1 3)" "(scope-for-line1 p1 2)" "(scope-for-line1 p1 4)" "(nth (flatten p1) 3)" "(scope-for-elem p1 (nth (flatten p1) 4))" "(scope-for-elem p1 (nth (flatten p1) 2))" "(scope-for-elem p1 (nth (flatten p1) 1))" "(scope-for-elem p1 (nth (flatten p1) 4))" "(\:body [{\:body 1} {\:body 2}])" "(scope-for-line p1 5)" "(scope-for-line p1 3)" "(def sc (scope-for-line p1 3))" "(get-todo sc)" "(get-result sc)" "(source assoc-in)" "(use 'clojure.repl)" "(source assoc-in)" "(.indexOf \:a [\:a \:b \:c])" "(.indexOf [\:a \:b \:c] \:a)" "(.indexOf [\:a \:b \:c] \:d)" "(subvec [1 2] 0 0)" "(subvec [1 2] 0 1)" "(subvec [1 2] 2 3)" "(subvec [1 2] 2)" "(subvec [1 2] 1)" "(subvec [1 2 3 4 5] 2)" "(subvec [1 2 3 4 5] 0 2)" "(subvec [1 2 3 4 5] 2)" "(add-line p1 3 {\:test 12})" "(add-line p1 (nth (flatten p1) 2) {\:test 12})" "(add-line p1 (nth (flatten p1) 2) {\:test 12})+\#" "(add-line p1 (nth (flatten p1) 2) {\:test 12})" "(add-line p2 (nth (flatten p2) 4) {\:bla 12})" "(time (add-line p2 (nth (flatten p2) 4) {\:bla 12}))" "(add-line p2 (nth (flatten p2) 4) {\:bla 12})" "(time (add-line p2 (nth (flatten p2) 4) {\:bla 12}))" "(add-line p2 (nth (flatten p2) 4) {\:bla 12})" "(add-line p2 4 {\:bla 12})" "(change-line p2 4 {\:bla 12})" "(in-scope? p4 '(1 3 4))" "(last (sort (flatten '(1 3 4))))" "(scope/scope-for-line p4 4)" "(in-scope? p4 '( 1 3 4))" "(in-scope? p4 '(1 3 4))" "(in-scope? p4 '( 1 3 4))" "(in-scope? p4 '(1 3 4))" "(def a (set [{\:body (or a b), \:rule \:premise} {\:body a, \:rule \:assumption} {\:body \:todo, \:rule nil} {\:body X, \:rule nil}]))" "(def a (set '[{\:body (or a b), \:rule \:premise} {\:body a, \:rule \:assumption} {\:body \:todo, \:rule nil} {\:body X, \:rule nil}]))" "a" "(contains? a (nth (flatten p4) 2))" "(in-scope? p4 '( 1 3 4))" "(in-scope? p4 '(2 5))" "(in-scope? p4 '(1 5 8))" "(in-scope? p4  '(1 4 8))" "(get-item p4 [2 4])" "(get-item p5 [3 5])" "(get-item p5 9)" "(in-scope? p4 '( 1 2 8))" "(in-scope? p4 '([2 4] [5 7] 8))" "(in-scope? p5 '(2 [3 5] 9))" "(step p \\"and-i\\" 1 2)" "(step p \\"or-i1\\" 1)" "(step p \\"o-i1\\" 2)" "(step p \\"or-i1\\" 2)" "(new-id)" "(infer '[a b] '(and a b))" "(infer '(or a b))" "(log/apply-rule \\"or-e-backwards\\" X)" "(log/apply-rule \\"or-e-backwards\\" 'X)" "(infer 'a 'b)" "(defn t\\n  [[bla]]\\n  bla)" "(t \\"asd\\")" "(t [\\"as\\"])" "(t 'a)" "(vec 'a)" "(vector 'a)" "(vector '[a])" "(infer 'a 'b)" "(infer 'a)" "(check-args p \\"bla\\" '(1 2))" "(check-args p \\"and-i\\" '(1 2 3))" "(check-args p \\"and-i\\" '(1 2 3 1))" "(check-args p \\"and-i\\" '(1 2))" "(step1 p \\"and-i\\" 1 2)" " (step1 p \\"and-i\\" 1 2)" "(step1 (infer '[a b] '(and a b)) \\"and-i\\" 1 2)" "(step1 (infer '[a b] '(and a b)) \\"or-i1\\"  2)" "(step1 (infer '[a b] '(and a b)) \\"or-i2\\"  3)" "(between 2 5)" "(step1 (infer '[a b] '(and a b)) \\"or-i1\\"  3)" "(log/apply-rule \\"and-i\\" false '(and a b))" "(first 1)" "(scope-for-lines '(1 [2 7] [3 5]))" "(scope-for-lines \\"\\" '(1 [2 7] [3 5]))" "(scope-for-lines p2 '(1 [4 6] [7 9]))" "(scope-for-lines p2 '(2 3 4))" "(get-todo (scope-for-lines p2 '(2 3 4)))" "(get-result (scope-for-lines p2 '(2 3 4)))" "(check-args p4 \\"or-e\\" 1 (between 2 4) (between 5 7))" "(check-args p4 \\"or-e\\" '(1 [2 3 4] [5 6 7]))" " (check-args p4 \\"or-e\\" '(1 5))" "(step1 p3 \\"and-i\\" 3 5)" "(scope/scope-for-line p3 5)" "(scope/scope-for-line p3 3)" "(scope/scope-for-line p3 4)" "(scope/scope-for-line p3 2)" "(get-item-on-line p3 2)" "(scope/scope-for-elem p3 (get-item-on-line p3 2))" "(scope/scope-for-line p3 5)" "(get-item-on-line p3 5)" "(step1 p3 \\"and-i\\" 3 5)" "(check-args p3 \\"and-i\\" '(3 5))" "(check-args p3 \\"and-i\\" '(3 4))" "(step1 p3 \\"and-i\\" 2 3)" "(log/apply-rule \\"and-i\\" true '(not f) 'f)" "(check-args p3 \\"and-i\\" '(2 3))" "(step1 p3 \\"and-i\\" 2 3)" "(concat [\\"hallo\\"] '((not f) f))" "(step1 p \\"and-i\\" 1 2)" "(step1 p3 \\"and-i\\" 2 3)" "(scope/scope-for-line p3 5)" "(step-f p \\"and-i\\" 1 2)" "(step-f p4 \\"or-e\\" 1 [2 4] [5 7])" "(filter \#(\= (\:body %) \:todo) '[{\:id 1, \:body (or a b), \:rule \:premise} [{\:id 2, \:body a, \:rule \:assumption} {\:id 3, \:body \:todo, \:rule nil} {\:id 4, \:body X, \:rule nil}] [{\:id 5, \:body b, \:rule \:assumption} {\:id 6, \:body \:todo, \:rule nil} {\:id 7, \:body X, \:rule nil}] {\:id 8, \:body \:todo, \:rule or-e (1 (2-4) (5-7))}])" "(def a '[{\:id 1, \:body (or a b), \:rule \:premise} [{\:id 2, \:body a, \:rule \:assumption} {\:id 3, \:body \:todo, \:rule nil} {\:id 4, \:body X, \:rule nil}] [{\:id 5, \:body b, \:rule \:assumption} {\:id 6, \:body \:todo, \:rule nil} {\:id 7, \:body X, \:rule nil}] \\n         {\:id 8, \:body \:todo, \:rule \\"or-e (1 (2-4) (5-7))\\"}])" "a" "(filter \#(\= (\:body %) \:todo) a)" "(filter \#(and (nil? (\:rule %))\\r\\n                (not\= (\:body %) \:todo)) a)" "(step-f p4 \\"or-e\\" 1 [2 4] [5 7])" "@id" "(step-f p4 \\"or-e\\" 1 [2 4] [5 7])" "(infer '[a] b)" "(infer '[a] 'b)" "(arg-for-line p6 2)" "(arg-for-line p6 [2 5])" "(step-f p6 \\"exists-e\\" 1 [2 5])" "(log/apply-rule \\"exists-e\\" '(exists [x] (P x)) '(infer [(actual z) (substitution (P x) z x)] X))" "(log/apply-rule \\"exists-e\\" true '(exists [x] (P x)) '(infer [(actual z) (substitution (P x) z x)] X))" "(arg-for-line p6 1)" "(arg-for-line p6 [2 5])" "(step-f p6 \\"exists-e\\" 1 [2 5])" "(step-f p6 \\"and-i\\" 1 7)" "(if-let [a '()]\\n  true\\n  false)" "(pprint proof/p)" "(take 3 (cycle \\" \\"))" "(str (take 3 (cycle \\" \\")))" "(str [\\" \\" \\" \\" \\" \\"])" "(apply str (take 3 (cycle \\" \\")))" "(count \\"asdasdasdasd\\")" "(pprint proof/p)" "(count \\"...\\")" "(pprint proof/p)" "(pprint proof/p4)" "(str )" "(apply str [])" "(pprint proof/p4)" "(pprint proof/p5)" "(pprint proof/p4)" "(pprint (proof/step-f p4 \\"or-i1\\" 1 2))" "(pprint (proof/step-f proof/p4 \\"or-i1\\" 1 2))" "(pprint (proof/step-f proof/p4 \\"or-i1\\" 2))" "(pprint proof/p4)" "(pprint (proof/step-f proof/p4 \\"or-i1\\" 2))" "(proof/step-f proof/p4 \\"or-i1\\" 2)" "(pprint (proof/step-f proof/p \\"or-i1\\" 2))" "(str '(or b _0))" "(def a (iterate inc 1))" "(take 3 a)" "(str a)" "(def a (map inc [1 2 3]))" "a" "(str a)" "(str (doall a))" "(apply str a)" "(apply str \\"hallo\\")" "(pprint (proof/step-f proof/p4 \\"or-i1\\" 2))" "(pprint (proof/step-f proof/p \\"or-i1\\" 2))" "(pprint (proof/step-f proof/p4 \\"or-i1\\" 2))" "(pprint (proof/step-f proof/p \\"and-i\\" 1 2))" "(reverse [1 2 3])" "(reverse [1 2 [3 4] 5])" "(reverse-proof [1 2 [3 4] 5 6])" "(cons 1 [2 3 4])" "(reverse-proof [1 2 [3 4] 5])" "(conj [1 2] [3])" "(reverse-proof [1 2[ 3 4] 5])" "(check-args p \\"or-e\\" '(4) false)" "(check-args p4 \\"or-e\\" '(8) false)" "(check-args p5 \\"or-e\\" '(10) false)" "(check-args p6 \\"or-e\\" '(7) false)" "(.indexOf [1 2 3] 3)" "(subvec [1 2 3] 0 2)" "(subvec [1 2 3] 2)" "(step-b p \\"efq\\" 4)" "(\= (first '(infer a b)) 'infer)" "(def a '(infer a b))" "a" "(if (\= (first a) 'infer)\\n  (eval a)\\n  false)" "(log/apply-rule \\"or-e\\" false 'X)" "(eval (conj (map \#(quote %) (rest '(infer a b))) 'infer))" "(conj (map \#(quote %) (rest '(infer a b))) 'infer)" "(rest '(infer a b))" "(map \#(quote %) '(a b))" "'a" "(conj (map \#(list (quote %)) (rest '(infer a b))) 'infer)" "(conj (map \#(quote %) '(a b)) 'infer)" "(conj (rest '(infer a b)) 'infer)" "(map % '(a b))" "(conj (map \#(list `quote %) (rest '(infer a b))) 'infer)" "(eval (conj (map \#(list `quote %) (rest '(infer a b))) 'infer))" "(def a (scope/scope-for-line p 1))" "a" "(def b '({\:id 4, \:body (and a b), \:rule nil} \\n          {\:id 3, \:body \:todo, \:rule nil}))" "b" "(reduce \#(scope/change-item %1 %2\\n                            {\:id (\:id %2)\\n                             \:body (\:body %2)\\n                             \:rule \\"Test\\"}) p b)" "(step-b p \\"efq\\" 4)" "(step-b p \\"not-i\\" 4)" "(set '(1 2 3 4 1))" "(step-b p7 \\"exists-i\\" 3)" "(filter \#(\= 1 %) [2 3 4 1])" "(step-f p8 \\"test\\" 1)" "(step-b p8 \\"and-e1\\" 3)" "(defn a \\n  [s & [todo lines]]\\n  (println s)\\n  (println todo)\\n  (println lines))" "(a \\"asd\\" 1 2 3 4)" "(defn bla \\n  ([a & b] (bla a nil b))\\n  ([a z & b] \\n    (println a)\\n    (println z)\\n    (println b)))" "(defn bla\\n  ([a] (println a))\\n  ([a & b] (println a b)))" "(bla \\"asd\\")" "(bla 1 2 3 4 )" "(defn bla\\n  ([a & b] (println a))\\n  ([a z & b] (println a)))" "(def a (infer 'a 'b))" "a" "(step-f a \\"or-i1\\" 1)" "(infer 'a 'b)" "(infer '[(not a) a] 'b)" "(step-f p \\"and-i\\" 1 2)" "(step-f p \\"or-i1\\" 1)" "(def a (infer '[a b] '(and a b)))" "a" "(line-to-id a 3)" "(id-to-line a 2)" "(flatten a)" "(id-to-line a 2)" "(def b '[{\:id 3 \:body a \:rule \:premise}\\n         {\:id 1 \:body \:todo \:rule nil}\\n         {\:id 5 \:body b \:rule nil}])" "b" "(id-to-line b 5)" "(line-to-id b 2)" "a" "(get-itema 3)" "(get-item a 3)" "(id-to-line a 3)" "(get-item a 3)" "(get-item b 5)" "(first [])" "(some \#(contains? (set [1 2 3]) %) [4 5 6 3])" "(some \#(contains? (set [1 2 3]) %) [4 5 6 7])" "(check-args a \\"\\" '(1 2) true)" "a" "(def a (infer '[a b] '(and a b)))" "a" "(check-args a \\"\\" '(1 2) true)" "(check-args a \\"\\" '(1 4) true)" "(check-args a \\"\\" '(1 3) true)" "(check-args a \\"\\" '(1 2) true)" "(check-args a \\"\\" '(1 4) true)" "(check-args a \\"\\" '(1 3) true)" "(def b '[{\:id 1 \:body a \:rule \:premise}\\n         {\:id 2 \:body b \:rule \:premise}\\n         [{\:id 3 \:body c \:rule \:assumption}\\n          [{\:id 4 \:body (not a) \:rule \:assumption}{\:id 5 \:body \:todo \:rule nil}{\:id 6 \:body d \:rule nil}]\\n          [{\:id 7 \:body (not b) \:rule \:assumption}{\:id 8 \:body \:todo \:rule nil}{\:id 9 \:body e \:rule nil}]\\n          {\:id 10 \:body (or d e) \:rule \\"bla (4 6) (7 9)\\"}]\\n         {\:id 11 \:body (or d e) \:rule \\"test\\"}])" "b" "(check-args b \\"\\" '(2 3 4) true)" "(check-args b \\"\\" '(2 3 4 7) true)" "(check-args b \\"\\" '(2 3 4 10) true)" "(check-args b \\"\\" '(1 11) true)" "(check-args b \\"\\" '(2 3 9) true)" "(check-args b \\"\\" '(2 3 4) true)" "(def a (infer 'a 'b))" "a" "(step-f a \\"\\" true 1)" "(def b '[{\:id 1 \:body a \:rule \:premise}\\n         [{\:id 2 \:body b \:rule \:assumption}\\n          {\:id 3 \:body \:todo \:rule nil}\\n          {\:id 4 \:body e \:rule nil}]\\n         {\:id 6 \:body e \:rule nil}])" "b" "(step-f b \\"\\" true 1 (between 2 4))" "b" "(def b '[{\:id 1, \:body a, \:rule \:premise} \\n         [{\:id 2, \:body b, \:rule \:assumption} \\n          {\:id 4, \:body e, \:rule nil}]\\n         {\:id 3 \:body \:todo \:rule nil}\\n         {\:id 6, \:body e, \:rule nil}])" "b" "(step-f b \\"\\" true 1 (between 2 4))" "a" "(step-f a \\"or-i1\\" 1)" "(scope/get-open (scope/scope-for-line a 1))" "(def c '[{\:id 1 \:body a \:rule \:premise}\\n         {\:id 2 \:body \:todo \:rule nil}\\n         {\:id 4 \:body b \:rule nil}\\n         {\:id 7 \:body \:todo \:rule nil}\\n         {\:id 8 \:body c \:rule nil}\\n         {\:id 9 \:body (and b c) \:rule \\"and-i (4 8)\\"}])" "(step-f c \\"and-i\\" 1 2)" "(step-f c \\"and-i\\" 1 3)" "(step-f c \\"or-i1\\" 1)" "(step-f c \\"or-i1\\" 3)" "(step-f c \\"and-i\\" 1 3)" "a" "(def aa (infer '[a b] '(and a b)))" "aa" "(step-f aa \\"and-i\\" 1 2)" "(step-f aa \\"or-i1\\" 1)" "(def bb (infer '(and a b) 'b))" "bb" "(step-f bb \\"test\\" 1)" "(def cc (infer '(and a b) 'c))" "(step-f cc \\"test\\" 1)" "(sort '(a (and a b)))" "(use 'clojure.math.combinatorics)" "(permutations '(a b c))" "(permutations '(a (and a b)))" "(for [x (permutations '(a b))]\\n  (eval (list `run* [q] (conj x (make-rule \\"and-i\\")))))" "(for [x (permutations '(a b))]\\r\\n     (eval (list `run* ['q] (conj x (make-rule \\"and-i\\")))))" "(permutations '(a b))" "(for [x (permutations '(a b))]\\r\\n    x)" "(for [x (permutations '(a b))]\\n  (apply-rule \\"and-i\\" true x))" "(for [x (permutations '(a b))]\\r\\n  (apply apply-rule (concat [\\"and-i\\" true] x)))" "(first (for [x (permutations '(a b))]\\r\\n     (apply apply-rule (concat [\\"and-i\\" true] x))))" "(for [x (permutations '((or a b)\\n                         (infer a X)\\n                         (infer b X)))]\\r\\n     (apply apply-rule (concat [\\"or-e\\" true] x)))" "(apply-rule1 \\"and-i\\" true 'a 'b)" "(apply-rule1 \\"or-e\\" true '(or a b) '(infer a X) '(infer b X))" "(apply-rule1 \\"and-i\\" true 'a 'b)" "(apply-rule1 \\"test\\" true '(and a b))" "(apply-rule1 \\"or-e\\" true '(or a b) '(infer a X) '(infer b X))" "(apply-rule1 \\"and-i\\" true 'a 'b)" "(def a (infer '[a b] '(and a b)))" "a" "(step-f a \\"and-i\\" 1 2)" "(def a (infer '[a b] '(and a b)))" "(step-f a \\"and-i\\" 1 2)" "(def b '[{\:id 1 \:body (and a b) \:rule \:premise}\\n         {\:id 2 \:body \:todo \:rule nil}\\n         {\:id 3 \:body a \:rule nil}])" "(step-f b \\"test\\" 1)" "(log/apply-rule1 \\"test\\" true '(and a b))" "(def c '[{\:id 1 \:body a \:rule \:premise}\\n         {\:id 2 \:body b \:rule \:premise}\\n         {\:id 3 \:body \:todo \:rule nil}\\n         {\:id 4 \:body (not a) \:rule nil}\\n         {\:id 5 \:body (not b) \:rule nil}])" "(log/apply-rule1 \\"multi\\" true 'a 'b)" "(log/apply-rule1 \\"or-e\\" '(infer a x) '(or a g) '(infer g x))" "(log/apply-rule1 \\"or-e\\" true '(infer a x) '(or a g) '(infer g x))" "(log/apply-rule1 \\"multi\\" true 'x 'y)" "(merge {\:1 a} {\:a b})" "(merge {\:a 1} {\:b 2})" "(map-indexed \#(hash-map %1 %2) '[a b c])" "(merge (map-indexed \#(hash-map %1 %2) '[a b c]))" "(apply merge (map-indexed \#(hash-map %1 %2) '[a b c]))" "(def rr '([(not a) b] [(not b) a]))" "rr" "(apply merge (map-indexed \#(hash-map (keyword %1) %2) rr))" "(map-indexed \#(hash-map (keyword %1) %2) rr)" "(map \#(hash-map (keyword %1) %2) (iterate inc 1) rr)" "(keyword 1)" "(keyword (str 1))" "(map-indexed \#(hash-map  %1 %2) rr)" "(apply merge (map-indexed \#(hash-map (keyword %1) %2) rr))" "(apply merge (map-indexed \#(hash-map %1 %2) rr))" "(apply merge (map-indexed \#(hash-map %1 %2) '((and a b) (and ba))))" "a" "(def a (infer '[a b] '(and a b)))" "a" "(step-f a \\"and-i\\" 1 2)" "(def b (infer '(and a b) a))" "b" "a" "(def b (infer '(and a b) 'a))" "b" "(step-f b \\"and-e1\\" 1)" "(step-f b \\"and-e2\\" 1)" "(def c '[{\:id 1 \:body (and a b) \:rule \:premise}\\n         {\:id 1 \:body (and a b) \:rule \:premise}\\n         {\:id 1 \:body (and a b) \:rule \:premise}" "(def c '[{\:id 1 \:body (and a b) \:rule \:premise}\\r\\n         {\:id 2 \:body \:todo \:rule nil}\\r\\n         {\:id 3 \:body a \:rule nil}\\n         {\:id 4 \:body b \:rule nil}])" "c" "(step-f c \\"test\\" 1)" "(def c '[{\:id 1 \:body (and a b) \:rule \:premise}\\r\\n            {\:id 2 \:body \:todo \:rule nil}\\r\\n            {\:id 3 \:body a \:rule nil}])" "(step-f c \\"test\\" 1)" "(def d '[{\:id 1 \:body a \:rule \:premise}\\n         {\:id 2 \:body b \:rule \:premise}\\n         {\:id 3 \:body \:todo \:rule nil}\\n         {\:id 4 \:body (not a) \:rule nil}])" "(step-f d \\"multi\\" 1 2)" "c" "(def e '[{\:id 1, \:body (and a b), \:rule \:premise} \\n         {\:id 2, \:body \:todo, \:rule nil} \\n         {\:id 3, \:body e, \:rule nil}])" "(step-f e \\"test\\" 1 2)" "(step-f e \\"test\\" 1)" "(get {1 \:a 2 \:b} 3)" "(get \:a 1)" "(choose-option a 1 1)" "a" "(def aa (step-f a \\"and-i\\" 1 2))" "aa" "(choose-option aa 3 1)" "(choose-option aa 3 2)" "(log/apply-rule1 \\"or-e\\" false 'X)" "(log/apply-rule1 \\"multi\\" false '(not a) '(or a b))" "(log/apply-rule1 \\"test\\" false 'a 'b)" "(drop-while \#(not\= 1 %) [2 3 4 1 2 3])" "(map \#(item-to-rule-arg %) '({\:body bla} {\:body blub}))" "(item-to-rule-arg {\:body bla})" "(item-to-rule-arg '{\:body bla})" "(list (item-to-rule-arg '{\:body bla}))" "(map \:a [{\:a 1} {\:a 2}])" "(def a (infer '[a b] '(and a b)))" "(step-b a \\"and-i\\" 4)" "a" "(log/apply-rule1 \\"and-i\\" false '(and a b))" "(step-b a \\"and-i\\" 4)" "(create-item '(infer a b))" "(create-item '(and a b))" "a" "(step-b a \\"and-i\\" 4)" "(step-b a \\"or-e\\" 4)" "(step-b a \\"and-i\\" 4)" "(step-b a \\"or-e\\" 4)" "(step-b a \\"and-i\\" 4)" "(step-b a \\"or-e\\" 4)" "(step-b a \\"and-i\\" 4)" "(step-b a \\"or-e\\" 4)" "(step-b a \\"and-i\\" 4)" "(step-b a \\"or-e\\" 4)" "(def bb (infer '[a] '(impl a b)))" "bb" "(step-b bb \\"impl-i\\" 3)" "(def a (infer '[a] '(impl a b)))" "a" "(step-b a \\"impl-e\\" 1)" "(step-f a \\"or-i2\\" 1)" "(step-b a \\"impl-i\\" 1)" "(step-b a \\"impl-i\\" 3)" "(step-b a \\"impl-e\\" 1)" "(step-b a \\"impl-e\\" 3)" "(step-b a \\"impl-i\\" 3)" "a" "(step-b a \\"not-i\\" 3)" "(step-f (step-b a \\"not-i\\" 3) \\"not-e\\" 1 2)" "(step-b b \\"raa\\" 3)" "(step-f (step-b b \\"raa\\" 3) \\"not-e\\" 1 2)" "d" "(step-b d \\"raa\\" 2)" "e" "(step-b e \\"impl-i\\" 3)" "d" "e" "f" "h" "l" "(use 'deduction-playground.auto-logic)" "(apply-rule1 \\"not-e\\" false 'contradiction)" "(def tt '[[{\:id 1 \:body (not a) \:rule \:assumption}\\n           {\:id 2 \:body \:todo \:rule nil}\\n           {\:id 3 \:body contradiction \:rule nil}]\\n          {\:id 4 \:body a \:rule \\"bla (1 3)\\"}])" "tt" "(step-b tt \\"not-e\\" 3)" "e" "a" "(def a (infer '[a] '(impl a b)))" "(step-b a \\"impl-i\\" 3)" "(def b (infer '[c] '(and a b)))" "(step-b b \\"and-i\\" 3)" "b" "(log/apply-rule1 \\"and-i\\" false '(and a b))" "(step-b b \\"and-i\\" 3)" "(create-item 'a)" "(seq? '(1 2 3))" "(seq? [1 2 3])" "(step-b b \\"and-i\\" 3)" "(def c (infer '[a] 'contradiction))" "c" "(step-b c \\"not-e\\" 3)"]
eclipse.preferences.version=1
