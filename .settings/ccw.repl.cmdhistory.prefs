cmdhistory=["(macroexpand '(anym bla [a b] (+ a b)))" "(flatten [1 2 3])" "`(~'bla ~@(1 2 3))" "(make rule)" "(def a (make rule))" "a" "(def a (eval (make rule)))" "(eval (make rule))" "(make rule)" "(eval (make rule))" "(def a (eval (make rule)))" "(run* [q] (a '(and x y) q))" "(list \\"(1 2 3)\\")" "(make rule)" "(seq \\"`(and ~a ~b)\\")" "(eval (quote 1))" "(quote 1)" "(quote and)" "and" "(eval (quote and))" "(eval '(quote and))" "(quote `())" "(\= '(and a b) ('and a b))" "(\= '(and a b) ('and 'a 'b))" "`(and ~a ~b)" "(quote `(and ~a ~b))" "(quote (and ~a ~b))" "'(and '~a '~b)" "'(quote (and ~a ~b))" "(def a (fn [and a] (fresh [b] (\=\= and `(and ~a ~b)))))" "(run* [q] (a '(and x y) q))" "(run* [q] (and-e-l '(and x y) q))" "(run 1 [q] (and-e-l '(and x y) q))" "(run* [q] (and-e-l '(and x y) q))" "(run 1 [q] (and-e-l '(and x y) q))" "(run* [q] (ande1o '(a & b) q))" "(run* [q] (ande1o q '(a & b)))" "(run* [q] (and-e-l '(and x y) q))" "(def a (fn [and a] (fresh [b] (\=\= and `(~'and ~a ~b)))))" "(run* [q] (a '(and x y) q))" "(t)" "(def f1 12)" "'(and `~f1)" "`(and ~f1)" "`(~'and ~f1)" "(quote `(~'and ~f1))" "(eval (quote `(~'and ~f1)))" "(t)" "(run* [q] ((eval (t)) '(and x y) q))" "(eval (t))" "(quote `(~a))" "(t)" "(eval (t))" "(def a (eval (t)))" "(run* [q] (a '(and x y) q))" "(run* [q] (a q '(and x y)))" "(t)" "(def a (eval (t)))" "(run* [q] (a '(and x y) q))" "(run* [q] (a q '(and x y)))" "a" "(def a (eval (t)))" "(run* [q] (a q '(and x y)))" "(t)" "(def a (eval (t)))" "(run* [q] (a '(and x y) q))" "(t)" "(def a (eval (t)))" "(run* [q] (a '(and x y) q))" "(def a (eval (t)))" "(run* [q] (a '(and x y) q))" "(t)" "(run* [q]\\n      ((fn [and a] (fresh [b]\\n                          (\=\= and `(~'and ~a ~b)))) '(and x y) q))" "(run* [q] ((t) '(and y x) q))" "(t)" "(def a '(fn [q] (+ 1 q)))" "((a) 4)" "(a 4)" "((eval a) 4)" "(run* [q] ((eval (t)) '(and x y) q))" "(t)" "(run* [q] (t '(and y x) q))" "(run* [q] ((t) '(and x y) q))" "(let [x 19]\\n  `~x)" "(run* [q] ((t) '(and x y) q))" "((h) 12)" "((g) 10)" "(g)" "((h) 10)" "(run* [q] ((t) '(and x y) q))" "(run* [q] ((t) '(and) q))" "(run* [q] ((t) 'and q))" "(run* [q] ((t) '(and) q))" "'(and a)" "'(and)" "(run* [q] ((t) '(and) q))" "(run* [q] ((t) '(and x y) q))" "(run* [q] ((t) '(and a b) q))" "(let [a 12]\\n  '(and `~x))" "(let [x 12]\\n  '(and ~x))" "(let [x 12]\\n  '(and ~`(~x)))" "(let [x 12]\\n  '(and ~`~x))" "(unquote 12)" "(let [x 'b]\\n  '(and ~`~x))" "(run* [q] ((t) '(and x y) q))" "(let [x 'a]\\n  (fn [x] `(~'and ~x)))" "((let [x 'a]\\r\\n  (fn [x] `(~'and ~x))) \\"we\\")" "(run* [q] ((t) '(and x y) q))" "(run* [q] ((t) q '(and x y)))" "(run* [q] ((t) '(and a b) q))" "((let [x 'a]\\n   (fn [x] (+ 10 a))) 12)" "(run* [q] ((t) '(and x y) q))" "(run* [q] ((t) '(and a b) q))" "(let [a '[a]]\\n  (fn a (* 1 a)))" "(run* [q] ((t) '(and a b) q))" "(run* [q] ((eval (g)) '(and a b) q))" "(run* [q] ((eval (g)) '(and a) q))" "(run* [q] ((eval (g)) 'true q))" "(run* [q] ((eval (g)) '(and a) q))" "(g)" "(run* [q] ((eval (m)) '(and) q))" "(run* [q] ((eval (m)) '(and a) q))" "(run* [q] ((eval (m)) '(and a b) q))" "(run* [q] ((eval (m)) '(and x c) q))" "(run* [q] ((eval (m)) '(and hj hj) q))" "(conj [1] [1 2])" "(concat [1] [1 2])" "(concat 12 [1 2 ])" "(contains? [4 5 6] 6)" "(contains? (seq [4 5 6]) 6)" "(seq [4 5 6])" "(use 'clojure.set)" "(intersection (set [1 2]) (set [3 2]))" "(vec \#{1 2})" "(flatten [1 2 3])" "(run* [q] ((eval (make rule)) '(and a b) q))" "rule" "(make rule)" "(first (\:operator rule))" "(doall (concat (\:operator rule) (\:result rule)))" "(make rule)" "(vec (doall (concat (\:operator rule) (\:result rule))))" "(same (\:arguments rule) (\:result rule))" "(make rule)" "(same (\:arguments rule) (\:result rule))" "(make rule)" "(vec (doall (concat (\:operator rule) (\:result rule))))" "(into [] (concat (\:operator rule) (\:result rule)))" "(make rule)" "(run* [q] ((eval (make rule)) '(and a b) q))" "(run* [q] ((eval (make rule)) '(and x h) q))" "(run* [q] ((eval (make rule)) q '(and a b)))" "(let [a [1 2 3]]\\n  `(~'hallo ~@a))" "`(~'and `(~'and))" "`(~'and `(~'and 12 13))" "(run* [q] (and-i 'x 'b q))" "(run* [q] (and-i q 'x 'b))" "(run* [q] (and-e-l q 'x))" "(run* [q] ((eval (make rule)) '(and f g) q))" "(run* [q] (and-i 'a 'b q))" "(run* [q] (and-i 'x 'h q))" "(run* [q] (or-i-l 'a q))" "(run* [q] (or-i-r 'x q))" "(with-meta [ \\"asd\\" (with-meta \\"fgh\\" {\:test 2})] {\:test 1})" "(with-meta 1 \\"asd\\")" "(wff? '(forall [x] (and (P x y) (exist [y] (Q y)))) \\n      {\:P [\:pred 2]\\n       \:Q [\:pred 1]})" "(use [\:clojure.strin \:as s])" "(use '[clojure.string \:as s])" "(str '(forall [x] (P x y)))" "(quote (forall (with-meta 'a {\:test 1})))" "(def a (with-meta '(bla) {\:t 1}))" "a" "(meta a)" "(meta (unquote 'a))" "(meta (eval 'a))" "(def f '(forall [y] (P y x)))" "f" "(run* [q] (and-e-l '(and (forall [x] (P x)) (Q c)) q))" "(wff? '(forall [x] (and (P x) (P2 x c))) s)" "(wff? '(forall [x] (and (P x) (P2 x c c))) s)" "(run* [q] (and-e-l '(and x y) q))" "(run* [q] (and-e-l q 'x))" "(run* [q] (and-i 'x 'y q))" "(run* [q] (and-i q 'y '(and x y)))" "(subform nil)" "(wff? '(and (and) (or)) s)" "(and)" "(or)" "(run* [q]\\n      (fresh [a b]\\n             (\=\= '(or x f) `(~'or ~a ~b))\\n             (\=\= q 1)))" "(run* [q]\\n      (fresh [a b]\\n             (\=\= '(or x g) `(~'or ~a ~b))\\n             (\=\= q 2)))" "(run* [q]\\r\\n         (fresh [a b]\\r\\n                (\=\= '(nor x g) `(~'or ~a ~b))\\r\\n                (\=\= q 2)))" "(run* [q] (or-e '(or a b) '(infer a the) '(infer b the) q))" "(run* [q] (impl-i '(infer h g) q))" "(run* [q] (impl-e 'a '(impl a g) q))" "(run* [q] (not-i '(infer g contradiction) q))" "(run* [q] (not-e 'a '(not a) q))" "(run* [q] (raa '(infer (not phi) contradiction) q))" "(run* [q] (raa '(infer (not phi) contradictio) q))" "(run* [q] (raa '(infer (not phi) contradiction) q))" "(run* [q] (efq 'contradiction q))" "(run* [q] (efq 'hjasd q))" "(run* [q] (equal-e '(\= f g) '(substitution \\n                               (forall [x] (P x))\\n                               g\\n                               x) q))" "(run* [q] (equal-e '(\= f g)\\n                   '(substitution\\n                      (forall [x] (P x))\\n                      f\\n                      x)\\n                   q))" "(run* [q] (forall-i '(infer (actual i) (substitution\\n                                         (P x)\\n                                         (actual i)\\n                                         x)) q))" "(run* [q] (forall-i '(infer (actual i) (substitution\\r\\n                                            (P x)\\r\\n                                            (actual i)\\r\\n                                            x)) q))" "(run* [q] (forall-e '(forall [y] (P y)) q))" "(run* [q] (exists-i '(substitution (P x) t x) q))" "(run* [q] (exists-e '(exists [z] (P z))\\n                    '(infer \\n                       [t\\n                       (substitution\\n                         (P z)\\n                         t\\n                         z)]\\n                       X) q))" "(first '[a b])" "(create-argument '(and a b))" "(create-args '[(or a b)\\r\\n               (infer a X)\\r\\n               (infer b X)])" "(con [1 2 3] 1)" "(conj [1 2 3] 3)" "(conj [1 2 3] 5)" "(create-args '[(or a b)\\r\\n                  (infer a X)\\r\\n                  (infer b X)])" "(rest [1 2 3])" "(t '[(or a b)\\r\\n                     (infer a X)\\r\\n                     (infer b X)])" "(create-args [(or a b)\\r\\n               (infer a X)\\r\\n               (infer b X)])" " (create-args '[(or a b)\\r\\n                  (infer a X)\\r\\n                  (infer b X)])" "(t '[(or a b)\\r\\n                     (infer a X)\\r\\n                     (infer b X)])" "(t '[(or a b)\\r\\n                        (infer a X)\\r\\n                        (infer b X)])" "(g '[or and])" "(g '[or and with])" "(g '[and or infer])" "(create-args '[(or a b)\\r\\n               (infer a X)\\r\\n               (infer b X)])" "(frequencies '[(or a b)\\r\\n               (infer a X)\\r\\n               (infer b X)])" "(frequencies (map \#(create-arg %) '[(or a b)\\r\\n               (infer a X)\\r\\n               (infer b X)]))" "(create-body '[(or a b)\\r\\n               (infer a X)\\r\\n               (infer b X)])" "(create-body '[(or a b)\\r\\n                  (infer a X)\\r\\n                  (infer b X)])" "`(~'bla `(~'bla))" "keywords" "(m)" "(run* [q] ((eval (m)) '(and a g) q))" "(create-g '(or a b))" "(create-g '(or a contradiction))" "`(~'or ~a ~b)" "``(~'or ~a ~b)" "(m)" "``(~'or ~~a ~~b)" "(create-g '(or a))" "(defn h [q]\\n  (fresh []\\n         (\=\= q 12)))" "(run* [q] (h q))" "`(~'and (for [x (range 1 4)] x))" "`(~'and ~(for [x (range 1 4)] x))" "(create-g '[a b] '[(a bla) (b blub)])" "(c 'a '(or a b))" "(concat '(or) '(a) '(b))" "(m)" "(c 'a '(or a))" "`(a ~'b)" "(symbol \\"~'and\\")" "(c 'a '(or a))" "(c 'a '(or and))" "(m)" "(b 'or a b)" "(b '(or a b))" "(m)" "`(seq (concat (list (quote a)) (list (quote b))))" "`(seq (concat (list (quote (quote a))) (list (quote (quote b)))))" "`(seq (concat (list 'a)))" "`(seq (concat (list ~a)))" "`(seq (concat (list (quote \\"a\\"))))" "(quote \\"a\\")" "`(seq (concat (list (quote ~'a))))" "`(list ~'a)" "(b '(or a b))" "(m)" "(conj '((a) (b)) 'concat)" "(let [m (map \#(list 'list %) '(a b))]\\n  m)" "(let [m (map \#(list 'list %) '(a b))]\\r\\n     (conj m 'concat))" "(defn a\\n  [given]\\n  (let [m (map \#(list 'list %) (rest given))]\\n    (conj m 'concat)))" "(a '(or a b))" "(defn b\\n [given]\\n (let [m (a given)]\\n   `(~(first given) ~m)))" "(b '(or a b))" "m" "(m)" "(def c\\n  [given]\\n  (let [m (map \#(list 'list %) (rest given))\\n        m1 (concat m (list 'list (list 'quote (first given))))]\\n    m1))" "(defn c\\r\\n     [given]\\r\\n     (let [m (map \#(list 'list %) (rest given))\\r\\n           m1 (concat m (list 'list (list 'quote (first given))))]\\r\\n       m1))" "(c '(or a b))" "(defn c\\r\\n     [given]\\r\\n     (let [m (map \#(list 'list %) (rest given))\\r\\n           op (list 'quote (first given))\\n           op1 (list 'list op)]\\r\\n       op1))" "(c '(or a b))" "(defn c\\r\\n     [given]\\r\\n     (let [m (map \#(list 'list %) (rest given))\\r\\n           op (list 'quote (first given))\\r\\n           op1 (list 'list op)\\n           res (concat op1 m)]\\r\\n       res))" "(c '(or a b))" "(defn c\\r\\n     [given]\\r\\n     (let [m (map \#(list 'list %) (rest given))\\r\\n           op (list 'quote (first given))\\r\\n           op1 (list 'list op)\\r\\n           res (concat op1 m)]\\r\\n       op1))" "(c '(or a b))" "(defn c\\r\\n     [given]\\r\\n     (let [m (map \#(list 'list %) (rest given))\\r\\n           op (list 'quote (first given))\\r\\n           op1 (list 'list op)\\r\\n           res (concat (list op1) m)]\\r\\n       res))" "(c '(or a b))" "(defn c\\r\\n     [given]\\r\\n     (let [m (map \#(list 'list %) (rest given))\\r\\n           op (list 'quote (first given))\\r\\n           op1 (list 'list op)\\r\\n           res (concat (list op1) m)\\n           res1 (concat res 'concat)\\n           res2 (concat res1 'seq)]\\r\\n       res2))" "(c '(or a b))" "(defn c\\r\\n     [given]\\r\\n     (let [m (map \#(list 'list %) (rest given))\\r\\n           op (list 'quote (first given))\\r\\n           op1 (list 'list op)\\r\\n           res (concat (list op1) m)\\r\\n           res1 (concat res (list 'concat))\\r\\n           res2 (concat res1 (list 'seq))]\\r\\n       res2))" "(c '(or a b))" "(defn c\\r\\n     [given]\\r\\n     (let [m (map \#(list 'list %) (rest given))\\r\\n           op (list 'quote (first given))\\r\\n           op1 (list 'list op)\\r\\n           res (conj op1 m)]\\r\\n       res))" "(c '(or a b))" "(defn c\\r\\n     [given]\\r\\n     (let [m (map \#(list 'list %) (rest given))\\r\\n           op (list 'quote (first given))\\r\\n           op1 (list 'list op)\\r\\n           res (concat (list op1) m)\\r\\n           res1 (concat res (list 'concat))\\r\\n           res2 (concat res1 (list 'seq))]\\r\\n       res2))" "(c '(or a b))" "(conj '((a) (b)) 'concat)" "(defn c\\r\\n     [given]\\r\\n     (let [m (map \#(list 'list %) (rest given))\\r\\n           op (list 'quote (first given))\\r\\n           op1 (list 'list op)\\r\\n           res (concat (list op1) m)\\r\\n           res1 (conj res 'concat)]\\r\\n       res1))" "(c '(or a b))" "(defn c\\r\\n     [given]\\r\\n     (let [m (map \#(list 'list %) (rest given))\\r\\n           op (list 'quote (first given))\\r\\n           op1 (list 'list op)\\r\\n           res (concat (list op1) m)\\r\\n           res1 (conj res 'concat)\\r\\n           res2 (conj res1 'seq)]\\r\\n       res2))" "(c '(or a b))" "(defn c\\r\\n     [given]\\r\\n     (let [m (map \#(list 'list %) (rest given))\\r\\n           op (list 'quote (first given))\\r\\n           op1 (list 'list op)\\r\\n           res (concat (list op1) m)\\r\\n           res1 (conj res 'concat)\\r\\n           res2 (conj (list res1) 'seq)]\\r\\n       res2))" "(c '(or a b))" "(defn c\\r\\n     [given]\\r\\n     (let [m (map \#(list 'list %) (rest given))\\r\\n           op (list 'quote (first given))\\r\\n           op1 (list 'list op)\\r\\n           res (concat (list op1) m)\\r\\n           res1 (conj res 'concat)\\r\\n           res2 (conj (list res1) 'seq)]\\r\\n       res2))" "(defn b\\n  [arg]\\n  `(\=\= ~arg ~(c '(or a b))))" "(b 'a)" "(run* [q] (b q))" "(m)" "`(~(c '(or a b)))" "`(seq 'a 'b)" "(defn c\\r\\n        [given]\\r\\n        (let [m (map \#(list 'list %) (rest given))\\r\\n              op (list 'quote (first given))\\r\\n              op1 (list 'list op)\\r\\n              res (concat (list op1) m)\\r\\n              res1 (conj res `concat)\\r\\n              res2 (conj (list res1) `seq)]\\r\\n          res2))" "(c '(or a b))" "(defn c\\r\\n        [given]\\r\\n        (let [m (map \#(list 'list %) (rest given))\\r\\n              op (list `quote (first given))\\r\\n              op1 (list `list op)\\r\\n              res (concat (list op1) m)\\r\\n              res1 (conj res `concat)\\r\\n              res2 (conj (list res1) `seq)]\\r\\n          res2))" "(c '(or a b))" "(defn c\\r\\n        [given]\\r\\n        (let [m (map \#(list `list %) (rest given))\\r\\n              op (list `quote (first given))\\r\\n              op1 (list `list op)\\r\\n              res (concat (list op1) m)\\r\\n              res1 (conj res `concat)\\r\\n              res2 (conj (list res1) `seq)]\\r\\n          res2))" "(c '(or a b))" "(m)" "(b 'a)" "(run* [q] (b q))" "(defn c\\r\\n        [given]\\r\\n        (let [m (map \#(list `list %) (rest given))\\r\\n              op (list `quote (first given))\\r\\n              op1 (list `list op)\\r\\n              res (concat (list op1) m)\\r\\n              res1 (conj res `concat)\\r\\n              res2 (conj (list res1) `seq)]\\r\\n          res2))" "(defn b\\n  [q]\\n  `(\=\= ~q ~(c '(or a b))))" "(run* [q] (b q))" "(run* [q] ((eval (b q))))" "(defn b\\n  []\\n  `(fn [~'q]\\n     (\=\= ~'q ~(c '(or a b)))))" "(run* [q] ((eval (b)) q))" "(defn b\\n  []\\n  `(fn [~'q]\\n     (fresh [~'a ~'b]\\n            (\=\= ~'q ~(c '(or a b))))))" "(run* [q] ((eval (b)) q))" "(defn c\\r\\n        [given]\\r\\n        (let [m (map \#(list `list %) (rest given))\\r\\n              op (list `quote (first given))\\r\\n              op1 (list `list op)\\r\\n              res (concat (list op1) m)\\r\\n              res1 (conj res `concat)\\r\\n              res2 (conj (list res1) `seq)]\\r\\n          res2))" "(defn b\\n  [arg form]\\n  `(\=\= ~arg ~(c form)))" "(b 'or1 '(or a b))" "(f '[(and a b)])" "(f '[(and a b)] '[a])" "(q '[a])" "(q '[(and a b)])" "(c '(and a b))" "(defn bla^" "`(\=\= ~'q ~(c '(and a b)))" "(c 'a)" "(create-term 'a)" "`(\=\= ~'a ~(create-term 'a))" "`(\=\= ~'q ~(create-term '(and a b)))" "`(\=\= ~'q (create-term 'a))" "`(\=\= ~'q ~(create-term 'a))" "(create-result '[a])" "(f '[(and a b)] '[a])" "(create-body 'and1 '(and a b))" "(f '[(and a b)] '[a])" "(f '[(and a b)])" "(f '(and a b))" "(f '[(and a b)])" "(f '[(or a b)\\r\\n               (infer a X)\\r\\n               (infer b X)])" "(f '[(and a b)] '[a])" "(list (create-result '[a]))" "(f '[(and a b)] '[a])" "(conj [1 2 3] [ 3 45])" "(concat [1 3 4] [4 56])" "(create-fresh-args '[(or a b)\\r\\n               (infer a X)\\r\\n               (infer b X)] '[X])" "(create-fresh-args '[(or a b)\\r\\n                  (infer a X)\\r\\n                  (infer b X)] '[X])" "(concat [] 'a)" "(concat [] ['a])" "(create-fresh-args '[(or a b)\\r\\n                     (infer a X)\\r\\n                     (infer b X)] '[X])" "(f '[(or a b)\\r\\n               (infer a X)\\r\\n               (infer b X)] '[X])" "(f '[(or a b)\\r\\n                  (infer a X)\\r\\n                  (infer b X)] '[X])" "(run* [q] ((f '[(or a b)\\r\\n                  (infer a X)\\r\\n                  (infer b X)] '[X]) '(or x v) '(infer x G) '(infer v G) q))" "((f '[(or a b)\\r\\n                  (infer a X)\\r\\n                  (infer b X)] '[X]) )" "(f '[(or a b)\\r\\n                  (infer a X)\\r\\n                  (infer b X)] '[X])" "(f '[a b] '[(and a b)])" "(f '[(and a b)] '[a])" "(run* [q] ((eval (f '[(and a b)] '[a])) '(and g b) q))" "(run* [q] ((eval (f '[(or a b)\\r\\n                     (infer a X)\\r\\n                     (infer b X)] '[X])) '(or x v) '(infer x G) '(infer v G) q))" "(f '[a b] '[(and a b)])" "(create-args '[a b])" "(map \#(create-body %1 %2) '[a1 b2] '[a b])" "(empty? (map \#(create-body %1 %2) '[a1 b2] '[a b]))" "(empty? (flatten (map \#(create-body %1 %2) '[a1 b2] '[a b])))" "(list (create-result '[(and a b)]))" "(concat (map \#(create-body %1 %2) '[a1 b2] '[a b]) (list (create-result '[(and a b)])))" "(remove \#(empty? %) (map \#(create-body %1 %2) '[a1 b2] '[a b]))" "(concat () (list (create-result '[(and a b)])))" "(f '[a b] '[(and a b)])" "(def given '[a b])" "(def conc '[(and a b)])" "(create-args given)" "(remove \#(empty? %) (map \#(create-body %1 %2) args given))" "(remove \#(empty? %) (map \#(create-body %1 %2) '[a1 b2] given))" "(list (create-result conc))" "(concat (remove \#(empty? %) (map \#(create-body %1 %2) '[a1 b2] given)) (list (create-result conc)))" "(def ggg (concat (remove \#(empty? %) (map \#(create-body %1 %2) '[a1 b2] given)) (list (create-result conc))))" "(conj ggg (create-fresh-args given conc) `fresh)" "(create-fresh-args given conc)" "(reduce \#(concat %1 (if (symbol? %2)\\r\\n                         [%2]\\r\\n                         (rest %2))) [] given)" "(reduce \#(concat %1 (if (symbol %2)\\r\\n                                    [%2]\\r\\n                                    (rest %2))) [] conc)" "(reduce \#(concat %1 (if (symbol? %2)\\r\\n                                    [%2]\\r\\n                                    (rest %2))) [] conc)" "(f '[a b] '[(and a b)])" "(run* [q] ((eval (f '[a b] '[(and a b)])) 'a 'h q))" "(f '[a b] '[(and a b)])" "(run* [q] ((eval (clojure.core/fn [a b q] (clojure.core.logic/fresh [] (clojure.core.logic/\=\= q (clojure.core/seq (clojure.core/concat (clojure.core/list (quote and)) (clojure.core/list a) (clojure.core/list b))))))\\n                  ) 'h 'b q))" "(symbol 'a)" "(symbol 'and 4)" "(list `quote (first given))" "(list (list `quote (first [1 2 3])))" "(list `list (list `quote (first [1 2 3 ])))" "(list `list `quote (first (1 2 3)))" "(list `list `quote (first [1 2 3]))" "(gen-term '[(or a b)])" "(map \#(list `list %) (rest '(or a b)))" "(list `list (list `quote (first '(or a b))))" "(concat '(clojure.core/list (quote or)) '((clojure.core/list (quote (or a b)))))" "(gen-term '(or a d))" "(gen-term '(and or a))" "(gen-term '(or a b))" "(concat '(or) '(a) '(b))" "(gen-term '(or a b))" "(gen-logic-function '[a b] '[(and a b)])" "(gen-logic-function '[(and a b)] '[a])" " (gen-logic-function '[(and a b)] '[a])" "(gen-logic-function '[(and a b)] '[a])" "(run* [q] ((eval (gen-logic-function '[(and a b)] '[a])) '(and z t) q))" "(run* [q] ((eval (gen-logic-function '[a (impl a b)] '[b])) 'g '(impl g h) q))" "(run* [q] ((eval (gen-logic-function '[(infer a contradiction)] '[(not a)])) '(infer g contradiction) q))" "(run* [q] ((eval (gen-logic-function '[a (not a)] '[contradiction])) 'g '(not g) q))" "(run* [q] ((eval (gen-logic-function '[a b] '[(and a b)])) 'g '(not g) q))" "(run* [q] ((eval (gen-logic-function '[a b] '[(and a b)])) 'a 'b q))" "(gen-logic-function '[a b] '[(and a b)])" "(run* [q] ((eval (gen-logic-function '[(and a b)])) '(and a b) q))" "(run* [q] ((eval (gen-logic-function '[(and a b)] '[a])) '(and a b) q))" "(run* [q] ((eval (gen-logic-function '[(and a b)] '[b])) '(and a b) q))" "(run* [q] ((eval (gen-logic-function '[a] '[(or a b)])) 'a q))" "(gen-logic-function '[a] '[(or a b)])" "(apply vector \#{a b})" "(apply vector \#{1 2})" "(gen-logic-function '[a] '[(or a b)])" "(run* [q] ((eval (gen-logic-function '[a] '[(or a b)])) 'a q))" "(run* [q] ((eval (gen-logic-function '[a b] '[(and a b)])) 'f 'g q))" "(run* [q] ((eval (make-rule {\:name \\"and-i\\"\\r\\n \:given      '[a b]\\r\\n \:conclusion '[(and a b)]})) 'g 'h q))" "(run* [q] ((eval (make-rule {\:name \\"and-e1\\"\\r\\n \:given      '[(and a b)]\\r\\n \:conclusion '[a]})) '(and e r) q))" "(run* [q] ((eval (make-rule {\:name \\"and-e2\\"\\r\\n \:given      '[(and a b)]\\r\\n \:conclusion '[b]})) '(and e r) q))" "(run* [q] ((eval (make-rule {\:name \\"or-i1\\"\\r\\n \:given      '[a]\\r\\n \:conclusion '[(or a b)]})) 'k q))" "(run* [q] ((eval (make-rule {\:name \\"or-i2\\"\\r\\n \:given      '[a]\\r\\n \:conclusion '[(or b a)]})) 'k q))" "(run* [q] ((eval (make-rule {\:name \\"or-e\\"\\r\\n \:given      '[(or a b)\\r\\n               (infer a X)\\r\\n               (infer b X)]\\r\\n \:conclusion '[X]})) '(or a g) '(infer a b) '(infer g b) q))" "(run* [q] ((eval (make-rule {\:name \\"impl-i\\"\\r\\n \:given      '[(infer a b)]\\r\\n \:conclusion '[(impl a b)]})) '(infer g h) q))" "(run* [q] ((eval (make-rule {\:name \\"impl-e\\"\\r\\n \:given      '[a (impl a b)]\\r\\n \:conclusion '[b]})) 'a '(impl a g) q))" "(run* [q] ((eval (make-rule {\:name \\"not-i\\"\\r\\n \:given      '[(infer a contradiction)]\\r\\n \:conclusion '[(not a)]})) '(infer g contradiction) q))" "(run* [q] ((eval (make-rule {\:name \\"not-e\\"\\r\\n \:given      '[a (not a)]\\r\\n \:conclusion '[contradiction]})) 'g '(not g) q))" "(run* [q] ((eval (make-rule {\:name \\"raa\\"\\r\\n \:given      '[(infer (not a) contradiction)]\\r\\n \:conclusion '[a]})) '(infer (not f) contradiction) q))" "(run* [q] ((eval (make-rule {\:name \\"efq\\"\\r\\n \:given      '[contradiction]\\r\\n \:conclusion '[a]})) 'contradiction q))" "(run* [q] ((eval (make-rule {\:name \\"equal-i\\"\\r\\n \:given      '[]\\r\\n \:conclusion '[(\= t t)]}))  q))" "(run* [q] ((eval (make-rule {\:name \\"equal-e\\"\\r\\n \:given      '[(\= a b)\\r\\n               (substitution phi a x)]\\r\\n \:conclusion '[(substitution phi b x)]})) '(\= e f) '(substitution (forall [x] (P x)) e x) q))" "(run* [q] ((eval (make-rule {\:name \\"forall-i\\"\\r\\n \:given      '[(infer (actual x0)\\r\\n                      (substitution phi x0 x))]\\r\\n \:conclusion '[(forall [x] phi)]})) '(infer (actual g) (substitution (forall [x] (P x)) g x)) q))" "(run* [q] ((eval (make-rule {\:name \\"forall-e\\"\\r\\n \:given      '[(forall [x] phi)]\\r\\n \:conclusion '[(substitution phi t x)]})) '(forall [x] (P x)) q))" "(run* [q] ((eval (make-rule {\:name \\"exists-i\\"\\r\\n \:given      '[(substitution phi t x)]\\r\\n \:conclusion '[(exists [x] phi)]})) '(substitution (P x) f x) q))" "(run* [q] ((eval (make-rule {\:name \\"exists-e\\"\\r\\n \:given      '[(exists [x] phi)\\r\\n               (infer [(actual x0)\\r\\n                       (substitution phi x0 x)]\\r\\n                      X)]\\r\\n \:conclusion '[X]})) '(exists [x] (P x)) '(infer [(actual g)\\n                                                  (substitution (P x) g x)]\\n                                                 T) q))" "(gen-result '[contradiction])" "(gen-logic-function '[(infer a contradiction)] '[(not a)])" "(list `list (list `quote arg))" "(def arg a)" "(def arg 'a)" "(list `list (list `quote arg))" "(get-term-arg '(not a))" "(run* [q] ((eval (make-rule {\:name \\"not-e\\"\\r\\n \:given      '[a (not a)]\\r\\n \:conclusion '[contradiction]})) 'a '(not a) q))" "(gen-logic-function '[a (not a)] '[contradiction])" "(run* [q] ((eval (gen-logic-function '[a (not a)] '[contradiction])) 'a '(not a) q))" "(run* [q] ((eval (gen-logic-function '[(and a b)] '[a])) q '(and a b)))" "(defn and-e-l\\r\\n  [and q]\\r\\n  (fresh [b]\\r\\n         (\=\= and `(~'and ~q ~b))))" "(run* [q] (and-e-l q '(and a b)))" "(defn and-i\\r\\n  [a b q]\\r\\n  (\=\= q `(~'and ~a ~b)))" "(run* [q] (and-i 'a q 'b))" "(gen-term '(infer (not a) contradiction))" "(gen-term '(infer a contradiction))" "(run* [q] ((eval (t)) 'g q))" "(run* [q] ((eval (t)) 'a q))" "(run* [q] ((eval (t)) \\"asd\\" q))" "(run* [q] ((eval (t)) 'a q))" "(run* [q] ((eval (t)) \\"sd\\" q))" "(run* [q] (t 'a q))" "(run* [q] (t \\"asd\\" q))" "(run* [q] (t 'f q))" "(run* [q] (t 'a '(infer (not f) contradiction) q))" "(run* [q] (t 'f '(infer (not f) contradiction) q))" "(run* [q] (t 'f '(infer (not d) contradiction) q))" "(run* [q] (t 'g q))" "(eval '(not true))" "(eval `(not true))" "`(get-term-arg \\"asdf\\")" "(eval '(gen-term 'g))" "(eval '(gen-term a))" "(eval '(gen-term '(and a b)))" "(list 1 2 3)" "(reduce \#(into %1 %2) (list `list 12) (1 2 3))" "(reduce \#(into %1 %2) (list `list 12) [1 2 3])" "(into () (1 2 3))" "(get-term-arg '(not a))" "(get-term-arg '(and r g))" "(conj (1 2 3) 23)" "(conj (1 2 3) (23))" "(conj (1 2 3) 'sd)" "(conj '(1 2 3) 12)" "(get-term-arg '(not a))" "(get-term-arg 'contradiction)" "(gen-term '(and a b))" "((clojure.core/list (quote not)) (clojure.core/list a))" "((clojure.core/list (quote not)) (clojure.core/list 'a))" "(clojure.core/list (quote not) (clojure.core/list 'a))" "(gen-term '(and a b))" "(gen-term '(and a (and c b)))" "(clojure.core/seq (clojure.core/concat (clojure.core/list (quote and)) (clojure.core/list 'a) ((clojure.core/list (quote and)) (clojure.core/list 'c) \\n                                                                                                                               (clojure.core/list 'b))))" "(clojure.core/seq (clojure.core/concat (clojure.core/list (quote and)) (clojure.core/list 'a) (clojure.core/list 'b)))" "(gen-term '(and a (and b c)))" "(clojure.core/seq (clojure.core/concat (clojure.core/list (quote and)) (clojure.core/list 'a) ((quote and) (clojure.core/list 'b) (clojure.core/list 'c))))" "((quote and) (clojure.core/list 'b) (clojure.core/list 'c))" "(and ('b) ('c))" "(clojure.core/seq (clojure.core/concat (clojure.core/list (quote and)) (clojure.core/list 'a) \\n                                       (seq (concat (list (quote and)) (clojure.core/list 'b) (clojure.core/list 'c)))))" "(clojure.core/seq (clojure.core/concat (clojure.core/list (quote and)) (clojure.core/list 'a) \\r\\n                                          (concat (list (quote and)) (clojure.core/list 'b) (clojure.core/list 'c))))" "(clojure.core/seq (clojure.core/concat (clojure.core/list (quote and)) (clojure.core/list 'a) \\r\\n                                          (list (list (quote and)) (clojure.core/list 'b) (clojure.core/list 'c))))" "(clojure.core/seq (clojure.core/concat (clojure.core/list (quote and)) (clojure.core/list 'a) \\r\\n                                          (list (concat (list (quote and)) (clojure.core/list 'b) (clojure.core/list 'c)))))" "(gen-term '(and a (and b c)))" "(gen-term '(and a (and a b)))" "(clojure.core/seq (clojure.core/concat (clojure.core/list (quote and)) (clojure.core/list 'a) ((clojure.core/list (clojure.core/concat (quote and))) \\n                                                                                                (clojure.core/list 'a) (clojure.core/list 'b))))" "(gen-term '(and a (and b c)))" "(gen-term '(and a (and a b)))" "(reduce \#(into %1 %2) '() '(1 2 3))" "(reduce \#(into %1 %2) '() '((1) (2)))" "(reduce \#(concat %1 %2) '() '((1) (2)))" "(gen-term '(and a (and b c)))" "(reduce \#(conj %1 %2) '() '((1) (2)))" "(apply get-term-arg '(a b))" "(reduce \#(apply get-term-arg %1) '(a b))" "(into '(list (quote and)) '((1) (2)))" "(concat '(list (quote and)) '((1) (2)))" "(gen-term '(and a (and b c)))" "(clojure.core/seq (clojure.core/concat (clojure.core/list (quote and)) (clojure.core/list 'a) (clojure.core/list (clojure.core/concat (quote and)) \\n                                                                                                                 (clojure.core/list 'b) (clojure.core/list 'c))))" "(gen-term '(and a (and a b)))" "(gen-term '(and a (and b c)))" "(gen-term '(and a (and a b)))" "(clojure.core/seq (clojure.core/concat (clojure.core/list (quote and)) (clojure.core/list 'a) (clojure.core/list (clojure.core/concat clojure.core/list (quote and) \\n                                                                                                                                      (clojure.core/list 'a) (clojure.core/list 'b)))))" "(gen-term '(and a (and b c)))" "(clojure.core/seq (clojure.core/concat (clojure.core/list (quote and)) (clojure.core/list 'a) (clojure.core/list (clojure.core/concat (clojure.core/list (quote and)) \\n                                                                                                                                      (clojure.core/list 'b) (clojure.core/list 'c)))))" "(gen-term '(and (and (not a) b) (or a b)))" "(clojure.core/seq (clojure.core/concat (clojure.core/list (quote and)) \\n                                       (clojure.core/list (clojure.core/concat (clojure.core/list (quote and)) \\n                                                                               (clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) \\n                                                                                                                       (clojure.core/list 'a))) (clojure.core/list 'b))) \\n                                       (clojure.core/list (clojure.core/concat (clojure.core/list (quote or)) (clojure.core/list 'a) (clojure.core/list 'b)))))" "(run* [q] ((eval (gen-logic-function '[(infer a (not b))\\n                                       (and (or a b) c)]\\n                                     '[c])) '(infer e (not f)) '(and (or e f) g) q))" "(gen-body-row 'infer1 '(infer a (not b)))" "(def r {\:name \\"test\\"\\n        \:given '[(infer a (not b))]\\n        \:conclusion '[b]})" "(run* [q] ((eval (make-rule r)) '(infer e (not f)) q))" "'(infer e (not f))" "(def given '[(infer a (not b))])" "(gen-args given)" "(def conclusion '[b])" "(apply vector (set/difference (set (gen-fresh-args given conclusion)) (set args)))" "(apply vector (set/difference (set (gen-fresh-args given conclusion)) (set (gen-args given))))" "(reduce \#(concat %1 (cond \\r\\n                                    (contains? keywords %2) []\\r\\n                                    (symbol? %2) [%2]\\r\\n                                    (list? %2) (rest %2)\\r\\n                                    \:else (throw (Exception. \\"Can't reduce gvars\\")))) [] given)" "(concat [1] [2 3])" "(gen-fresh-arg '(infer a (not b)))" "(gen-fresh-arg '(not b))" "(apply vector (set/difference (set (gen-fresh-args given conclusion)) (set args)))" "(apply vector (set/difference (set (gen-fresh-args given conclusion)) (set (gen-args given))))" "(run* [q] ((eval (make-rule r)) '(infer e (not f)) q))" "rule" "r" "(run* [q] ((eval (make-rule {\:name \\"raa\\"\\r\\n \:given      '[(infer (not a) contradiction)]\\r\\n \:conclusion '[a]})) '(infer (not e) contradiction) q))" "(run* [q] ((eval (make-rule {\:name \\"forall-i\\"\\r\\n \:given      '[(infer (actual x0)\\r\\n                      (substitution phi x0 x))]\\r\\n \:conclusion '[(forall [x] phi)]})) '(infer (actual X)\\n                                            (substitution (P x) X x)) q))" "(gen-term '(infer (actual X) (substitution phi X x)))" "(gen-term '(infer (actual X) (substitution (P x) X x)))" "(clojure.core/seq (clojure.core/concat (clojure.core/list (quote infer)) (clojure.core/list (clojure.core/concat (clojure.core/list (quote actual)) (clojure.core/list 'X))) (clojure.core/list (clojure.core/concat \\n                                                                                                                                                                                                  (clojure.core/list (quote substitution)) \\n                                                                                                                                                                                                  (clojure.core/list (clojure.core/concat (clojure.core/list (quote P)) \\n                                                                                                                                                                                                                                          (clojure.core/list 'x))) (clojure.core/list 'X) \\n                                                                                                                                                                                                  (clojure.core/list 'x)))))" "(def r {\:name \\"forall-i\\"\\r\\n \:given      '[(infer (actual x0)\\r\\n                      (substitution phi x0 x))]\\r\\n \:conclusion '[(forall [x] phi)]})" "r" "(run* [q] ((eval (make-rule r)) '(infer (actual F) (substitution (P x) F x)) q))" "(def given '[(infer (actual x0)\\r\\n                      (substitution phi x0 x))])" "(def conclusion '[(forall [x] phi)])" "(gen-args given)" "(apply vector (set/difference (set (gen-fresh-args given conclusion)) (set (gen-args given))))" "(gen-body (gen-args given) given)" "((clojure.core.logic/\=\= infer1 \\n                        (clojure.core/seq (clojure.core/concat (clojure.core/list (quote infer)) \\n                                                               (clojure.core/list (clojure.core/concat (clojure.core/list (quote actual)) \\n                                                                                                       (clojure.core/list 'x0))) \\n                                                               (clojure.core/list (clojure.core/concat (clojure.core/list (quote substitution)) \\n                                                                                                       (clojure.core/list 'phi) (clojure.core/list 'x0) (clojure.core/list 'x)))))))" "((clojure.core.logic/\=\= 'infer1 \\r\\n                           (clojure.core/seq (clojure.core/concat (clojure.core/list (quote infer)) \\r\\n                                                                  (clojure.core/list (clojure.core/concat (clojure.core/list (quote actual)) \\r\\n                                                                                                          (clojure.core/list 'x0))) \\r\\n                                                                  (clojure.core/list (clojure.core/concat (clojure.core/list (quote substitution)) \\r\\n                                                                                                          (clojure.core/list 'phi) (clojure.core/list 'x0) (clojure.core/list 'x)))))))" "(clojure.core/seq (clojure.core/concat (clojure.core/list (quote infer)) \\r\\n                                                                     (clojure.core/list (clojure.core/concat (clojure.core/list (quote actual)) \\r\\n                                                                                                             (clojure.core/list 'x0))) \\r\\n                                                                     (clojure.core/list (clojure.core/concat (clojure.core/list (quote substitution)) \\r\\n                                                                                                             (clojure.core/list 'phi) (clojure.core/list 'x0) (clojure.core/list 'x)))))" "(gen-result conclusion)" "(get-term-arg '[x])" "(run* [q] ((eval (make-rule r)) '(infer (actual F) (substitution (P x) F x)) q))" "(map \#(get-term-arg %) (rest given))" "given" "(map \#(get-term-arg %) (rest (first given)))" "(map \#(get-term-arg %) (rest (first conclusion)))" "(gen-result conclusion)" "(gen-logic-function given conclusion)" "(concat '(forall) ['x] '(phi))" "(run* [q] ((eval (make-rule r)) '(infer (actual F) (substitution (P x) F x)) q))" "(into [] ((1) (2)))" "(int [] '((1) (2)))" "(into [] '((1) (2)))" "(concat '((1) (2)))" "(reduce \#(concat %1 (first %2)) [] '((1) (2)))" "(first '(1))" "(reduce \#(into %1 (first %2)) [] '((1) (2)))" "(into [] 1)" "(into [] '(1))" "(reduce \#(into %1 %2) [] '((1) (2)))" "(run* [q] ((eval (make-rule r)) '(infer (actual F) (substitution (P x) F x)) q))" "(get-term-arg '[x])" "(run* [q] ((eval (make-rule r)) '(infer (actual F) (substitution (P x) F x)) q))" "(get-term-arg 'x)" "(map \#(get-term-arg %) [x])" "(map \#(get-term-arg %) '[x])" "(reduce \#(into %1 %2) [] (map \#(get-term-arg %) '[x]))" "(reduce \#(conj %1 %2) [] (map \#(get-term-arg %) '[x]))" "(run* [q] ((eval (make-rule r)) '(infer (actual F) (substitution (P x) F x)) q))" "r" "(def r {\:name \\"forall-e\\"\\r\\n \:given      '[(forall [x] phi)]\\r\\n \:conclusion '[(substitution phi t x)]})" "(run* [q] ((eval (make-rule r)) '(forall [x] (P x)) q))" "(def r {\:name \\"exists-i\\"\\r\\n \:given      '[(substitution phi t x)]\\r\\n \:conclusion '[(exists [x] phi)]})" "(run* [q] ((eval (make-rule r)) '(substitution (P x) F x) q))" "(def r {\:name \\"exists-e\\"\\r\\n \:given      '[(exists [x] phi)\\r\\n               (infer [(actual x0)\\r\\n                       (substitution phi x0 x)]\\r\\n                      X)]\\r\\n \:conclusion '[X]})" "(run* [q] ((eval (make-rule r)) '(exists [y] (P y)) '(infer [(actual F)\\n                                                             (substitution (P y) F y)] X) q))" "(get-term-arg '[x y])" "(clojure.core/list [x y])" "(clojure.core/list ['x 'y])" "(def given '[(exists [x] phi)\\r\\n               (infer [(actual x0)\\r\\n                       (substitution phi x0 x)]\\r\\n                      X)])" "(def conclusion '[X])" "(gen-args given)" "(apply vector (set/difference (set (gen-fresh-args given conclusion)) (set (gen-args given))))" "(gen-body (gen-args given) given)" "(gen-result conclusion)" "(get-term-arg '[x (not y)])" "(gen-term '(infer [(actual x)\\n                   (substitution phi x e)] X))" "(clojure.core/seq (clojure.core/concat (clojure.core/list (quote infer)) \\n                                       [(clojure.core/list (clojure.core/concat (clojure.core/list (quote actual)) (clojure.core/list 'x))) \\n                                        (clojure.core/list (clojure.core/concat (clojure.core/list (quote substitution)) (clojure.core/list 'phi) \\n                                                                                (clojure.core/list 'x) (clojure.core/list 'e)))] (clojure.core/list 'X)))" "(gen-term '(infer [(actual x)\\r\\n                      (substitution phi x e)] X))" "(clojure.core/seq (clojure.core/concat (clojure.core/list (quote infer)) \\n                                       (clojure.core/vector \\n                                         [(clojure.core/list (clojure.core/concat (clojure.core/list (quote actual)) (clojure.core/list 'x))) \\n                                          (clojure.core/list (clojure.core/concat (clojure.core/list (quote substitution)) (clojure.core/list 'phi) (clojure.core/list 'x) (clojure.core/list 'e)))]) (clojure.core/list 'X)))" "(vector (map \#(inc %) '(1 2 3)))" "(gen-term '(infer [(actual x)\\r\\n                         (substitution phi x e)] X))" "(clojure.core/seq (clojure.core/concat (clojure.core/list (quote infer)) (clojure.core/into [] [(clojure.core/list (clojure.core/concat (clojure.core/list (quote actual)) \\n                                                                                                                                        (clojure.core/list 'x))) \\n                                                                                                (clojure.core/list (clojure.core/concat (clojure.core/list (quote substitution)) (clojure.core/list 'phi) (clojure.core/list 'x) (clojure.core/list 'e)))]) (clojure.core/list 'X)))" "(gen-term '(infer [(actual x)\\r\\n                            (substitution phi x e)] X))" "(clojure.core/seq (clojure.core/concat (clojure.core/list (quote infer)) (clojure.core/list (clojure.core/into [] [(clojure.core/list (clojure.core/concat (clojure.core/list \\n                                                                                                                                                             (quote actual)) (clojure.core/list 'x))) (clojure.core/list (clojure.core/concat (clojure.core/list (quote substitution)) (clojure.core/list 'phi) (clojure.core/list 'x) (clojure.core/list 'e)))])) (clojure.core/list 'X)))" "(into [] (map \#(inc %) '( 1 2 3)))" "(gen-term '(infer [(actual x)\\r\\n                               (substitution phi x e)] X))" "(clojure.core/seq (clojure.core/concat (clojure.core/list (quote infer)) \\n                                       (clojure.core/list (clojure.core/into [] ((clojure.core/list (clojure.core/concat (clojure.core/list (quote actual)) \\n                                                                                                                         (clojure.core/list 'x))) \\n                                                                                  (clojure.core/list (clojure.core/concat (clojure.core/list (quote substitution)) (clojure.core/list 'phi) (clojure.core/list 'x) (clojure.core/list 'e)))))) (clojure.core/list 'X)))" "(clojure.core/list (clojure.core/into [] ((clojure.core/list (clojure.core/concat (clojure.core/list (quote actual)) \\r\\n                                                                                                                            (clojure.core/list 'x))) \\r\\n                                                                                     (clojure.core/list (clojure.core/concat (clojure.core/list (quote substitution)) (clojure.core/list 'phi) (clojure.core/list 'x) (clojure.core/list 'e))))))" "((clojure.core/list (clojure.core/concat (clojure.core/list (quote actual)) \\r\\n                                                                                                                               (clojure.core/list 'x))) \\r\\n                                                                                        (clojure.core/list (clojure.core/concat (clojure.core/list (quote substitution)) (clojure.core/list 'phi) (clojure.core/list 'x) (clojure.core/list 'e))))" "(get-term-arg '[(not a) (bla e)])" "(clojure.core/list (clojure.core/concat (clojure.core/into [] ((clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) \\n                                                                                                       (clojure.core/list 'a))) \\n                                                                (clojure.core/list (clojure.core/concat (clojure.core/list (quote bla)) (clojure.core/list 'e)))))))" "(into [] '((1) (2)))" "(map \#(get-term-arg %) '[(not a)])" "(map \#(get-term-arg %) '[(not a) (not b)])" "(into [] (map \#(get-term-arg %) '[(not a) (not b)]))" "(vector (map \#(get-term-arg %) '[(not a) (not b)]))" "(gen-term '(infer [(actual x)\\r\\n                                  (substitution phi x e)] X))" "(gen-term '(infer [(actual x)\\r\\n                                     (substitution phi x e)] X))" "(clojure.core/seq (clojure.core/concat (clojure.core/list (quote infer)) (clojure.core/list (clojure.core/into [] \\n                                                                                                               ((clojure.core/list (clojure.core/concat \\n                                                                                                                                     (clojure.core/list (quote actual)) (clojure.core/list 'x))) (clojure.core/list (clojure.core/concat (clojure.core/list (quote substitution)) (clojure.core/list 'phi) (clojure.core/list 'x) (clojure.core/list 'e)))))) (clojure.core/list 'X)))" "(clojure.core/list (clojure.core/into [] \\r\\n                                          ((clojure.core/list (clojure.core/concat (clojure.core/list (quote actual)) (clojure.core/list x))) \\r\\n                                            (clojure.core/list (clojure.core/concat (clojure.core/list (quote substitution)) (clojure.core/list phi) (clojure.core/list x) (clojure.core/list e))))))" "(clojure.core/list (clojure.core/into [] \\r\\n                                          ((clojure.core/list (clojure.core/concat (clojure.core/list (quote actual)) (clojure.core/list 'x))) \\r\\n                                            (clojure.core/list (clojure.core/concat (clojure.core/list (quote substitution)) (clojure.core/list 'phi) (clojure.core/list 'x) (clojure.core/list 'e))))))" "(clojure.core/into [] \\r\\n                                          ((clojure.core/list (clojure.core/concat (clojure.core/list (quote actual)) (clojure.core/list x))) \\r\\n                                            (clojure.core/list (clojure.core/concat (clojure.core/list (quote substitution)) (clojure.core/list phi) (clojure.core/list x) (clojure.core/list e)))))" "(clojure.core/into [] \\r\\n                                          ((clojure.core/list (clojure.core/concat (clojure.core/list (quote actual)) (clojure.core/list x))) \\r\\n                                            (clojure.core/list (clojure.core/concat (clojure.core/list (quote substitution)) (clojure.core/list 'phi) (clojure.core/list 'x) (clojure.core/list 'e)))))" "(clojure.core/into [] \\r\\n                                             ((clojure.core/list (clojure.core/concat (clojure.core/list (quote actual)) (clojure.core/list 'x))) \\r\\n                                               (clojure.core/list (clojure.core/concat (clojure.core/list (quote substitution)) (clojure.core/list 'phi) (clojure.core/list 'x) (clojure.core/list 'e)))))" "(into [] '((1) (2)))" "(into [] '(((1)) ((2))))" "(into [] '(1) '(2))" "(vector '((1) (2)))" "(apply vector '((1) (2)))" "(gen-term '(infer [(actual x)\\r\\n                                        (substitution phi x e)] X))" "(clojure.core/seq (clojure.core/concat (clojure.core/list (quote infer)) \\n                                       (clojure.core/list (clojure.core/apply clojure.core/vector \\n                                                                              ((clojure.core/list (clojure.core/concat (clojure.core/list (quote actual)) \\n                                                                                                                       (clojure.core/list 'x))) (clojure.core/list (clojure.core/concat (clojure.core/list (quote substitution)) (clojure.core/list 'phi) (clojure.core/list 'x) (clojure.core/list 'e)))))) (clojure.core/list 'X)))" "(get-term-arg '[(not a)])" "(clojure.core/list (clojure.core/apply clojure.core/vector ((clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list 'a))))))" "(clojure.core/apply clojure.core/vector ((clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list 'a)))))" "((clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list 'a))))" "(clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list 'a)))" "(get-term-arg '[(not a)])" "(clojure.core/list (clojure.core/apply clojure.core/vector (clojure.core/concat ((clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) \\n                                                                                                                         (clojure.core/list 'a)))))))" "(clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list 'a))" "(get-term-arg '[(not a)])" "(clojure.core/apply clojure.core/vector (clojure.core/concat ((clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list 'a))))))" "(clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list 'a)))" "(get-term-arg '(not a))" "(clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list 'a)))" "(gen-term '(infer (actual x0)\\r\\n                      (substitution phi x0 x)))" "(clojure.core/seq (clojure.core/concat (clojure.core/list (quote infer)) (clojure.core/list (clojure.core/concat (clojure.core/list (quote actual)) (clojure.core/list 'x0))) (clojure.core/list \\n                                                                                                                                                                                (clojure.core/concat (clojure.core/list (quote substitution)) (clojure.core/list 'phi) (clojure.core/list 'x0) (clojure.core/list 'x)))))" "(gen-term '(forall [x] (P x)))" "(clojure.core/seq (clojure.core/concat (clojure.core/list (quote forall)) (clojure.core/apply clojure.core/vector (clojure.core/concat ((clojure.core/list 'x)))) (clojure.core/list (clojure.core/concat (clojure.core/list \\n                                                                                                                                                                                                            (quote P)) (clojure.core/list 'x)))))" "(map \#(inc %) [1 2 3])" "(concat (map \#(inc %) [1 2 3]))" "(get-term-arg '[x y])" "(clojure.core/apply clojure.core/vector ((clojure.core/list 'x) (clojure.core/list 'y)))" "(apply vector '((1) (2)))" "((clojure.core/list 'x) (clojure.core/list 'y))" "(get-term-arg '[x y])" "(clojure.core/apply clojure.core/vector [(clojure.core/list x) (clojure.core/list y)])" "(clojure.core/apply clojure.core/vector [(clojure.core/list 'x) (clojure.core/list 'y)])" "(get-term-arg '[x (not y)])" "(clojure.core/apply clojure.core/vector [(clojure.core/list 'x) (clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list 'y)))])" "(get-term-arg '[x (not y)])" "(clojure.core/apply clojure.core/vector (clojure.core/concat ((clojure.core/list 'x) (clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list 'y))))))" "(def e '[(x) ((not y))])" "e" "(get-term-arg '[x (not x)])" "(get-term-arg '[x (not y)])" "[(clojure.core/list 'x) (clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list 'y)))]" "(reduce \#(conj %1 (first %2)) [] '[(x) ((not y))])" "(get-term-arg '[x (not x)])" "(concat [(clojure.core/list 'x) (clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list 'y)))])" "(apply vector '[(x) ((not x))])" "(apply \#(vector (first %)) '[(x) ((not x))])" "(map \#(first %) '[(x) ((not y))])" "(get-term-arg '[x (not y)])" "(conj (get-term-arg '[x (not y)]) 'concat)" "(vector (concat (clojure.core/list 'x) (clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list 'y)))))" "(apply vector (concat (clojure.core/list 'x) (clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list 'y)))))" "(get-term-arg '[x (not y)])" "(clojure.core/apply clojure.core/vector (clojure.core/conj ((clojure.core/list 'x) (clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) \\n                                                                                                                           (clojure.core/list 'y)))) clojure.core/concat))" "(clojure.core/conj ((clojure.core/list 'x) (clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) \\r\\n                                                                                                                              (clojure.core/list 'y)))) clojure.core/concat)" "(get-term-arg '[x (not y)])" "(clojure.core/apply clojure.core/vector (clojure.core/concat (clojure.core/list 'x) \\n                                                             (clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list 'y)))))" "r" "(run* [q] ((eval (make-rule r)) '(exists [x] (P x)) '(infer [(actual F)\\n                                                             (substitution (P x) F x)] X) q))" "(def r {\:name \\"forall-i\\"\\r\\n \:given      '[(infer (actual x0)\\r\\n                      (substitution phi x0 x))]\\r\\n \:conclusion '[(forall [x] phi)]})" "(run* [q] ((eval (make-rule r)) '(infer (actual F)\\n                                        (substitution (P x) F x)) q))" "(gen-term '(infer [(actual x0)\\r\\n                       (substitution phi x0 x)]\\r\\n                      X))" "(clojure.core/seq (clojure.core/concat (clojure.core/list (quote infer)) (clojure.core/apply clojure.core/vector (clojure.core/concat (clojure.core/list (clojure.core/concat (clojure.core/list (quote actual)) (clojure.core/list 'x0))) (clojure.core/list (clojure.core/concat (clojure.core/list (quote substitution)) (clojure.core/list 'phi) (clojure.core/list 'x0) \\n                                                                                                                                                                                                                                                                                   (clojure.core/list 'x))))) (clojure.core/list 'X)))" "(get-term-arg '(infer [(actual x) (subs phi a x)] b))" "(clojure.core/list (clojure.core/concat (clojure.core/list (quote infer)) (clojure.core/apply clojure.core/vector (clojure.core/concat (clojure.core/list (clojure.core/concat (clojure.core/list (quote actual)) (clojure.core/list 'x))) (clojure.core/list (clojure.core/concat (clojure.core/list (quote subs)) (clojure.core/list 'phi) (clojure.core/list 'a) \\n                                                                                                                                                                                                                                                                                   (clojure.core/list 'x))))) (clojure.core/list 'b)))" "(get-term-arg '[(actual x) (not b)])" "(clojure.core/apply clojure.core/vector (clojure.core/concat (clojure.core/list (clojure.core/concat (clojure.core/list (quote actual)) (clojure.core/list 'x))) (clojure.core/list (clojure.core/concat \\n                                                                                                                                                                                      (clojure.core/list (quote not)) (clojure.core/list 'b)))))" "(rest (infer [(a x) (s p x y)] b))" "(rest '(infer [(a x) (s p x y)] b))" "(get-term-arg '[(a x) (s p x y)])" "(clojure.core/apply clojure.core/vector (clojure.core/concat (clojure.core/list (clojure.core/concat (clojure.core/list (quote a)) (clojure.core/list 'x))) \\n                                                             (clojure.core/list (clojure.core/concat (clojure.core/list (quote s)) (clojure.core/list 'p) (clojure.core/list 'x) (clojure.core/list 'y)))))" "(map \#(get-term-arg %) (rest '(infer [(actual x0)\\r\\n                       (substitution phi x0 x)]\\r\\n                      X)))" "(gen-term '(infer [(actual x0)\\r\\n                       (substitution phi x0 x)]\\r\\n                      X))" "((clojure.core/list (quote infer)) (clojure.core/apply clojure.core/vector (clojure.core/concat (clojure.core/list (clojure.core/concat (clojure.core/list (quote actual)) (clojure.core/list 'x0))) (clojure.core/list (clojure.core/concat (clojure.core/list (quote substitution)) \\n                                                                                                                                                                                                                                             (clojure.core/list 'phi) (clojure.core/list 'x0) (clojure.core/list 'x))))) (clojure.core/list 'X))" "(concat (clojure.core/list (quote infer)) (clojure.core/apply clojure.core/vector (clojure.core/concat (clojure.core/list (clojure.core/concat (clojure.core/list (quote actual)) (clojure.core/list 'x0))) (clojure.core/list (clojure.core/concat (clojure.core/list (quote substitution)) \\r\\n                                                                                                                                                                                                                                                (clojure.core/list 'phi) (clojure.core/list 'x0) (clojure.core/list 'x))))) (clojure.core/list 'X))" "(gen-term '(infer [(actual x0)\\r\\n                       (substitution phi x0 x)]\\r\\n                      X))" "(clojure.core/seq (clojure.core/concat (clojure.core/list (quote infer)) (clojure.core/list (clojure.core/apply clojure.core/vector (clojure.core/concat (clojure.core/list (clojure.core/concat (clojure.core/list (quote actual)) (clojure.core/list 'x0))) (clojure.core/list (clojure.core/concat (clojure.core/list (quote substitution)) \\n                                                                                                                                                                                                                                                                                                      (clojure.core/list 'phi) (clojure.core/list 'x0) (clojure.core/list 'x)))))) (clojure.core/list 'X)))" "r" "(run* [q] ((eval (make-rule r)) '(infer (actual F) (substitution (P x) F x)) q))" "(def r {\:name \\"exists-e\\"\\r\\n \:given      '[(exists [x] phi)\\r\\n               (infer [(actual x0)\\r\\n                       (substitution phi x0 x)]\\r\\n                      X)]\\r\\n \:conclusion '[X]})" "(run* [q] ((eval (make-rule r)) '(exists [z] (P z)) '(infer \\n                                                       [(actual F)\\n                                                        (substitution (P z) F z)]\\n                                                       X) q))" "(def r {\:name \\"forall-i\\"\\r\\n \:given      '[(infer (actual x0)\\r\\n                      (substitution phi x0 x))]\\r\\n \:conclusion '[(forall [x] phi)]})" "(run* [q] ((eval (make-rule r)) '(infer (actual J) (substitution (P x) J x)) q))" "(def r {\:name \\"forall-e\\"\\r\\n \:given      '[(forall [x] phi)]\\r\\n \:conclusion '[(substitution phi t x)]})" "(run* [q] ((eval (make-rule r)) '(forall [y] (P y)) q))" "(run* [q] ((eval (make-rule r)) '(forall [y x] (P y x)) q))" "(def r {\:name \\"exists-i\\"\\r\\n \:given      '[(substitution phi t x)]\\r\\n \:conclusion '[(exists [x] phi)]})" "(run* [q] ((eval (make-rule r)) '(substitution (P x) t x) q))" "(gen-fresh-args '[(exists [x] phi)\\r\\n               (infer [(actual x0)\\r\\n                       (substitution phi x0 x)]\\r\\n                      X)] '[X])" "(def r {\:name \\"exists-e\\"\\r\\n \:given      '[(exists [x] phi)\\r\\n               (infer [(actual x0)\\r\\n                       (substitution phi x0 x)]\\r\\n                      X)]\\r\\n \:conclusion '[X]})" "(run* [q] ((eval (make-rule r)) '(exists [z] (P z))\\n                                '(infer [(actual F)\\n                                         (substitution (P z) F z)]\\n                                        X) q))" "(def r {\:name \\"exists-i\\"\\r\\n \:given      '[(substitution phi t x)]\\r\\n \:conclusion '[(exists [x] phi)]})" "(run* [q] ((eval (make-rule r)) '(substitution (P z) g z) q))" "(def r {\:name \\"and-i\\"\\r\\n \:given      '[a b]\\r\\n \:conclusion '[(and a b)]})" "(run* [q] ((eval (make-rule r)) 'g 'p q))" "(def r {\:name \\"and-e1\\"\\r\\n \:given      '[(and a b)]\\r\\n \:conclusion '[a]})" "(run* [q] ((eval (make-rule r)) '(and t z) q))" "(def r {\:name \\"and-e2\\"\\r\\n \:given      '[(and a b)]\\r\\n \:conclusion '[b]})" "(run* [q] ((eval (make-rule r)) '(and t z) q))" "(def r {\:name \\"or-i1\\"\\r\\n \:given      '[a]\\r\\n \:conclusion '[(or a b)]})" "(run* [q] ((eval (make-rule r)) 'l q))" "(def r {\:name \\"or-i2\\"\\r\\n \:given      '[a]\\r\\n \:conclusion '[(or b a)]})" "(run* [q] ((eval (make-rule r)) 'l q))" "(def r {\:name \\"or-e\\"\\r\\n \:given      '[(or a b)\\r\\n               (infer a X)\\r\\n               (infer b X)]\\r\\n \:conclusion '[X]})" "(run* [q] ((eval (make-rule r)) '(or x y)\\n                                '(infer x D)\\n                                '(inder y D) q))" "(run* [q] ((eval (make-rule r)) '(or x y)\\r\\n                                   '(infer x D)\\r\\n                                   '(infer y D) q))" "(def r {\:name \\"impl-i\\"\\r\\n \:given      '[(infer a b)]\\r\\n \:conclusion '[(impl a b)]})" "(run* [q] ((eval (make-rule r)) '(infer f g) q))" "(def r {\:name \\"impl-e\\"\\r\\n \:given      '[a (impl a b)]\\r\\n \:conclusion '[b]})" "(run* [q] ((eval (make-rule r)) 'g '(impl g h) q))" "(def r {\:name \\"not-i\\"\\r\\n \:given      '[(infer a contradiction)]\\r\\n \:conclusion '[(not a)]})" "(run* [q] ((eval (make-rule r)) '(infer g contradiction) q))" "(def r {\:name \\"not-e\\"\\r\\n \:given      '[a (not a)]\\r\\n \:conclusion '[contradiction]})" "(run* [q] ((eval (make-rule r)) 'g '(not g) q))" "(def r {\:name \\"raa\\"\\r\\n \:given      '[(infer (not a) contradiction)]\\r\\n \:conclusion '[a]})" "(run* [q] ((eval (make-rule r)) '(infer (not t) contradiction) q))" "(def r {\:name \\"efq\\"\\r\\n \:given      '[contradiction]\\r\\n \:conclusion '[a]})" "(run* [q] ((eval (make-rule r)) 'contradiction q))" "(def r {\:name \\"equal-i\\"\\r\\n \:given      '[]\\r\\n \:conclusion '[(\= t t)]})" "(run* [q] ((eval (make-rule r)) q))" "(def r {\:name \\"equal-e\\"\\r\\n \:given      '[(\= a b)\\r\\n               (substitution phi a x)]\\r\\n \:conclusion '[(substitution phi b x)]})" "(run* [q] ((eval (make-rule r)) '(\= e f) '(substitution (P x) f e x) q))" "(run* [q] ((eval (make-rule r)) '(\= e f) '(substitution (P x) e x) q))" "(def r {\:name \\"forall-i\\"\\r\\n \:given      '[(infer (actual x0)\\r\\n                      (substitution phi x0 x))]\\r\\n \:conclusion '[(forall [x] phi)]})" "(run* [q] ((eval (make-rule r)) '(infer (actual g) (substitution (P x) g x)) q))" "(def r {\:name \\"forall-e\\"\\r\\n \:given      '[(forall [x] phi)]\\r\\n \:conclusion '[(substitution phi t x)]})" "(run* [q] ((eval (make-rule r)) '(forall [z] (P z)) q))" "(def r {\:name \\"exists-i\\"\\r\\n \:given      '[(substitution phi t x)]\\r\\n \:conclusion '[(exists [x] phi)]})" "(run* [q] ((eval (make-rule r)) '(substitution (P x) f x) q))" "(def r {\:name \\"exists-e\\"\\r\\n \:given      '[(exists [x] phi)\\r\\n               (infer [(actual x0)\\r\\n                       (substitution phi x0 x)]\\r\\n                      X)]\\r\\n \:conclusion '[X]})" "(run* [q] ((eval (make-rule r)) '(exists [y] (P y))\\n                                '(infer [(actual D)\\n                                         (substitution (P y) D y)]\\n                                        Y) q))" "(def r {\:name \\"and-i\\"\\r\\n \:given      '[a b]\\r\\n \:conclusion '[(and a b)]})" "(run* [q] ((eval (make-rule r)) nil nil q))" "(run* [q] ((eval (make-rule r)) q 'b '(and a b)))" "(run* [q] ((eval (make-rule r)) 'a q '(and a b)))" "(def r {\:name \\"and-e1\\"\\r\\n \:given      '[(and a b)]\\r\\n \:conclusion '[a]})" "(run* [q] ((eval (make-rule r)) q '(and a b)))" "(run* [q] ((eval (make-rule r)) q 'a))" "(def r {\:name \\"or-i1\\"\\r\\n \:given      '[a]\\r\\n \:conclusion '[(or a b)]})" "(run* [q] ((eval (make-rule r)) q '(or a b)))" "(def r {\:name \\"or-i2\\"\\r\\n \:given      '[a]\\r\\n \:conclusion '[(or b a)]})" "(run* [q] ((eval (make-rule r)) q '(or a b)))" "(def r {\:name \\"or-e\\"\\r\\n \:given      '[(or a b)\\r\\n               (infer a X)\\r\\n               (infer b X)]\\r\\n \:conclusion '[X]})" "(run* [q] ((eval (make-rule r)) q q q 'X))" "(run* [q] ((eval (make-rule r)) q '(infer a X) '(infer b X) 'X))" "(defn n\\n  [c]\\n  `(\=\= ~'q ~(cond\\n              (contains? keywords c) (list `quote c)\\n              (symbol? c) c\\n              (list? c) (gen-term c))))" "(map \#(n %) '[a b])" "(map \#(n %) '[a contradiction (and a (not b))])" "(clojure.core/seq (clojure.core/concat (clojure.core/list (quote and)) \\n                                       (clojure.core/list 'a) (clojure.core/list (clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list 'b)))))" "(gen-result '[a b])" "(into [] (map \#(inc %) '(1 2 3)))" "(gen-result '[a b])" "(gen-logic-function '[(and a b)] '[ a b])" "(def r {\:name \\"test\\"\\r\\n \:given '[(and a b)]\\r\\n \:conclusion '[a b]})" "(run* [q] ((eval (make-rule r)) '(and x y) q))" "(run* [q]\\n      (conde \\n        [(\=\= q 1) (\=\= q 2)]))" "(run* [q]\\n      (conde\\n        [(\=\= q 1)]\\n        [(\=\= q 2)]))" "(run* [q]\\n      (fresh [a b]\\n             (\=\= '(and x y) `(~'and ~a b))\\n             (conde\\n               [(\=\= q a)]\\n               [(\=\= q b)])))" "(run* [q]\\r\\n         (fresh [a b]\\r\\n                (\=\= '(and x y) `(~'and ~a ~b))\\r\\n                (conde\\r\\n                  [(\=\= q a)]\\r\\n                  [(\=\= q b)])))" "(apply vector ('(and a b) '(and x y)))" "(apply vector '((and a b) (and x y)))" "(for [x '((1) (2))]\\n  (vector x))" "(conj '([(1)] [(2)]) `conde)" "(gen-result '[a b])" "r" "(run* [q] ((eval (make-rule r)) '(and f g) q))" "(def r {\:name \\"exists-i\\"\\r\\n \:given      '[(substitution phi t x)]\\r\\n \:conclusion '[(exists [x] phi)]})" "(run* [q] ((eval (make-rule r)) '(substitution (P x) t x) q))" "(def r {\:name \\"test\\"\\r\\n \:given '[(and a b)]\\r\\n \:conclusion '[a b]})" "(run* [q] ((eval (make-rule r)) q 'b))" "(run* [q] ((eval (make-rule r)) q 'a))" "(def r {\:name \\"equal-e\\"\\r\\n \:given      '[(\= a b)\\r\\n               (substitution phi a x)]\\r\\n \:conclusion '[(substitution phi b x)]})" "(run* [q] ((eval (make-rule r)) '(substitution (P x) F x) '(\= F D) q))" "(run* [q] ((eval (make-rule r)) '(\= F D) '(substitution (P x) F x) q))" "(make-rule r)" "(def r {\:name \\"and-i\\"\\r\\n \:given      '[a b]\\r\\n \:conclusion '[(and a b)]})" "(run* [q] ((eval (make-rule r)) q q '(and a b)))" "(run* [q u] ((eval (make-rule r)) q u '(and a b)))" "(def r {\:name \\"or-e\\"\\r\\n \:given      '[(or a b)\\r\\n               (infer a X)\\r\\n               (infer b X)]\\r\\n \:conclusion '[X]})" "(run* [q u z] ((eval (make-rule r)) q u z 'X))" "(def r {\:name \\"test\\"\\r\\n \:given '[(and a b)]\\r\\n \:conclusion '[a b]})" "(run* [q] ((eval (make-rule r)) '(and a b) q))" "(conj [1 2 3] 'q)" "(apply \#(conj [1 2 3] %) '(q u z))" "(apply conj [1 2 3] '(q u z))" "(take 3 (cycle 'q))" "(take 3 (cycle ['q]))" "(def conclusion '[a b])" "(map \#(symbol (str %1 %2)) (take (count conclusion) (cycle ['q])) (take (count conclusion (iterate inc 1))))" "(map \#(symbol (str %1 %2)) (take (count conclusion) (cycle ['q])) (take (count conclusion) (iterate inc 1)))" "(def e1 (map \#(symbol (str %1 %2)) (take (count conclusion) (cycle ['q])) (take (count conclusion) (iterate inc 1))))" "e1" "(gen-result1 conclusion e1)" "(def given '[(and a b)])" "(def e2 (gen-args given))" "e2" "(apply conj e2 e1)" "(concat '(a b) '(c d))" "(gen-logic-function given conclusion)" "(run* [q u] ((eval (make-rule r)) '(and e f) q u))" "(run* [q u] ((eval (make-rule r)) q 'a 'b))" "(run* [q] ((eval (make-rule r)) q 'a 'b))" "(def r {\:name \\"and-i\\"\\r\\n \:given      '[a b]\\r\\n \:conclusion '[(and a b)]})" "(run* [q] ((eval (make-rule r)) 'a 'r q))" "(run* [q u] ((eval (make-rule r)) q u '(and e f)))" "(slurp \\"rules.clj\\")" "(slurp \\"src/deduction_playground/rules.clj\\")" "(require [clojure.java.io \:as io])" "(read-rules)" "(read-test)" "(if (read-test) true false)" "(read-test)" "(read-rules)" "(read-rules1)" "(\:given (\:equal-i (read-rules1)))" "(eval (\:given (\:equal-i (read-rules1))))" "(\:given (\:exists-i (read-rules1)))" "(apply rule \\"asd\\" '[a b c])" "(apply-rule \\"asd\\" '[1 2 3])" "(concat [1 2 3] '(4 5 6))" "(apply-rule \\"test\\" '[(and x y)])" "(apply-rule \\"test\\" '(and x y))" "(def e1 ((keyword \\"test\\") rules))" "e1" "(map \#(symbol (str %1 %2)) \\r\\n                        (take (count (\:conclusion e1)) (cycle ['q]))\\r\\n                        (take (count (\:conclusion e1)) (iterate inc 1)))" "(apply-rule \\"test\\" '(and x y))" "(def r ((keyword \\"test\\") rules))" "r" "logic-args (map \#(symbol (str %1 %2)) \\r\\n                        (take (count (\:given r)) (cycle ['q]))\\r\\n                        (take (count (\:given r)) (iterate inc 1)))" "\\n(map \#(symbol (str %1 %2)) \\r\\n                        (take (count (\:given r)) (cycle ['q]))\\r\\n                        (take (count (\:given r)) (iterate inc 1)))" "(concat '((and a b)) '(q1))" "(apply str '((and a b) q1))" "(apply-rule \\"test\\" '(and x y))" "(apply-rule \\"and-i\\" 'a 'b)" "(apply-rule \\"test\\" '(and c x))" "(apply-rule \\"test\\" '(and c d))" "(apply-rule \\"test\\" '(and e d))" "(apply-rule \\"test\\" '(and e f))" "(eval (apply-rule \\"test\\" '(and e g)))" "(apply-rule \\"and-e1\\" '(and a b))" "(apply-rule \\"and-e1\\" '(and e f))" "(let [fn (eval `(fn [a] (+ a 10)))]\\n  (fn 15))" "(let [fn (eval `(fn [~'a] (+ ~'a 10)))]\\r\\n     (fn 15))" "(apply-rule \\"test\\" '(and e g))" "(run* [q1] ((eval (make-rule {\:name \\"test\\"\\r\\n \:given '[(and a b)]\\r\\n \:conclusion '[a b]})) '(and e g) q1))" "(def r {\:name \\"test\\"\\r\\n \:given '[(and a b)]\\r\\n \:conclusion '[a b]})" "(run* [q] ((eval (make-rule r)) '(and e gh) q))" "(def r {\:name \\"and-i\\"\\r\\n \:given      '[a b]\\r\\n \:conclusion '[(and a b)]})" "(run* [q] ((eval (make-rule r)) 'a 'e q))" "(apply-rule \\"and-i\\" 'a 'e)" "(apply-rule \\"and-i\\" 'a 'e )" "(apply-rule \\"and-i\\" 'g 'e)" "r" "(into [] (map \#(symbol (str %1 %2)) \\r\\n                                 (take (count (\:conclusion r)) (cycle ['q]))\\r\\n                                 (take (count (\:conclusion r)) (iterate inc 1))))" "(apply-rule \\"and-i\\" 'g 'e)" "(run* [q u] ((eval (make-rule {\:name \\"test\\"\\r\\n \:given '[(and a b)]\\r\\n \:conclusion '[a b]})) '(and e fg) q u))" "(run* [q] (apply (eval (make-rule {\:name \\"and-e1\\"\\r\\n \:given      '[(and a b)]\\r\\n \:conclusion '[a]})) '((and e f) q)))" "(run* [q] (apply (make-rule {\:name \\"and-e1\\"\\r\\n \:given      '[(and a b)]\\r\\n \:conclusion '[a]}) '((and e f) q)))" "(let [fn (make-rule {\:name \\"and-e1\\"\\r\\n \:given      '[(and a b)]\\r\\n \:conclusion '[a]})]\\n  (run* [q] (apply fn '((and e f) q))))" "(apply-rule \\"and-e1\\" '(and e f))" "(run* [q] (apply (eval (make-rule {\:name \\"and-e1\\"\\r\\n \:given      '[(and a b)]\\r\\n \:conclusion '[a]})) '[(and e f) q]))" "(run* [q] (apply (eval (make-rule {\:name \\"and-e1\\"\\r\\n    \:given      '[(and a b)]\\r\\n    \:conclusion '[a]})) ['(and e f) 'q]))" "(run* [q] (apply (eval (make-rule {\:name \\"and-e1\\"\\r\\n    \:given      '[(and a b)]\\r\\n    \:conclusion '[a]})) '(and e f) q))" "`(run* [q] (apply (eval (make-rule {\:name \\"and-e1\\"\\r\\n    \:given      '[(and a b)]\\r\\n    \:conclusion '[a]})) '[(and e f) q]))" "(eval `(run* [q] (apply (eval (make-rule {\:name \\"and-e1\\"\\r\\n    \:given      '[(and a b)]\\r\\n    \:conclusion '[a]})) '[(and e f) q])))" "(eval `(run* [~'q] (apply (eval (make-rule {\:name \\"and-e1\\"\\r\\n    \:given      '[(and a b)]\\r\\n    \:conclusion '[a]})) '[(and e f) q])))" "(eval `(run* [~'q] ~(apply (eval (make-rule {\:name \\"and-e1\\"\\r\\n    \:given      '[(and a b)]\\r\\n    \:conclusion '[a]})) '[(and e f) q])))" "(apply-rule \\"test\\" '(and e f))" "r" "(def r {\:given '[(and a b)] \:conclusion '[a]})" "r" "(let [largs [q1 q2]\\n      args '((and a b) q1 q2)]\\n  (eval `(run* ~largs ~(conj ~args (eval (make-rule ~r))))))" "(let [largs '[q1 q2]\\r\\n         args '((and a b) q1 q2)]\\r\\n     (eval `(run* ~largs ~(conj ~args (eval (make-rule ~r))))))" "(let [largs '[q1 q2]\\r\\n         args '((and a b) q1 q2)]\\r\\n     (eval `(run* ~largs ~(conj ~args `(eval (make-rule ~~r))))))" "`(run* [~'q] ((eval (make-rule ~r)) '(and e b) ~'q))" "`(run* [~q] ((eval (make-rule ~r)) `(~'and ~'e ~'f) ~'q))" "`(run* [~'q] ((eval (make-rule ~r)) `(~'and ~'e ~'f) ~'q))" "(eval `(run* [~q] ((eval (make-rule ~r)) `(~'and ~'e ~'f) ~'q)))" "(eval `(run* [~'q] ((eval (make-rule ~r)) `(~'and ~'e ~'f) ~'q)))" "(make-rule r)" "(conj '((and e b) q) (make-rule r))" "(conj (conj '((and e g) q) (make-rule r)) `eval)" "(run* [q]  (conj (conj '((and e g) q) (make-rule r)) `eval))" "(def g (conj '((and e d) q) (make-rule r)))" "g" "(eval g)" "(run* [q] (eval g))" "g" "(def g (make-rule r))" "g" "(eval g)" "(def h (eval g))" "(run* [q] (h '(and e f) q))" "(let [t (eval g)]\\n  (run* [q] (t '(and e f) q)))" "(let [t (eval g)\\n      q '[q]\\n      u '(and e d)]\\n  (eval `(run* ~q (t u ~'q))))" "(let [t (eval g)\\r\\n         q '[q]\\r\\n         u '(and e d)]\\r\\n     (eval `(run* ~q (~'t u ~'q))))" "(let [t (eval g)\\r\\n         q '[q]\\r\\n         u '(and e d)]\\r\\n     (eval `(run* ~q (~t u ~'q))))" "(let [t (eval g)\\r\\n         q '[q]\\r\\n         u '(and e d)]\\r\\n     (eval `(run* ~q (t ~u ~'q))))" "(let [t (eval g)\\r\\n         q '[q]\\r\\n         u '(and e d)]\\r\\n     (eval `(run* ~q (~t ~u ~'q))))" "(let [t (eval g)\\r\\n            q '[q]\\r\\n            u '(and e d)]\\r\\n        (eval `(run* ~q (~t ~`u ~'q))))" "(let [t (eval g)\\n      q '[q]\\n      u '(and e d)]\\n  (eval (list `run* q (list t u 'q))))" "(let [t (eval g)\\r\\n         q '[q]\\r\\n         u '(and e d)]\\r\\n     (list `run* q (list t u 'q)))" "(let [fn \#(+ % 10)]\\n  (eval (list fn 12)))" "(let [t (eval g)\\r\\n         q '[q]\\r\\n         u '(and e d)]\\r\\n     (eval (list `run* q (list t (list u) 'q))))" "(let [t (eval g)\\r\\n         q '[q]\\r\\n         u '(and e d)]\\r\\n     (eval (list `run* q (list t (quote u) 'q))))" "(let [t (eval g)\\r\\n            q '[q]\\r\\n            u '(and e d)]\\r\\n        (list `run* q (list t (quote u) 'q)))" "(let [t (eval g)\\r\\n            q '[q]\\r\\n            u '(and e d)]\\r\\n        (eval (list `run* q (list t (quote (list u)) 'q))))" "(let [t (eval g)\\r\\n            q '[q]\\r\\n            u '(and e d)]\\r\\n        (eval (list `run* q (list t '(and e d) 'q))))" "(let [t (eval g)\\r\\n            q '[q]\\r\\n            u '(and e d)]\\r\\n        (eval (list `run* q (list t ''(and e d) 'q))))" "(quote (list '(a e d)))" "(let [t (eval g)\\r\\n               q '[q]\\r\\n               u '(and e d)]\\r\\n           (eval (list `run* q (list t (quote (list u)) 'q))))" "(let [t (eval g)\\r\\n               q '[q]\\r\\n               u '(and e d)]\\r\\n           (eval (list `run* q (list t ''~u 'q))))" "(let [t (eval g)\\r\\n               q '[q]\\r\\n               u '(and e d)]\\r\\n           (eval (list `run* q (list t '~u 'q))))" "(let [t (eval g)\\r\\n               q '[q]\\r\\n               u '(and e d)]\\r\\n           (eval (list `run* q (list t `(quote ~u) 'q))))" " (let [t (eval g)\\r\\n                  q '[q]\\r\\n                  u '(and e d)\\n                  p '((and e d) q)]\\r\\n              (eval (list `run* q (conj p t))))" "(let [t (eval g)\\r\\n                     q '[q]\\r\\n                     u '(and e d)\\r\\n                     p '((and e d) q)]\\r\\n                 (eval (list `run* q (conj `(quote ~p) t))))" "(concat '(t) '((and e f) q))" "(let [t (eval g)\\r\\n                     q '[q]\\r\\n                     u '(and e d)\\r\\n                     p ((quote (and e d)) (quote q))]\\r\\n                 (eval (list `run* q (concat t p))))" "(let [t (eval g)\\r\\n                        q '[q]\\r\\n                        u '(and e d)\\r\\n                        p ((quote (and e d)) (quote q))]\\r\\n                    (list `run* q (concat t p)))" "(let [t (eval g)\\r\\n                        q '[q]\\r\\n                        u '(and e d)\\r\\n                        p ((quote (and e d)) (quote q))]\\r\\n                    (eval (list `run* q (list concat t p))))" "(let [t (eval g)\\r\\n                        q '[q]\\r\\n                        u '(and e d)\\r\\n                        p ((quote (and e d)) (quote q))]\\r\\n                    (eval (list `run* q (list t p))))" "(let [t (eval g)\\r\\n      q '[q]\\r\\n      u '(and e d)\\r\\n      p ((quote (and e d)) (quote q))]\\r\\n  (list `run* q (conj p t)))" "(let [t (eval g)\\r\\n         q '[q]\\r\\n         u '(and e d)\\r\\n         p ((quote (and e d)) (quote q))]\\r\\n     (list `run* q (conj `(quote ~p) t)))" "(let [t (eval g)\\r\\n         q '[q]\\r\\n         u '(and e d)\\r\\n         p ((and e d) q)]\\r\\n     (list `run* q (conj `(quote ~p) t)))" "(let [t (eval g)\\r\\n            q '[q]\\r\\n            u '(and e d)\\r\\n            p '((and e d) q)]\\r\\n        (list `run* q (conj `(quote ~p) t)))" "(let [t (eval g)\\r\\n               q '[q]\\r\\n               u '(and e d)\\r\\n               p '((and e d) q)]\\r\\n           (list `run* q (concat (list t) `(quote ~p) )))" "(let [t (eval g)\\r\\n      q '[q]\\r\\n      u '(and e d)\\r\\n      p '((and e d) q)\\n      p2 (map \#(`(quote ~%1)) p)]\\r\\n  (list `run* q (concat (list t) p2)))" "(let [t (eval g)\\r\\n         q '[q]\\r\\n         u '(and e d)\\r\\n         p '((and e d) q)\\r\\n         p2 (map \#(`(quote ~%1)) p)]\\r\\n     p2)" "(let [t (eval g)\\r\\n         q '[q]\\r\\n         u '(and e d)\\r\\n         p '((and e d) q)\\r\\n         p2 (map \#(list `(quote ~%1)) p)]\\r\\n     p2)" "(let [t (eval g)\\r\\n         q '[q]\\r\\n         u '(and e d)\\r\\n         p '((and e d) q)\\r\\n         p2 (map \#(quote %1) p)]\\r\\n     p2)" "(let [t (eval g)\\r\\n         q '[q]\\r\\n         u '(and e d)\\r\\n         p '((and e d) q)\\r\\n         p2 (map \#(quote ~%) p)]\\r\\n     p2)" "(let [t (eval g)\\r\\n         q '[q]\\r\\n         u '(and e d)\\r\\n         p '((and e d) q)\\r\\n         p2 (map \#(conj (list %) `quote) p)]\\r\\n     p2)" "(let [t (eval g)\\r\\n            q '[q]\\r\\n            u '(and e d)\\r\\n            p '((and e d) q)\\r\\n            p2 (map \#(conj (list %) `quote) p)]\\r\\n        (list `run* q (conj p2 t)))" "(let [t (eval g)\\r\\n               q '[q]\\r\\n               u '(and e d)\\r\\n               p '((and e d) q)\\r\\n               p2 (map \#(conj (list %) `quote) p)]\\r\\n           (eval (list `run* q (conj p2 t))))" "g" "(run* [q] ((eval g) (quote (and e f)) (quote q)))" "(let [t (eval g)\\r\\n               q '[q]\\r\\n               u '(and e d)\\r\\n               p '((and e d))\\r\\n               p2 (map \#(conj (list %) `quote) p)\\n               p3 (concat p2 (first q))]\\r\\n           (list `run* q (conj p3 t)))" "(run* [q] ((eval g) (quote (and e f)) q))" "(let [t (eval g)\\r\\n                  q '[q]\\r\\n                  u '(and e d)\\r\\n                  p '((and e d))\\r\\n                  p2 (map \#(conj (list %) `quote) p)]\\r\\n              p2)" "(let [t (eval g)\\r\\n                  q '[q]\\r\\n                  u '(and e d)\\r\\n                  p '((and e d))\\r\\n                  p2 (map \#(conj (list %) `quote) p)\\r\\n                  p3 (concat p2 '(q))]\\r\\n              (list `run* q (conj p3 t)))" "(let [t (eval g)\\r\\n                     q '[q]\\r\\n                     u '(and e d)\\r\\n                     p '((and e d))\\r\\n                     p2 (map \#(conj (list %) `quote) p)\\r\\n                     p3 (concat p2 '(q))]\\r\\n                 (eval (list `run* q (conj p3 t))))" " (let [t (eval g)\\r\\n       q '[q]\\r\\n       u '(and e d)\\r\\n       p '((and e d))\\r\\n       p2 (map \#(conj (list %) `quote) p)\\r\\n       p3 (concat p2 q)]\\r\\n   (eval (list `run* q (conj p3 t))))" "(def g (make-rule (\:and-e1 rules)))" "g" "(t \\"and-e1\\" '(and e d))" "(t \\"and-e1\\" '(and e d) 'a)" "(t \\"and-e1\\" '(and e d))" "(t \\"and-e1\\" '(and e f))" "(t \\"and-i\\" 'a 'e)" "(t \\"test\\" '(and e f))" "(apply-rule \\"forall-i\\" '(infer (actual F)\\n                               (substitution (P x) F x)))"]
eclipse.preferences.version=1
