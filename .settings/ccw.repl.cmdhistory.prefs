cmdhistory=["(step-f c \\"and-i\\" 1 2)" "(choose-option (step-f c \\"and-i\\" 1 2)\\n               3 1)" "(choose-option (step-f c \\"and-i\\" 1 2)\\n               3 2)" "(step-b c \\"and-i\\" 1 3)" "(step-b c \\"and-i\\" 1 4)" "(choose-option (step-b c \\"and-i\\" 1 4)\\n               4 1)" "(choose-option (step-b c \\"and-i\\" 1 4)\\n               4 2)" "(step-b c \\"and-i\\" 4)" "(empty? nil)" "(step-b c \\"and-i\\" 4)" "(step-f c \\"and-i\\" 1 2)" "a" "b" "(step-b b \\"not-e\\" 1 3)" "(choose-option (step-b c \\"and-i\\" 4)\\n               3 2)" "(choose-option (step-b b \\"not-e\\" 1 3)\\n               3 2)" "a" "(step-f a \\"and-e2\\" 1)" "(step-f (step-f a \\"and-e2\\" 1) \\"and-e1\\" 1)" "(def a (proof 'a 'b))" "(step-f \\"or-i1\\" a 1)" "(step-f a \\"or-i1\\" 1)" "\\ndeduction-playground.proof-new/var-id" "(reset\! deduction-playground.proof-new/var-id 0)" "(step-f a \\"or-i1\\" 1)" "(deduction-playground.auto-logic/apply-rule2\\n  \\"exists-i\\" false \\n  '(actual g) 'contradiction)" "(deduction-playground.auto-logic/apply-rule2\\r\\n     \\"exists-i\\" false \\r\\n     '(actual g) '(exists [x] (P x)))" "(deduction-playground.auto-logic/apply-rule2\\r\\n        \\"exists-i\\" false \\r\\n        '[(actual g)] '[(exists [x] (P x))])" "(deduction-playground.auto-logic/apply-rule2\\r\\n           \\"exists-i\\" false \\r\\n           '[(exists [x] (P x))] '[(actual g)] )" "(deduction-playground.proof-new/create-items \\n  '((substitution (P x) x g)))" "(map \#(if (vector? %) \\r\\n        [(\:id (first %)) (\:id (last %))]\\r\\n        (\:id %)) '({\:id 13, \:body (P g), \:rule nil}))" "(deduction-playground.auto-logic/apply-rule2\\n  \\"not-e\\" false '[contradiction]\\n  '[(not a)])" "(step-f (proof '(and a b) 'c) \\"and-e1\\" 1)" "(def a (step-f (proof '(and a b) 'c) \\"and-e1\\" 1))" "(step-f a \\"test\\" 1 2)" "(def b '[{\:id 1 \:body (and a b) \:rule \:premise}\\n         {\:id 2 \:body \:todo \:rule nil}\\n         {\:id 3 \:body a \:rule nil}])" "(step-f b \\"test\\" 1 3)" "(def c '[{\:id 1 \:body a \:rule \:premise}\\n         {\:id 2 \:body b \:rule \:premise}\\n         {\:id 3 \:body \:todo \:rule nil}\\n         {\:id 4 \:body c \:rule nil}])" "(step-f c \\"multi\\" 1 2)" "(def c '[{\:id 1 \:body a \:rule \:premise}\\r\\n            {\:id 2 \:body b \:rule \:premise}\\r\\n            {\:id 3 \:body \:todo \:rule nil}\\r\\n            {\:id 4 \:body (not a) \:rule nil}])" "(step-f c \\"multi\\" 1 2 4)" "(deduction-playground.proof-new/check-duplicates\\n  '[{\:id 1 \:body a \:rule \:assumption}\\n    {\:id 2 \:body b \:rule \\"blabla\\"}\\n    {\:id 3 \:body \:todo \:rule nil}\\n    {\:id 12 \:body a \:rule nil}\\n    {\:id 13 \:body b \:rule nil}\\n    {\:id 4 \:body (and a b) \:rule \\"and-i (12 13)\\"}])" "(deduction-playground.proof-new/check-duplicates\\r\\n  '[{\:id 1 \:body a \:rule \:assumption}\\r\\n    {\:id 2 \:body b \:rule \\"blabla\\"}\\r\\n    {\:id 3 \:body \:todo \:rule nil}\\r\\n    {\:id 12 \:body a \:rule nil}\\r\\n    {\:id 13 \:body b \:rule nil}\\r\\n    {\:id 4 \:body (and a b) \:rule \\"and-i (12 13)\\"}])" "(def a '{a [{\:id 1, \:body a, \:rule \:assumption} {\:id 12, \:body a, \:rule nil}], b [{\:id 2, \:body b, \:rule blabla} {\:id 13, \:body b, \:rule nil}]})" "(map val a)" "(map \#(let [remain (filter \:rule %)\\n            delete (remove \:rule %)]\\n        (for [x remain\\n              y delete]\\n          (hash-map x y))) (map val a))" "(map \#(let [remain (map \:id (filter \:rule %))\\r\\n            delete (map \:id (remove \:rule %))]\\r\\n        (for [x remain\\r\\n              y delete]\\r\\n          (hash-map x y))) (map val a))" "(map \#(let [remain (map \:id (filter \:rule %))\\r\\n            delete (map \:id (remove \:rule %))]\\r\\n        (first (for [x remain\\r\\n              y delete]\\r\\n          (hash-map x y)))) (map val a))" "(map \#(let [remain (map \:id (filter \:rule %))\\r\\n            delete (map \:id (remove \:rule %))]\\r\\n        (apply merge (first (for [x remain\\r\\n              y delete]\\r\\n          (hash-map x y))))) (map val a))" "(apply merge ({1 2} {3 4}))" "(apply merge '({1 2} {3 4}))" "(map \#(apply merge (let [remain (map \:id (filter \:rule %))\\r\\n               delete (map \:id (remove \:rule %))]\\r\\n           (first (for [x remain\\r\\n                 y delete]\\r\\n             (hash-map x y))))) (map val a))" "(map \#(let [remain (map \:id (filter \:rule %))\\r\\n               delete (map \:id (remove \:rule %))]\\r\\n           (first (for [x remain\\r\\n                 y delete]\\r\\n             (hash-map x y)))) (map val a))" "(map \#(apply merge (let [remain (map \:id (filter \:rule %))\\r\\n                         delete (map \:id (remove \:rule %))]\\r\\n                     (first (for [x remain\\r\\n                                  y delete]\\r\\n                              (hash-map x y))))) (map val a))" "(apply merge (map \#(let [remain (map \:id (filter \:rule %))\\r\\n               delete (map \:id (remove \:rule %))]\\r\\n           (first (for [x remain\\r\\n                 y delete]\\r\\n             (hash-map x y)))) (map val a)))" "(deduction-playground.proof-new/check-duplicates\\r\\n     '[{\:id 1 \:body a \:rule \:assumption}\\r\\n       {\:id 2 \:body b \:rule \\"blabla\\"}\\r\\n       {\:id 3 \:body \:todo \:rule nil}\\r\\n       {\:id 12 \:body a \:rule nil}\\r\\n       {\:id 13 \:body b \:rule nil}\\r\\n       {\:id 4 \:body (and a b) \:rule \\"and-i (12 13)\\"}])" "a" "(def b '{a [{\:id 1, \:body a, \:rule \:assumption} {\:id 12, \:body a, \:rule nil} {\:id 23 \:body a \:rule nil}], b [{\:id 2, \:body b, \:rule blabla} {\:id 13, \:body b, \:rule nil}]})" "b" "(apply merge (map \#(let [remain (map \:id (filter \:rule %))\\r\\n                  delete (map \:id (remove \:rule %))]\\r\\n              (first (for [x remain\\r\\n                    y delete]\\r\\n                (hash-map x y)))) (map val b)))" "(apply merge (map \#(let [remain (map \:id (filter \:rule %))\\r\\n                  delete (map \:id (remove \:rule %))]\\r\\n              (for [x remain\\r\\n                    y delete]\\r\\n                (hash-map x y))) (map val a)))" "(let [remain (map \:id (filter \:rule (first b)))\\n      delete (map \:id (remove \:rule (first b)))]\\n  delete)" "(first b)" "(let [remain (map \:id (filter \:rule (val (first b))))\\r\\n      delete (map \:id (remove \:rule (val (first b))))]\\r\\n     delete)" "(let [remain (map \:id (filter \:rule (val (first b))))\\r\\n         delete (map \:id (remove \:rule (val (first b))))]\\r\\n        remain)" "(let [remain (map \:id (filter \:rule (val (first b))))\\r\\n      delete (map \:id (remove \:rule (val (first b))))]\\r\\n  (reduce \#(assoc %1 %2 (last remain)) {} delete))" "(deduction-playground.proof-new/check-duplicates\\r\\n        '[{\:id 1 \:body a \:rule \:assumption}\\r\\n          {\:id 2 \:body b \:rule \\"blabla\\"}\\r\\n          {\:id 3 \:body \:todo \:rule nil}\\r\\n          {\:id 12 \:body a \:rule nil}\\r\\n          {\:id 13 \:body b \:rule nil}\\r\\n          {\:id 4 \:body (and a b) \:rule \\"and-i (12 13)\\"}])" "(def c '[{\:id 1 \:body (and a b) \:rule \:premise}\\n         {\:id 2 \:body \:todo \:rule nil}\\n         {\:id 3 \:body (and a b) \:rule nil}\\n         [{\:id 4 \:body a \:rule \:assumption}\\n          {\:id 5 \:body \:todo \:rule nil}\\n          {\:id 12 \:body (and a b) \:rule nil}\\n          {\:id 6 \:body b \:rule \\"bla\\"}]])" "(deduction-playground.proof-new/check-duplicates\\n  c)" "(def d '[{\:id 1 \:body (and a b) \:rule \:premise}\\r\\n         {\:id 2 \:body \:todo \:rule nil}\\r\\n         {\:id 3 \:body a \:rule nil}\\r\\n         [{\:id 4 \:body a \:rule \:assumption}\\r\\n          {\:id 5 \:body \:todo \:rule nil}\\r\\n          {\:id 12 \:body a \:rule nil}\\r\\n          {\:id 6 \:body b \:rule \\"bla\\"}]])" "(deduction-playground.proof-new/check-duplicates\\n  d)" "(deduction-playground.proof-new/check-duplicates\\r\\n     d)" "(deduction-playground.proof-new/check-duplicates\\r\\n     c)" "(deduction-playground.proof-new/check-duplicates\\r\\n           '[{\:id 1 \:body a \:rule \:assumption}\\r\\n             {\:id 2 \:body b \:rule \\"blabla\\"}\\r\\n             {\:id 3 \:body \:todo \:rule nil}\\r\\n             {\:id 12 \:body a \:rule nil}\\r\\n             {\:id 13 \:body b \:rule nil}\\r\\n             {\:id 4 \:body (and a b) \:rule \\"and-i (12 13)\\"}])" "(def a '[{\:id 1 \:body a \:rule \:premise}\\n         [{\:id 2 \:body a \: rule \:assumption}\\n          {\:id 3 \:body \:todo \:rule nil}\\n          {\:id 4 \:body b \:rule nil}]\\n         {\:id 5 \:body \:todo \:rule nil}\\n         {\:id 6 \:body (impl a b) \:rule nil}])" "(def a '[{\:id 1 \:body a \:rule \:premise}\\r\\n         [{\:id 2 \:body a \:rule \:assumption}\\r\\n          {\:id 3 \:body \:todo \:rule nil}\\r\\n          {\:id 4 \:body b \:rule nil}]\\r\\n         {\:id 5 \:body \:todo \:rule nil}\\r\\n         {\:id 6 \:body (impl a b) \:rule nil}])" "(step-f a \\"impl-i\\" (between 2 4))" "(step-f a \\"impl-i\\" [2 4])" "(infer 'a 'b)" "(infer '[a] 'b)" "(step-f a \\"impl-i\\" [2 4])" "(def b '[{\:id 1 \:body (or a b) \:rule \:premise}\\n         [{\:id 2 \:body a \:rule \:assumption}\\n          {\:id 3 \:body \:todo \:rule nil}\\n          {\:id 4 \:body X \:rule nil}]\\n         {\:id 5 \:body \:todo \:rule nil}\\n         {\:id 6 \:body X \:rule nil}])" "(step-b b \\"or-e\\" 1 [2 4] 6)" "(step-f a \\"impl-i\\" [2 4])" "(step-b b \\"or-e\\" 1 [2 4] 6)" "(if (vector? %) [(\:id (first %)) (\:id (last %))] (\:id %))" "(step-b b \\"or-e\\" 1 [2 4] 6)" "b" "(step-b b \\"or-e\\" 1 [2 4] 6)" "(def c (proof '[a b] '(and a b)))" "(step-f c \\"multi\\" 1 2)" "(def c (proof '[a b c] '(not c)))" "(step-f c \\"smulti\\" 1 2 3 5)" "c" "(def a (proof '[a b c] '(not c)))" "(step-f a \\"smulti\\" 1 2 3 5)" "(choose-option (step-f a \\"smulti\\" 1 2 3 5) 4 1)" "(step-f a \\"smulti\\" 1 2 3 5)" "(choose-option (step-f a \\"smulti\\" 1 2 3 5) 4 2)" "(step-f a \\"smulti\\" 1 2 3 5)" "(choose-option (step-f a \\"smulti\\" 1 2 3 5) 4 1)" "(def a '[{\:id 1 \:body a \:rule \:premise}\\n         {\:id 2 \:body {1 [a (and a b)]\\n                       2 [a (and b a)]} \:rule \\"bla\\"}\\n         {\:id 3 \:body \:todo \:rule nil}\\n         {\:id 4 \:body (and a b) \:rule nil}])" "(choose-option a 2 1)" "(choose-option a 2 2)" "(def a '[{\:id 1 \:body a \:rule \:premise}\\n         {\:id 3 \:body \:todo \:rule nil}\\r\\n         {\:id 2 \:body {1 [a (and a b)]\\r\\n                       2 [a (and b a)]} \:rule nil}\\r\\n         {\:id 4 \:body (and a b) \:rule \\"bla\\"}])" "(choose-option a 3 1)" "(choose-option a 3 2)" "(def a '[{\:id 1 \:body (and a b) \:rule \:prem}\\n         {\:id 2 \:body \:todo \:rule nil}\\n         {\:id 3 \:body a \:rule nil}\\n         {\:id 4 \:body b \:rule nil}])" "(step-b a \\"test\\" 3 4)" "(choose-option (step-b a \\"test\\" 3 4) 3 1)" "(choose-option (step-b a \\"test\\" 3 4) 3 2)" "(def b '[{\:id 1 \:body a \:rule \:premise}\\n         {\:id 2 \:body b \:rule \:premise}\\n         {\:id 3 \:body \:todo \:rule nil}\\n         {\:id 4 \:body (not a) \:rule nil}\\n         {\:id 5 \:body (and a b) \:rule nil}])" "(step-b b \\"multi\\" 4 5)" "(def b '[{\:id 1 \:body a \:rule \:premise}\\r\\n            {\:id 2 \:body b \:rule \:premise}\\r\\n            {\:id 3 \:body \:todo \:rule nil}\\r\\n            {\:id 4 \:body (not a) \:rule nil}\\r\\n            {\:id 5 \:body (or a b) \:rule nil}])" "(step-b b \\"multi\\" 4 5)" "(distinct? '(1 2 3 [3 4]))" "(distinct? '(1 3 [3 4] [3 4] 2))" "(distinct? 1 3 2 [3 4] [3 4] )" "(distinct? 1 2 3 [3 4])" "(< 2 1)" "(deduction-playground.proof-new/get-item\\n  '[1 2 [3 4] 5]\\n  [3 4])" "(def a (proof '[a b] '(and a b)))" "(deduction-playground.proof/proved? a)" "a" "(deduction-playground.proof/proved?\\n  (-> (proof '(not (or p q))\\r\\n                   '(and (not p) (not q)))\\r\\n          (step-b \\"and-i\\" 3)\\r\\n          (step-b \\"not-i\\" 3)\\r\\n          (step-b \\"not-i\\" 7)\\r\\n          (step-b \\"not-e\\" 1 4)\\r\\n          (choose-option 4 2)))" "(deduction-playground.proof/proved?\\r\\n     (-> (proof '(not (or p q))\\r\\n                      '(and (not p) (not q)))\\r\\n             (step-b \\"and-i\\" 3)\\r\\n             (step-b \\"not-i\\" 3)\\r\\n             (step-b \\"not-i\\" 7)\\r\\n             (step-b \\"not-e\\" 1 4)\\r\\n             (choose-option 4 2)))" "(conj [1 2] '(3 4 5))" "(apply \#(conj [1 2] %) '(3 4 5))" "(conj [1 2] 3 4 5)" "(apply \#(conj [1 2]) '(3 4 5))" "(deduction-playground.proof/proved?1\\r\\n        (-> (proof '(not (or p q))\\r\\n                         '(and (not p) (not q)))\\r\\n                (step-b \\"and-i\\" 3)\\r\\n                (step-b \\"not-i\\" 3)\\r\\n                (step-b \\"not-i\\" 7)\\r\\n                (step-b \\"not-e\\" 1 4)\\r\\n                (choose-option 4 2)))" "(deduction-playground.proof/proved?\\r\\n        (-> (proof '(not (or p q))\\r\\n                         '(and (not p) (not q)))\\r\\n                (step-b \\"and-i\\" 3)\\r\\n                (step-b \\"not-i\\" 3)\\r\\n                (step-b \\"not-i\\" 7)\\r\\n                (step-b \\"not-e\\" 1 4)\\r\\n                (choose-option 4 2)))" "(deduction-playground.proof/proved?1\\r\\n        (-> (proof '(not (or p q))\\r\\n                         '(and (not p) (not q)))\\r\\n                (step-b \\"and-i\\" 3)\\r\\n                (step-b \\"not-i\\" 3)\\r\\n                (step-b \\"not-i\\" 7)\\r\\n                (step-b \\"not-e\\" 1 4)\\r\\n                (choose-option 4 2)))" "(-> (proof '(not (or p q))\\r\\n                            '(and (not p) (not q)))\\r\\n                   (step-b \\"and-i\\" 3)\\r\\n                   (step-b \\"not-i\\" 3)\\r\\n                   (step-b \\"not-i\\" 7)\\r\\n                   (step-b \\"not-e\\" 1 4)\\r\\n                   (choose-option 4 2))" "(deduction-playground.proof/proved?1\\r\\n           (-> (proof '(not (or p q))\\r\\n                            '(and (not p) (not q)))\\r\\n                   (step-b \\"and-i\\" 3)\\r\\n                   (step-b \\"not-i\\" 3)\\r\\n                   (step-b \\"not-i\\" 7)\\r\\n                   (step-b \\"not-e\\" 1 4)\\r\\n                   (choose-option 4 2)))" "(def b {\:a 2 \:b 2})" "(deduction-playground.read-rules/export-theorem\\n  \\"src/deduction_playground/theorems.clj\\"\\n  b)" "(deduction-playground.read-rules/export-theorem\\r\\n     \\"src/deduction_playground/theorems.clj\\"\\r\\n     b)" "(deduction-playground.read-rules/export-theorem\\n  \\"src/deduction_playground/theorems.clj\\"\\n  (-> (proof '(not (or p q))\\r\\n                   '(and (not p) (not q)))\\r\\n          (step-b \\"and-i\\" 3)\\r\\n          (step-b \\"not-i\\" 3)\\r\\n          (step-b \\"not-i\\" 7)\\r\\n          (step-b \\"not-e\\" 1 4)\\r\\n          (choose-option 4 2)\\r\\n          (step-f \\"or-i1\\" 2)\\r\\n          (rename-var 'V1 'q)\\r\\n          (step-b \\"not-e\\" 7 1)\\r\\n          (choose-option 7 2)\\r\\n          (step-f \\"or-i2\\" 5)\\r\\n          (rename-var 'V2 'p)\\r\\n          )\\n  \\"TestTheorem\\")" "(deduction-playground.read-rules/export-theorem\\r\\n     \\"src/deduction_playground/theorems.clj\\"\\r\\n     (-> (proof '(not (or p q))\\r\\n                      '(and (not p) (not q)))\\r\\n             (step-b \\"and-i\\" 3)\\r\\n             (step-b \\"not-i\\" 3)\\r\\n             (step-b \\"not-i\\" 7)\\r\\n             (step-b \\"not-e\\" 1 4)\\r\\n             (choose-option 4 2)\\r\\n             (step-f \\"or-i1\\" 2)\\r\\n             (rename-var 'V1 'q)\\r\\n             (step-b \\"not-e\\" 7 1)\\r\\n             (choose-option 7 2)\\r\\n             (step-f \\"or-i2\\" 5)\\r\\n             (rename-var 'V2 'p)\\r\\n             )\\r\\n     \\"TestTheorem\\")" "(vector '(and a b))" "(deduction-playground.read-rules/export-theorem\\r\\n     \\"src/deduction_playground/theorems.clj\\"\\r\\n     (-> (proof '(not (or p q))\\r\\n                      '(and (not p) (not q)))\\r\\n             (step-b \\"and-i\\" 3)\\r\\n             (step-b \\"not-i\\" 3)\\r\\n             (step-b \\"not-i\\" 7)\\r\\n             (step-b \\"not-e\\" 1 4)\\r\\n             (choose-option 4 2)\\r\\n             (step-f \\"or-i1\\" 2)\\r\\n             (rename-var 'V1 'q)\\r\\n             (step-b \\"not-e\\" 7 1)\\r\\n             (choose-option 7 2)\\r\\n             (step-f \\"or-i2\\" 5)\\r\\n             (rename-var 'V2 'p)\\r\\n             )\\r\\n     \\"TestTheorem\\")" "(deduction-playground.read-rules/export-theorem\\n  \\"src/deduction_playground/theorems.clj\\"\\n  (-> (proof '[(impl a b) (not b)] '(not a))\\r\\n          (step-b \\"not-i\\" 4)\\r\\n          (step-f \\"impl-e\\" 1 3)\\r\\n          (step-f \\"not-e\\" 2 4)\\r\\n          )\\n  \\"modus-tollens\\")" "(or false 1)" "(or 1 2)" "(or nil 3)" "(def a (proof '(not b) '(not a)))" "a" "(step-b a \\"modus-tollens\\" 1 3)" "(list (list 1 2 3))" "(get-term-arg '[x (not y)])" "(map + [1 2 3] [4 5 6])" "(gen-logic-function '[a b] '[(and a b)])" "(gen-logic-function '[a (not a)] '[contradiction])" "(apply-rule2 \\"not-e\\" true '[a (not a)])" "(deduction-playground.auto-logic/make-rule \\"not-e\\")" "(deduction-playground.auto-logic/gen-logic-function\\n  '[a (not a)] '[contradiction])" "(deduction-playground.auto-logic/make-rule\\n  \\"not-e\\")" "(deduction-playground.auto-logic/make-rule\\n  {\:given '[contradiction]\\n   \:conclusion '[a (not a)]})" "(run* [q] ((eval (clojure.core/fn [contradiction q1 q2] (clojure.core.logic/fresh [a] (clojure.core.logic/\=\= contradiction (quote contradiction)) (clojure.core.logic/\=\= q1 a) (clojure.core.logic/\=\= q2 (clojure.core/seq (clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list a)))))))\\n            q '(not a) 'contradiction))" "(clojure.core.logic/run* [q] ((eval (clojure.core/fn [contradiction q1 q2] (clojure.core.logic/fresh [a] (clojure.core.logic/\=\= contradiction (quote contradiction)) (clojure.core.logic/\=\= q1 a) (clojure.core.logic/\=\= q2 (clojure.core/seq (clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list a)))))))\\r\\n               q '(not a) 'contradiction))" "(clojure.core.logic/run* [q] ((eval (clojure.core/fn [contradiction q1 q2] (clojure.core.logic/fresh [a] (clojure.core.logic/\=\= contradiction (quote contradiction)) (clojure.core.logic/\=\= q1 a) (clojure.core.logic/\=\= q2 (clojure.core/seq (clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list a)))))))\\r\\n                  q 'contradiction '(not a)))" "(def a (proof '[(impl p q) (not q)] '(not p)))" "a" "(deduction-playground.proof/get-scope\\n  a {\:rule \:premise, \:id 1, \:body (impl p q)})" "(deduction-playground.proof/get-scope\\n  [1 2 [3 4] [5 6 7] 8]\\n  5)" "(deduction-playground.proof/get-scope\\r\\n     [1 2 [3 4] [5 6 7] 8]\\r\\n     5)" "(read-rules)" "(read-theorems)" "(deduction-playground.read-rules/rules)" "deduction-playground.read-rules/rules" "@deduction-playground.read-rules/rules" "(read-rules)" "@deduction-playground.read-rules/rules" "(assoc {\:a 1} \:a 2)" "(proof '[a b] '(and a b))" "(step-f \\"and-i\\" 1 2)" "(proof '[a b] '(and a b))" "(step-f \\"and-i\\" 1 2)" "(pprint @p)" "(step-f \\"and-i\\" 1 2)" "(conj '(1 2 3) 5)" "(step-f \\"and-i\\" 1 2)" "(choose-option 3 1)" "(rename-var 'a 'c)" "(proof '[(at 3 a) (at 3 b)] '(at 3 (and a b)))" "(step-f \\"and-i\\" 1 2)" "(choose-option 3 1)" "(proof '[(at 2 a) (at 3 b)] '(at 4 (and a b)))" "(step-f \\"and-i\\" 1 2)" "(proof '(impl (asap (not a)) (not (asap a))))" "(step-b \\"impl-i\\" 2)" "(proof '(at x (impl (asap (not a)) (not (asap a)))))" "(step-b \\"impl-i\\" 2)" "(proof '(at x (impl (asap (not a)) (not (asap a)))))" "(step-b \\"impl-i\\" 2)" "(step-b \\"not-e\\" 2)" "(proof '(at x (impl (asap (not a)) (not (asap a)))))" "(step-b \\"impl-i\\" 2)" "(step-b \\"not-e\\" 2)" "(step-b \\"not-i\\" 2)" "(rename-var 'V1 'y)" "(rename-var 'V2 'a)" "(step-b \\"asap-e\\" 2)" "(rename-var 'V3 'x)" "(proof '(at x (impl (asap (not a)) (not (asap a)))))" "(step-b \\"impl-i\\" 2)" "(step-b \\"not-e\\" 2)" "(step-b \\"not-i\\" 2)" "(rename-var 'V1 'y)" "(rename-var 'V3 'x)" "(rename-var 'V2 'x)" "(proof '(at x (impl (asap (not a)) (not (asap a)))))" "(step-b \\"impl-i\\" 2)" "(step-b \\"not-e\\" 2)" "(step-b \\"not-i\\" 2)" "(rename-var 'V1 'y)" "(rename-var 'V2 'a)" "(step-f \\"asap-e\\" 7)" "(rename-var 'V3 'y)" "(step-f \\"not-e\\" 4)" "(step-f \\"asap-e\\" 2)" "(rename-var 'V4 y)" "(rename-var 'V4 'y)" "(proof '(at x (asap (not a))) '(at x (not (asap a))))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'x)" "(proof '(at x (asap (not a))) '(at x (not (asap a))))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3 1)" "(choose-option 3 1)" "(proof '(at x (asap (not a))) '(at x (not (asap a))))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'y)" "(rename-var 'V2 'a)" "(step-f \\"asap-e\\" 1)" "(rename-var 'V3 'y)" "(step-b \\"asap-e\\" 4)" "(rename-var 'V4 'x)" "(step-b \\"not-e\\" 4 )" "(proof '(at x (asap (not a))) '(at x (not (asap a))))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(concat [1 2 3] [4 5 6])" "(apply conj [1 2 3] [4 5 6])" "(apply conj [1 2 3] 'a [4 5])" "(deduction-playground.proof-new/infer\\n  'a '[b c])" "(deduction-playground.proof-new/infer \\n  '[a b] 'c)" "(deduction-playground.proof-new/infer\\r\\n     'a '[b c])" "(deduction-playground.proof-new/infer \\r\\n     '[a b] 'c)" "(deduction-playground.proof-new/infer \\r\\n     'a 'c)" "(deduction-playground.proof-new/infer \\r\\n     '[a b] '[c d])" "(proof '(at x (impl (asap (not a)) (not (asap a)))))" "(step-b \\"impl-i\\" 2)" "(step-f \\"asap-e\\" 1)" "(rename-var 'V1 'y)" "(step-b \\"not-e\\" 4)" "(step-b \\"not-i\\" 4)" "(rename-var 'V2 'y)" "(rename-var 'V3 'a)" "(step-f \\"not-e\\" 3)" "(step-f \\"asap-e\\" 4)" "(rename-var 'V4 'y)" "a" "(proof '(at x (impl (asap (not a)) (not (asap a)))))" "(step-b \\"impl-i\\" 2)" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'y)" "(rename-var 'V2 'a)" "(step-f \\"asap-e\\" 1)" "(rename-var 'V3 'y)" "(proof '(at x (impl (asap (not a)) (not (asap a)))))" "(step-b \\"impl-i\\" 2)" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'y)" "(rename-var 'V2 'a)" "(step-f \\"asap-e\\" 1)" "(rename-var 'V3 'y)" "(step-b \\"and-i\\" 5)" "(step-f \\"not-e\\" 3)" "(step-f \\"asap-e\\" 4)" "(rename-var 'V4 'y)" "(proof '(impl (sometimes a) (until true a)))" "(step-b \\"impl-i\\" 2)" "(proof '(at x (impl (sometimes a) (until true a))))" "(step-b \\"impl-i\\" 2)" "(step-f \\"sometimes-e\\" 1)" "(rename-var 'V1 'y)" "(step-b \\"not-e\\" 5)" "(step-b \\"not-i\\" 5)" "(rename-var 'V2 'y)" "(rename-var 'V3 'a)" "(step-b \\"and-i\\" 6)" "(step-f \\"until-e\\" 4)" "(proof '[(at i (or b a)) (at i (not a))] '(at i b))" "(step-f \\"or-e\\" 1 2)" "(proof '[(at i (or a b)) (at i (not a))] '(at i b))" "(step-f \\"or-e\\" 1 2)" "(proof '[(at i (or b a)) (at i (not a))] '(at i b))" "(step-b \\"or-e\\" 4)" "(rename-var 'V1 'a)" "(step-b \\"or-i1\\" 4)" "(proof '(at x (impl (asap (sometimes a)) (sometimes a))))" "(step-b \\"impl-i\\" 2)" "(step-f \\"seriality\\")" "(step-f \\"asap-seriality\\")" "(rename-var 'V3 'x)" "(rename-var 'V4 'y)" "(step-f \\"asap-e\\" 1)" "(rename-var 'V5 'y)" "(step-f \\"asap/<\=\\" 2)" "(step-f \\"sometimes-e\\" 3)" "(rename-var 'V6 'z)" "(step-f \\"transitivity\\" 4 5)" "(step-f \\"sometimes-i\\" 6 7)" "(proof '(impl (sometimes a) (until true a)))" "(step-b \\"impl-i\\" 2)" "(proof '(at x (impl (sometimes a) (until true a))))" "(step-b \\"impl-i\\" 2)" "(step-f \\"sometimes-e\\" 1)" "(rename-var 'V1 'y)" "(step-b \\"not-e\\" 5)" "(step-b \\"not-i\\" 5)" "(rename-var 'V2 y)" "(rename-var 'V2 'y)" "(rename-var 'V3 'a)" "(step-f \\"not-until\\" 4)" "(step-b \\"and-i\\" 7)" "(proof 'a 'b)" "(step-f \\"asap-seriality\\")" "(undo)" "(undO)" "(undo)" "(proof '(at x (impl (asap (not a)) (not (asap a)))))" "(step-b \\"impl-i\\" 2)" "(step-f \\"asap-e\\" 1)" "(rename-var 'V1 'y)" "(step-b \\"not-e\\" 4)" "(step-b \\"not-i\\" 4)" "(rename-var 'V2 'y)" "(rename-var 'V3 'a)" "(step-b \\"and-i\\" 5)" "(step-f \\"not-e\\" 3)" "(step-f \\"asap-e\\" 4)" "(rename-var 'V4 'y)" "(read/export-theorem\\n  \\"resources/theorems\\"\\n  @p\\n  \\"temporal-1\\")" "(proof '(at x (impl (not (sometimes a)) (always (not a)))))" "(step-b \\"impl-i\\" 2)" "(proof '(asap (not a)) '(not (asap a)))" "(step-b \\"not-e\\" 3)" "(proof '(at x (asap (not a)))\\n       '(at x (not (asap a))))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'y)" "(rename-var 'V2 'a)" "(step-f \\"not-e\\" 2)" "(step-b \\"and-i\\" 5)" "(step-f \\"asap-e\\" 1)" "(rename-var 'V3 'y)" "(step-f \\"asap-e\\" 4)" "(rename-var 'V4 'y)" "(read/export-theorem\\n  \\"resources/theorems.clj\\"\\n  @p\\n  \\"temporal-5\\")" "(proof '(at x (asap (not a))) '(at x (not (asap a))))" "(step-f \\"temporal-5\\" 1)" "(proof '(at x (asap (not a)))\\n       '(at x (not (asap a))))" "(step-f \\"temporal-5\\" 1)" "(show)" "(proof '(at x (asap (not a)))\\n       '(at x (not (asap a))))" "(step-f \\"temporal-5\\" 1)" "(show)" "@p" "(show)" "(proof '(at x (asap (not a)))\\n       '(at x (not (asap a))))" "(show)" "(step-b \\"not-e\\" 3)" "(usw 'clojure.string)" "(use 'clojure.string)" "(subs \\"\\\\\\"test\\\\\\" (1)\\"\\n     (.lastIndexOf  \\"\\\\\\"test\\\\\\" (1)\\" \\\\\\"))" "(subs \\"\\\\\\"test\\\\\\" (1)\\"\\r\\n        (.lastIndexOf  \\"\\\\\\"test\\\\\\" (1)\\" \\"\\\\\\"\\"))" "(subs \\"\\\\\\"test\\\\\\" (1)\\"\\r\\n        (inc (.lastIndexOf  \\"\\\\\\"test\\\\\\" (1)\\" \\"\\\\\\"\\")))" "(+ \\"asd\\" \\"asd\\")" "@p" "(proof '(at x (asap (not a)))\\n       '(at x (not (asap a))))" "(show)" "(step-f \\"temporal-5\\" 1)" "(show)" "(proof '(at x (not (sometimes a)))\\n       '(at x (always (not a))))" "(step-b \\"always-i\\" 3)" "(rename-var 'V1 'y)" "(step-b \\"not-i\\" 4)" "(undo)" "(step-b \\"not-i\\" 4)" "(rename-var 'V4 'x)" "(rename-var 'V5 '(sometimes a))" "(step-b \\"and-i\\" 5)" "(step-f \\"sometimes-i\\" 2 3)" "(read/export-theorem\\n  \\"resources/theorems.clj\\"\\n  @p\\n  \\"temporal-6\\")" "(proof '(at x (not (sometimes a)))\\n       '(at x (always (not a))))" "(step-f \\"temporal-6\\" 1)" "(proof '(at x (not (always a)))\\n       '(at x (sometimes (not a))))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'x)" "(rename-var 'V2 '(always a))" "(step-b \\"and-i\\" 4)" "(step-f \\"temporal-6\\" 2)" "(rename-var '(not (not a))\\n            'a)" "(read/export-theorem\\n  \\"resources/theorems.clj\\"\\n  @p\\n  \\"temporal-7\\")" "(proof '(at x (not (always a)))\\n       '(at x (sometimes (not a))))" "(step-f \\"temporal-7\\")" "(read/read-theorems \\"resources/theorems.clj\\")" "(step-f \\"temporal-7\\" 1)" "(clojure.walk/postwalk-demo [1 2 [3 4]5 ])" "(str \\"asd asd\\" 123)" "(proof '(at x (not (always a)))\\n       '(at x (sometimes (not a))))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'x)" "(rename-var 'V2 '(always a))" "(step-b \\"and-i\\" 4)" "(step-f \\"temporal-6\\" 2)" "(classical 3)" "@p" "(clojure.walk/postwalk (fn [node]\\n                         (if (\= node 2)\\n                           3\\n                           node))\\n                       [1 2 [1 2 [1 2] 3] 3])" "(clojure.walk/postwalk (fn [node]\\r\\n                                          (if (list? node)\\r\\n                                            (cond \\r\\n                                              (and (\= 'and (first node))\\r\\n                                                   (some false? (rest node))) false\\r\\n                                              (and (\= 'and (first node))\\r\\n                                                   (some true? (rest node))) (first (remove true? (rest node)))\\r\\n                                              (and (\= 'or (first node))\\r\\n                                                   (some true? (rest node))) true\\r\\n                                              (and (\= 'or (first node))\\r\\n                                                   (some false? (rest node))) (first (remove false? (rest node)))\\r\\n                                              (and (\= 'not (first node))\\r\\n                                                   (list? (second node))\\r\\n                                                   (\= 'not (first (second node)))) (second (second node))\\r\\n                                              (and (\= 'not (first node))\\r\\n                                                   (true? (second node))) false\\r\\n                                              (and (\= 'not (first node))\\r\\n                                                   (false? (second node))) true)\\r\\n                                            node))\\r\\n                                        '(at x (always (not (not a)))))" "(undo)" "(classical 3)" "@p" "(undo)" "(classical 3)" "(proof '(at x (until a false))\\n       'false)" "(proof '(at x (until a false))\\n       '(at x false))" "(step-b \\"impl-e\\" 3)" "(rename-var 'V1 '(until a false))" "(step-b \\"until-e\\" 3)" "(proof '(at x (until a false))\\n       '(at x false))" "(step-b \\"impl-e\\" 3)" "(rename-var 'V1 '(until a false))" "(step-b \\"until-e\\" 3)" "(classical 3)" "(undo)" "(classical 3)" "(undo)" "(classical 3)" "(undo)" "(proof '(at x (impl a b))\\n       '(at x (impl (not b) (not a))))" "(step-b \\"impl-i\\" 3)" "(step-b \\"not-i\\" 4)" "(rename-var 'V1 'x)" "(rename-var 'V2 'b)" "(step-b \\"and-i\\" 5)" "(step-f \\"impl-e\\" 1 3)" "(proof '(at x a)\\n       '(at x (always a)))" "(step-f \\"reflexivity\\")" "(rename-var 'V1 'x)" "(undo)" "(proof '(at x a)\\n       '(at x (always a)))" "(step-b \\"always-i\\" 3)" "(rename-var 'V1 'x)" "(read/export-theorem\\n  \\"resources/theorems.clj\\"\\n  @p \\n  \\"temporal-1\\")" "(read/read-theorems)" "(read/read-theorems \\"resources/theorems.clj\\")" "(proof '(at x (until a false))\\n       '(at x false))" "(step-b \\"impl-i\\" 3)" "(step-b \\"impl-e\\" 3)" "(rename-var 'V1 '(until a false))" "(step-b \\"until-e\\" 3)" "(step-b \\"temporal-1\\" 3)" "(step-f \\"temporal-1\\" 1)" "(proof '(at x (and true a)) '(at x a))" "(classical 1)" "(proof '(at x (sometimes a))\\n       '(until true a))" "(proof '(at x (sometimes a))\\n       '(at x (until true a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'y)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(step-f \\"sometimes-e\\" 1)" "(rename-var 'V3 'y)" "(step-f \\"not-until\\" 4)" "(classical 5)" "(step-f \\"temporal-8\\" 6)" "(proof '(until a false) 'false)" "(proof '(at x (sometimes a)) '(at x (until true a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'y)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(step-f \\"sometimes-e\\" 1)" "(rename-var 'V3 'y)" "(step-b \\"always-e\\" 6)" "(rename-var 'V4 'x)" "(step-f \\"not-until\\" 4)" "(classical 5)" "(proof '(or a (and b false)) 'a)" "(classical 1)" "(clojure.walk/postwalk-demo [1 2 [3 4] 5])" "(pr-str \\"hallo\\"\\n        '(1 2 3))" "(proof '(at x (sometimes a)) '(at x (until true a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'y)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(step-f \\"sometimes-e\\" 1)" "(rename-var 'V3 'y)" "(step-f \\"not-until\\" 4)" "(classical 5)" "(step-f-inside \\"temporal-8\\" 6)" "(list 1 '(2 3 4))" "(step-f-inside \\"temporal-8\\" 6)" "(deduction-playground.auto-logic/rule-givens\\n  \\"temporal-8\\")" "(deduction-playground.auto-logic/rule-givens\\r\\n     \\"temporal-8\\")" "(deduction-playground.auto-logic/rule-givens\\r\\n     \\"and-i\\")" "(deduction-playground.auto-logic/rule-givens\\r\\n     \\"temporal-8\\")" "(proof '(at x (sometimes a)) '(at x (until true a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'y)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(step-f \\"sometimes-e\\" 1)" "(rename-var 'V3 'y)" "(step-f \\"not-until\\" 4)" "(classical 5)" "(step-f-inside \\"temporal-8\\" 6)" "(conj '(1 2 3) (list \\"proof\\" \\"rule\\"))" "(conj '(1 2 3) \\"proof\\" \\"rule\\")" "(step-f-inside \\"temporal-8\\" 6)" "(symbol? false)" "(symbol? true)" "(step-f-inside \\"temporal-8\\" 6)" "@p" "(reset\! p bla)" "(show)" "(step-f-inside \\"temporal-8-in\\" 6)" "(classical 1)" "(proof '(at x (sometimes a)) '(at x (until true a)))" "(step-b \\"not-e\\" 3)" " (step-b \\"not-i\\" 3)" "(rename-var 'V1 'y)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(step-f \\"sometimes-e\\" 1)" "(rename-var 'V3 'y)" "(step-f \\"not-until\\" 4)" "(classical 5)" "(step-f-inside \\"temporal-8-in\\" 6)" "(classical 7)" "(step-f \\"always-e\\" 8 3)\#" "(show)" "@p" "(show)" "(undo)" "@p" "(proof '(at x (sometimes a)) '(at x (until true a)))" "(step-f \\"sometimes-e\\" 1)" "(rename-var 'V1 'y)" "(step-b \\"not-e\\" 5)" "(step-b \\"not-i\\" 5)" "(rename-var 'V2 'y)" "(rename-var 'V3 'a)" "(step-b \\"and-i\\" 6)" "(step-f \\"not-until\\" 4)" "(classical 5)" "(step-f-inside \\"temporal-8-in\\" 6)" "(show)" "@p" "(proof '(at x (sometimes a)) '(at x (until true a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'y)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(step-f \\"sometimes-e\\" 1)" "(rename-var 'V3 'y)" "(step-f \\"not-until\\" 4)" "(classical 5)" "(step-f-inside \\"temporal-8-in\\" 6)" "(classical 7)" "(step-f \\"always-e\\" 8 3)" "(deduction-playground.read-rules/export-theorem\\n  @p\\n  \\"temporal-9\\")" "(deduction-playground.read-rules/export-theorem\\n  \\"resources/theorems.clj\\"\\r\\n     @p\\r\\n     \\"temporal-9\\")" "(proof '(at x (asap (sometimes a))) '(at x (sometimes a)))" "(step-b \\"sometimes-i\\" 3)" "(rename-var 'V1 'z)" "(step-f \\"asap-e\\" 1)" "(rename-var 'V2 'x1)" "(step-f \\"asap-seriality\\")" "(rename-var 'V3 'x)" "(rename-var 'V4 'x1)" "(step-f \\"asap/<\=\\" 3)" "(step-f \\"sometimes-e\\" 2)" "(rename-var 'V5 'z)" "(step-f \\"transitivity\\" 4 5)" "(deduction-playground.read-rules/export-theorem\\n  \\"resources/theorems.clj\\"\\n  @p\\n  \\"temporal-10\\")" "(proof '(at x (and true (asap (sometimes a))))\\n       '(at x (sometimes a)))" "(proof '(at x (always (and (impl a (asap a)) a)))\\n       '(at x (always a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'x)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(proof '(at x (and (always (impl a (asap a))) a))\\n       '(at x (always a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'x)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(step-f \\"and-e1\\" 1)" "(step-f \\"and-e2\\" 1)" "(step-f \\"temporal-7\\" 4)" "(step-f \\"temporal-9\\" 5)" "(proof '(at x (and (always (impl a (asap a)))))\\n       '(at x (always a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'x)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(step-f \\"and-e1\\" 1)" "(proof  '(at x (and (always (impl a (asap a))) a))\\n        '(at x (always a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'x)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(step-f \\"and-e1\\" 1)" "(step-f \\"and-e2\\" 1)" "(step-f \\"temporal-7\\" 4)" "(step-f \\"temporal-9\\" 5)" "(step-b \\"impl-e\\" 8 6)" "(step-b \\"until-e\\" 8)" "(proof '(at x (until a false))\\n       'false)" "(step-b \\"impl-e\\" 3)" "(proof '(at x (until a false))\\n       '(at x false))" "(step-b \\"impl-e\\" 3)" "(rename-var 'V1 '(until a false))" "(step-b \\"until-e\\" 3)" "(step-f \\"classical-13\\")" "(proof '(at x (until a false))\\n       '(at x false))" "(step-b \\"impl-e\\" 3)" "(rename-var 'V1 '(until a false))" "(step-b \\"until-e\\" 3)" "(step-f \\"classical-13\\")" "(rename-var 'V2 false)" "(insert-formula '(impl (and a (asap false)) false))" "(is-valid? '(impl a false))" "(if (and (\= 'impl (first '(impl a false)))\\r\\n               (false? (first (rest node)))) true)" "(if (and (\= 'impl (first '(impl a false)))\\r\\n                  (false? (first (rest '(impl a false))))) true)" "(insert-formula (impl (and a false) false))" "'(insert-formula (impl (and a false) false))" "(is-valid? '(impl (and a false) false9))" "(def a {\:1 a\\n        \:2 b \:3 c})" "(def a {\:a 1 \:b 2 \:c 3})" "(map key a)" "(map str (map key a))" "(map str (map symbol (map key a)))" "(map symbol (map key a))" "(map \#(subs 1) (map str (map key a)))" "(map \#(subs 1 %) (map str (map key a)))" "(map \#(subs % 1) (map str (map key a)))" "(apply-classicals '(and false a))" "@classicals" "(apply-classicals '(and false a))" "(impl (and a false) false)" "(apply-classicals '(impl (and a false) false))" "(contains? \#{1 2 3} 3)" "(drop (drop '(at x (and a b))))" "(drop 2 '(at x (and a b)))" "(class (first (drop 2 '(at x (and a b)))))" "(def a (proof '(impl (and a true) false)\\n              'b))" "a" "(classical a 1)" "(def a (proof '(impl (and a false) false)\\n              'b))" "(classical a 1)" "(def a (proof '(impl (and a true) false)\\n              'b))" "(classical a 1)" "(def a (proof '(impl (and a true) false)\\n              'b))" "(classical a 1)" "(insert-formula\\n  a\\n  '(impl false false))" "(insert-formula a\\n                '(impl (or a true) true))" "(proof '(at x (until a false))\\n       '(at x false))" "(step-b \\"impl-e\\" 3)" "(rename-var 'V1 '(until a false))" "(step-b \\"until-e\\" 3)" "(insert-formula '(at x (impl false false)))" "@p" "(undo)" "(insert-formula '(at x (impl false false)))" "@p" "(undo)" "(insert-formula '(at x (impl false false)))" "(show)" "@p" "(undo)" "(insert-formula '(at x (impl false false)))" "(show)" "(insert-formula '(at x (impl (and a (asap false)) false)))" "(and 'a false)" "(and 'a true)" "(or 'a true)" "(or true 'b)" "(proof '(at x (sometimes a))\\n       '(at x (until true a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'y)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(step-f \\"sometimes-e\\" 1)" "(rename-var 'V3 'y)" "(step-f \\"not-until\\" 4)" "(classical 5)" "(step-f-inside \\"temporal-8\\" 6)" "(undo)" "(step-f-inside \\"temporal-8\\" 6)" "(undo)" "(step-f-inside \\"temporal-8\\" 6)" "(undo)" "(step-f-inside \\"temporal-8\\" 6)" "(undo)" "(step-f-inside \\"temporal-8\\" 6)" "(classical 7)" "(undo)" "(classical 7)" "(undo)" "(classical 7)" "(undo)" "(classical 7)" "(undo)" "(classical 7)" "(conj '(1 2 3) '(4 5))" "(reduce conj '(1 2 3) '(4 5))" "(proof '(at x (sometimes a))\\n       '(at x (until true a)))" "(step-b \\"not-e\\" 3)" "((keyword name) @rules)" "(step-b \\"not-e\\" 3)" "(proof '(at x (sometimes a))\\n       '(at x (until true a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'y)" "(rename-var 'V2 'a)" "(step-f \\"not-until\\" 2)" "(classical 3)" "(undo)" "(classical 3)" "(undo)" "(classical 3)" "(step-f-inside \\"temporal-8\\" 4)" "(classical 5)" "(proof '(at x (and (always (impl a (asap a))) a))\\n       '(at x (always a)))" "(step-f \\"and-e1\\" 1)" "(step-f \\"and-e2\\" 1)" "(step-b \\"not-e\\" 5)" "(step-b \\"not-i\\" 5)" "(rename-var 'V1 'x)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 6)" "(step-f \\"temporal-7\\" 4)" "(step-f \\"temporal-9\\" 5)" "(insert-formula '(at x (impl a a)))" "(proof '(at x (and (always (impl a (asap a))) a))\\n       '(at x (always a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'x)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(step-f \\"and-e1\\" 1)" "(step-f \\"and-e2\\" 1)" "(step-f \\"temporal-7\\" 4)" "(step-f \\"temporal-9\\" 5)" "(insert-formula '(at x (impl (not a) (not a))))" "(step-f \\"generalisation\\" 2)" "(step-b \\"impl-e\\" 10)" "(rename-var 'V3 '(not a))" "(undo)" "(rename-var 'V3 '(until true (not a)))" "(step-b \\"until-e\\" 10)" "(step-b \\"always-i\\" 10)" "(rename-var 'V4 'v)" "(step-f \\"always-e\\" 9 5)" "(proof '(at x (and a (asap false)))\\n       '(at x false))" "(classical 1)" "(apply list false)" "(proof '(at x false)\\n       '(at x false))" "(deduction-playground.read-rules/export-theorem\\n  \\"resources/theorems.clj\\"\\n  @p\\n  \\"blabla\\")" "(class (clojure.walk/postwalk-demo\\n         '(1 2 (3 4) 5)))" "(proof '(at x (and a (asap false)))\\n       '(at x false))" "(classical 1)" "(undo)" "(classical 1)" "(undo)" "(classical 1)" "(insert-theorem \\"temporal-8\\")" "(undo)" "(insert-theorem \\"temporal-8\\")" "(undo)" "(insert-theorem \\"temporal-8\\")" "(proof '(at x (or (always a) (until a false)))\\n       'b)" "(step-f-inside \\"temporal-8\\" 1)" "(deduction-playground.auto-logic/get-rule \\"temporal-8\\")" "(step-f-inside \\"temporal-8\\" 1)" "(deduction-playground.proof-new/prep-temporal\\n  {\:given [(at x (until a false))], \:conclusion [(at x false)], \:proof \\"not yet\\"})" "(deduction-playground.proof-new/prep-temporal\\r\\n     {\:given '[(at x (until a false))], \:conclusion '[(at x false)], \:proof \\"not yet\\"})" "(deduction-playground.proof-new/prep-temporal\\r\\n        {\:given '[(at x (until a false))], \:conclusion '[(at x false)], \:proof \\"not yet\\"})" "(step-f-inside \\"temporal-8\\" 1)" "(show)" "(step-f-inside \\"temporal-8\\" 1)" "(classical 2)" "(undo)" "(classical 2)" "(proof '(impl (and a false) false))" "(classical 2)" "(proof '(impl (and a false) false)\\n       'b)" "(deduction-playground.read-rules/read-rules\\n  \\"resources/classic-theorems.clj\\")" "(deduction-playground.read-rules/read-rules\\n  \\"resources/classical-theorems\\")" "(deduction-playground.read-rules/read-rules\\r\\n     \\"resources/classical-theorems.clj\\")" "(show)" "(step-f \\"classical-1\\" 1)" "(step-f-inside \\"classical-1\\" 1)" "(classical 1)" "(undo)" "(classical 1)" "(classical 3)" "(classical 2)" "(undo)" "(classical 5)" "(proof '(at x (sometimes a))\\n       '(at x (until true a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 y)" "(rename-var 'V1 'y)" "(rename-var 'V2 'a)" "(step-f \\"sometimes-e\\" 1)" "(rename-var 'V3 'y)" "(step-f \\"not-until\\" 4)" "(classical 5)" "(step-f-inside \\"temporal-8\\" 6)" "(classical 7)" "(step-b \\"and-i\\" 10)" "(step-f \\"always-e\\" 3 8)" "(proof '(at x (impl (not a) (not a))))" "(classical 2)" "@p" "(undo)" "(classical 2)" "(deduction-playground.read-rules/export-theorem\\n  \\"resources/theorems.clj\\"\\n  @p\\n  \\"c1\\")" "(step-f \\"c1\\" 1)" "(proof '(at x (and (always (impl a (asap a))) a))\\n       '(at x (always a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'x)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(step-f \\"and-e1\\" 1)" "(step-f \\"and-e2\\" 1)" "(step-f \\"temporal-7\\" 4)" "(step-f \\"temporal-9\\" 5)" "(step-f \\"c1\\")" "(rename-var 'V3 'x)" "(rename-var 'V4 'a)" "(step-f \\"generalisation\\" 7)" "(step-b \\"impl-e\\" 10)" "(rename-var 'V5 '(until true (not a)))" "(step-b \\"until-e\\" 10)" "(step-b \\"always-i\\" 10)" "(rename-var 'V6 'v)" "(step-f \\"always-e\\" 9 3)" "(proof '(at x (impl a b))\\n       '(at x (impl (not b) (not a))))" "(step-b \\"impl-i\\" 3)" "(step-b \\"not-i\\" 4)" "(rename-var 'V1 'x)" "(step-f \\"impl-e\\" 1 3)" "(rename-var 'V2 'b)" "(step-b \\"and-i\\" 6)" "(deduction-playground.read-rules/export-theorem\\n  \\"resources/theorems.clj\\"\\n  @p\\n  \\"rule-2\\")" "(proof '[(at x (impl a b)) (at x (impl b c))]\\n       '(at x (impl a c)))" "(step-b \\"impl-i\\" 4)" "(step-f \\"impl-e\\" 1 3)" "(step-f \\"impl-e\\" 2 4)" "(deduction-playground.read-rules/export-theorem\\n  \\"resources/theorems.clj\\"\\n  @p\\n  \\"rule-3\\")" "(proof '(at x (and (always (impl a (asap a))) a))\\n       '(at x (always a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'x)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(step-f \\"and-e1\\" 1)" "(step-f \\"and-e2\\" 1)" "(step-f \\"temporal-7\\" 4)" "(step-f \\"temporal-9\\" 5)" "(step-b \\"impl-e\\" 8)" "(rename-var 'V3 '(until true (not a)))" "(step-b \\"until-e\\" 8)" "(step-f \\"c1\\")" "(rename-var 'V5 'a)" "(step-f \\"generalisation\\" 7)" "(rename-var 'V4 'x)" "(step-b \\"always-i\\" 10)" "(rename-var 'V6 'v)" "(step-f \\"always-e\\" 9 3)" "(step-f \\"rule-2\\" 10)" "(proof '(at x (and (always (impl a (asap a))) a))\\n       '(at x (always a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'x)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(step-f \\"and-e1\\" 1)" "(step-f \\"and-e2\\" 1)" "(step-f \\"temporal-7\\" 4)" "(step-f \\"temporal-9\\" 5)" "(step-f \\"c1\\")" "(rename-var 'V3 'x)" "(rename-var 'V4 a)" "(rename-var 'V4 'a)" "(step-f \\"generalisation\\" 7)" "(step-b \\"impl-e\\" 10)" "(rename-var 'V5 '(until true (not a)))" "(step-b \\"until-e\\" 10)" "(step-b \\"always-i\\" 10)" "(rename-var 'V6 'v)" "(step-f \\"always-e\\" 9 3)" "(step-f \\"rule-2\\" 10)" "(proof '(at x (impl (asap (not a)) (not (asap a)))))" "(step-b \\"impl-i\\" 2)" "(step-f \\"asap-e\\" 1)" "(rename-var 'V1 'x1)" "(step-b \\"not-e\\" 4)" "(step-b \\"not-i\\" 4)" "(rename-var 'V2 'x1)" "(rename-var 'V3 'a)" "(step-b \\"and-i\\" 5)" "(step-f \\"not-e\\" 3)" "(step-f \\"asap-e\\" 4)" "(rename-var 'V4 'x1)" "(deduction-playground.read-rules/export-theorem\\n  \\"resources/theorems.clj\\"\\n  @p\\n  \\"teo-5\\")" "(proof '(at x (and (always (impl a (asap a))) a))\\n       '(at x (always a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'x)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(step-f \\"and-e1\\" 1)" "(step-f \\"and-e2\\" 1)" "(step-f \\"temporal-7\\" 4)" "(step-f \\"temporal-9\\" 5)" "(step-f \\"c1\\")" "(rename-var 'V3 'x)" "(rename-var 'V4 'a)" "(step-f \\"generalisation\\" 7)" "(step-b \\"impl-e\\" 10)" "(rename-var 'V5 '(until true (not a)))" "(step-b \\"until-e\\" 10)" "(step-b \\"always-i\\" 10)" "(rename-var 'V6 'v)" "(step-f \\"always-e\\" 9 3)" "(step-f \\"rule-2\\" 10)" "(step-f \\"teo-5\\")" "(rename-var 'V7 'v)" "(rename-var 'V8 'a)" "(step-f \\"rule-3\\" 11 12)" "(proof '(at x (impl (and true (asap (not a))) (asap (not a)))))" "(step-b \\"impl-i\\" 2)" "(classical 1)" "(deduction-playground.read-rules/export-theorem\\n  \\"resources/theorems.clj\\"\\n  @p\\n  \\"teo-4\\")" "(proof '(at x (and (always (impl a (asap a))) a))\\n       '(at x (always a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'x)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(step-f \\"and-e1\\" 1)" "(step-f \\"and-e2\\" 1)" "(step-f \\"temporal-7\\" 4)" "(step-f \\"temporal-9\\" 5)" "(step-f \\"c1\\")" "(rename-var 'V3 'x)" "(rename-var 'V4 'a)" "(step-f \\"generalisation\\" 7)" "(step-b \\"impl-e\\" 10)" "(rename-var 'V5 '(until true (not a)))" "(step-b \\"until-e\\" 10)" "(step-b \\"always-i\\" 10)" "(rename-var 'V6 'v)" "(step-f \\"always-e\\" 3 9)" "(step-f \\"rule-2\\" 10)" "(step-f \\"teo-5\\")" "(rename-var 'V7 'v)" "(rename-var 'V8 'a)" "(step-f \\"rule-3\\" 11 12)" "(step-f \\"teo-4\\")" "(rename-var 'V9 'v)" "(rename-var 'V10 'a)" "(step-f \\"rule-3\\" 13 14)"]
eclipse.preferences.version=1
