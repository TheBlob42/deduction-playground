cmdhistory=["t4" "(form-parser t4)" "(def t5 (form-to-string '(and (P (f c c)) true)))" "(form-parser t5)" "(def f (form-to-string '(and (not (P c)) (P (f c (f c c))))))" "(form-parser f)" "(def f2 (form-to-string '(and (not (P c c)) true)))" "(form-parser f2)" "(form-parser f)" "(form-parser f2)" "((pand (item 2) (item 3) (item 4)) [2 3 5])" "((pand-hl (item 2) (item 3) (item 4)) [2 3 5])" "((pand-lazy (item 2) (item 3) (item 4)) [2 3 5])" " ((pand-hl (item 2) (item 3) (item 4)) [2 3 5])" "((pand-hl (item 2) (item 3) (item 4)) [2 3 5])" "f" "(form-parser f)" "f2" "(form-parser f2)" "(def f (form-to-string '(or (and true (P c)) (not (P (f c c))))))" "(form-parser f)" "(form-parser [\\"true\\"])" "(def f2 (form-to-string '(and (P (f c c)) true)))" "(form-parser f2)" "f" "(def f3 (form-to-string '(or (P c) false)))" "(form-parser f3)" "(form-parser f)" "(def f4 (form-to-string '(or (and true false) (not true))))" "(form-parser f4)" "f2" "(def f5 (form-to-string '(or (and true true) true)))" "(form-parser f5)" "(def f6 (form-to-string '(not (or true true))))" "(form-parser f6)" "(def f7 (form-to-string '(and (not true) false)))" "(form-parser f7)" "(form-parser f)" "((item 2) [2 3])" "((item 2) [2])" "'(and 3 (not 3)" "(def t (form-to-string '(c \= c)))" "t" "(equals-parser t)" "(def t2 (form-to-string '(and (not (P c)) ((f c c) \= c))))" "(form-parser t2)" "(def t (form-to-string '(\= c (f c c))))" "(equals-parser t)" "(def t (form-to-string '(and (not (P c)) (\= (f c c) c))))" "(form-parser t)" "(def t (form-to-string '(\= c c)))" "(form-parser t)" "(equals-parser t)" "(form-parser t)" "(def t (form-to-string '(and (not true) (\= c c))))" "(form-parser t)" "(form-to-string '(forall [x] (P c)))" "(var-parser [\\"x\\"])" "(var-parser [\\"c\\"])" "(form-to-string '(forall [x] (P x)))" "(def f (form-to-string '(or (P x) false)))" "(form-parser f)" "(pred-parser [\\"(\\" \\"P\\" \\"x\\" \\")\\"])" "(def f (form-to-string '(and (P x) true)))" "(form-parser f)" "(def f (form-to-string '(forall [x] (P x))))" "(form-parser f)" "(forall-parser f)" "(p [2 3])" "(p [2 4])" "(p [1 2])" "(p [2 3 5])" "(p [5])" "(p [1 2 5])" "(p [2 3 5])" "(p [2 3 1 2 5])" "(p [1 2 5])" "(p [1 2 2 3 1 2])" "(p [1 2 2 3 5])" "(p [1 2 2 3 4])" "(p [1 2 2 3 1 4])" "(p [1 2 1 2 5])" "(p [1 2 5])" "((item 2) [1 2 5])" "((item 2) (1 2 5))" "((item 2) '(1 2 5))" "((item 1) [1 2 5])" "((item 1) '(2 5))" "((item 2) '(2 5))" "((pand-lazy (item 1) (item 2) (item 5)) [1 2 5])" "(pipe (item 1) [1 2])" "(doall (pipe (item 1) [1 2]))" "(pipe [(item 1)] [1 2])" "((item 1) [1 2])" "(cons 2 3)" "(cons [1 2] [ 3 4])" "(cons [1 2] (cons [3 4] [5 6]))" "(p [1 2 5])" "(por \\n  (item 2)\\n  bullshit)" "(declare bullshit)" "((por\\n   (item 2)\\n   (bullshit)) [2])" "((por (item 2) (fn [in] (assert false))) [2 3])" "(p [1 1 5])" "(c [1 1 5])" "(c [5])" "(c [1 5])" "(c [1 1 5])" "(c [1 5])" "(c [1 1 5])" "(c [ 1 1 5])" "(p [1 2 5])" "(c [1 1 2 5])" "(p [1 1 1 2 5])" "(p [1 1 2 5])" "(p [1 2 5])" "(c [1 2 5])" "(p [1 1 2 5])" "(c [1 1 2 5])" "(c [1 1 1 1 1 1 2])" "(c [1 2 1 2 5])" "(c [1 2 1 2 3])" "(p [1 2 1 2])" "(p [1 2])" "(c [1 2])" "(declare x)" "(def a (+ x 10))" "(defn a [] (+ x 10))" "a" "(a)" "(def x 5)" "(a)" "(def b (a))" "b" "(declare y)" "(def a ((fn [] (+ 10 y))))" "(p [1 2])" "(c [1 2])" "(p [1 2])" "p" "(o [1 2])" "(p [1 2])" "(c [1 2])" "(p [1 2])" "(c [1 2])" "(c [ 1 2 2 2 5])" "(c [1 2 2 3])" "(def f (form-to-string '(and (or (not true) false) true)))" "(form-parser f)" "(def f2 (form-to-string '(and (or (not true false) true) true)))" "(form-parser f2)" "(form-parser f)" "(form-parser f2)" "(form-parser f)" "(form-parser f2)" "(form-parser f)" "(c [1 2])" "(c [1 1 5 2 2])" "(c [1 1 5 2])" "(c [1 1 5 1 2])" "(c [1 1 5 5 2 2])" "(c [1 5 5 2])" "(c [1 1 5 5 2 2])" "(c [1 1 5 5 2 5 2])" "(form-parser [\\"(\\" \\"and\\" \\"(\\" \\"not\\" \\"true\\" \\")\\" \\"false\\" \\")\\"])" "(c [1 2 1 2 5])" "(c [1 1 2 2 5])" "(c [2 2 1 1 5])" "(f [\\"(\\" \\"and\\" \\"(\\" \\"or\\" \\"t\\" \\"t\\" \\")\\" \\"t\\" \\")\\"])" "(f [\\"and\\" \\"or\\" \\"t\\" \\"t\\" \\"t\\"])" "(f [\\"and\\" \\"or\\" \\"t\\" \\"t\\" \\"t\\" \\")\\"])" "(f [\\"and\\" \\"or\\" \\"t\\" \\"t\\" \\")\\" \\"t\\" \\")\\"])" "(f [\\"(\\" \\"and\\" \\"(\\" \\"or\\" \\"t\\" \\"t\\" \\")\\" \\"t\\" \\")\\"])" "(f [\\"(and\\" \\"(or\\" \\"t\\" \\"t\\" \\")\\" \\"t\\" \\")\\"])" "((pand-lazy (item \\"(\\") (item \\"and\\") (item \\")\\")) [\\"(\\" \\"and\\" \\"(\\"])" "(f [\\"(\\" \\"and\\" \\"(\\" \\"or\\" \\"t\\" \\"t\\" \\")\\" \\"t\\" \\")\\"])" "(f [\\"(\\" \\"and\\" \\"(\\" \\"or\\" \\"t\\" \\"t\\" \\"t\\" \\")\\" \\"t\\" \\")\\"])" "(f [\\"(\\" \\"or\\" \\"(\\" \\"and\\" \\"t\\" \\"t\\" \\")\\" \\"t\\" \\")\\"])" "(fts '(and (or true false) (not true)))" "(pForm (fts '(and (or true false) (not true))))" "(pForm (fts '(and (or true false) (not true false))))" "(pForm (fts '(and (P c) (or true false))))" "(pForm (fts '(and (or true false) (not true))))" "(pForm (fts '(and (not true) true)))" "(pForm (fts '(or (and true false) (not false))))" "(pForm (fts '(and (or (P c) true) (not false))))" "(pForm (fts '(or (P c) true)))" "(pForm (fts '(and (or (P c) true) false)))" "(pForm [\\"true\\"])" "(pForm (fts '(and (or (P c) true) false)))" "(pForm (fts '(and (or (P c) true) false)))\\r\\nOR" "(pForm (fts '(and (or (P c) true) false)))" "(pForm (fts '(and (or (P c) true) false)))\\r\\nOR" "(pForm (fts '(and (or (P c) true) false)))" "(pForm (fts '(and (or false (P c)) (not false))))" "(pForm (fts '(not (and true (or (P c) false)))))" "(pForm (fts '(and (or (P c) true) (not false))))" "(pForm (fts '(and (or (P c) false) (not true))))" "(pForm (fts '(and (or (P c c c ) false) (not true))))" "((just-check \:const) [\\"c\\"])" "(pPred (fts '(P c)))" "(pPred (fts '(P c c)))" "(pForm (fts '(or (and (P c) true) (not false))))" "(pForm (fts '(or (and (P c c ) true) (not false))))" "((item 2) [2])" "debug" "@debug" "(enDebug)" "diDebug" "(diDebug)" "@debug" "((item 2) [2])" "(enDebug)" "((item 2) [2])" "(pFunc [\\"(\\" \\"f\\" \\"c\\" \\"c\\" \\")\\"])" "(diDebug)" "(pFunc [\\"(\\" \\"f\\" \\"c\\" \\"c\\" \\"c\\" \\")\\"])" "(diDebug)" "(pFunc [\\"(\\" \\"f\\" \\"c\\" \\"c\\" \\"p\\" \\")\\"])" "(pPred (fts '(P (f c c))))" "(enDebug)" "(pPred (fts '(P (f c c))))" "(diDebug)" "(pPred (fts '(P (f c c))))" "(pForm (fts '(forall [x] (P c))))" "(enDebug)" "(pForm (fts '(forall [x] (P c))))" "((more pVar) [x x c])" "((more pVar) [\\"x\\" \\"x\\" \\"c\\"])" "((more pVar) [\\"x\\" \\"x\\" \\"c\\" \\"x\\"])" "((more pVar) [\\"c\\"])" "(pForm (fts '(forall [x] (P c))))" "((pand-lazy (pand (item \\"(\\") (item \\"forall\\")) (item \\"[\\") (more pVar) (item \\"]\\") pForm (item \\")\\"))\\n  (fts '(forall [x] (P c))))" "(pForm (fts '(forall [x] (P c))))" "((pand-lazy (more (item 2)) (item 3)) [2 2 2 2 3])" "((pand-lazy (more (item 2)) (item 3)) [3])" "(pForm (fts '(forall [x] (P c))))" "(pForm (fts '(forall [x y z] (P (f c c)))))" "(pForm (fts '(exist [x z] (and (P c) (not true)))))" "(pForm (fts '(forall [x] (and (\= x c) (P z)))))" "(pEquals (fts '(\= c x)))" "(pForm (fts '(forall [x] (and (\= x c) (P z)))))" "(add-variable \\"x\\" \:unbound)" "variables" "@variables" "(add-variable \\"y\\" \:bound)" "(\:x @variables)" "(reset\! variables {})" "(add-variable \\"x\\" \:bound)" "(\:x @variables)" "(\:bound @variables)" "(reset\! variables {})" "(add-variable \\"x\\" \:bound)" "(add-variable \\"x\\" \:unbound)" "(doc add-variable)" "(use '(clojure.repl))" "(doc map)" "(use '(clojure.repl repl))" "(use '[clojure.repl \:refer \:all])" "(doc map)" "(doc add-variable)" "(defn bla [x] \\"blabla\\" (+ x 10))" "(doc bla)" "(meta add-variable)" "@variables" "(add-variable \\"x\\" \:bound)" "(add-variable \\"x\\" \:unbound)" "(add-variable \\"X\\" \:bound)" "@variables" "(doc add-variable)" "((keyword \\"x\\") sign)" "((keyword \\"c\\") sign)" "((is-variable? true) [\\"x\\"])" "@variables" "(reset\! variables {})" "((is-variable? true) [\\"x\\"])" "((is-variable? false) [\\"x\\"])" "(is-variable? [\\"x\\"])" "((is-variable?) [\\"x\\"])" "((is-variable?) [\\"y\\"])" "@variables" "(pForm (fts '(forall [x] (and (P x) (or z (f c z))))))" "@variables" "(pForm (fts '(forall [x] (and (P x) true))))" "@variables" "(reset\! variables {})" "(pForm (fts '(exist [x y] (and (P x) (or (P (f z y)) (\= z x))))))" "@variables" "(reset\! variables {})" "(pForm (fts '(forall [x] (and (\= x c) (P (f c x))))))" "(pForm (fts '(forall [x] (P (f x c)))))" "(pForm (fts '(P (f c c))))" "(pTerm (fts '(f c c)))" "@variables" "(pFunc (fts '(f c c)))" "((por (is? \:const) pFunc) (fts '(f c c)))" "(pTerm (fts '(f c c)))" "((por \\r\\n     (is? \:const)\\r\\n     (is-variable?)\\r\\n     pFunc) (fts '(f c c)))" "((por \\r\\n        (is? \:const)\\r\\n        pFunc) (fts '(f c c)))" "((is-variable?) (fts '(f c c)))" "(reset\! variables {})" "(pForm (fts '(forall [x] (and (P (f c x)) (P z)))))" "@variables" "(pForm (fts '(forall [x] (and (P (f c x)) (P z)))))" "@variables" "(add-variable \\"z\\" \:unbound)" "@variables" "(reset\! variables {})" "(pForm (fts '(forall [x] (and (P (f c x)) (P z)))))" "@variables" "(diDebug)" "(pForm (fts '(true)))" "((optional (item 2)) [2])" "((pand (optional (item 2)) (item 3)) [2 3])" "((pand (optional (item \\"(\\")) (item \\"true\\") (optional \\")\\")) [\\"(\\" \\"true\\"])" "((optional (item \\"(\\")) [\\"(\\"])" "((pand (optional (item \\"(\\")) (item \\"true\\")) [\\"(\\" \\"true\\"])" "(pForm (fts '(true)))" "(pForm (fts '(and true false)))" "(pForm (fts '(true)))" "(pForm (fts '(false)))" "(pForm (fts '(and false true)))" "(pForm (fts '(P c)))" "(pForm (fts '(P (f c c))))" "(pForm (fts '(P c c)))" "(pForm (fts '(P2 c c)))" "(pForm (fts '(P x)))" "@variables" "(r)" "(pForm (fts '(P2 x y)))" "@variables" "(r)" "(pForm (fts '(\= c c)))" "(pForm (fts '(\= c c c)))" "(pForm (fts '(\= x z)))" "@variables" "(r)" "(pForm (fts '(\= (f c x) z)))" "@variables" "(r)" "(pForm (fts '(and true x)))" "@variables" "(pForm (fts '(and (or true (not false)) (or (and true (not false)) true))))" "(pForm (fts '(forall [x y] \\n                     (and (P2 (f x z) ) (not c)))))" "@variables" "(r)" "(pForm (fts '(exist [x] (and (P x) (not (P2 (f x z)))))))" "@variables" "(r)" "(formula '(and (not (P x)) true))" "@variables" "(formula '(exist [x] (P x)))" "(formula '(forall [x] (P2 x z)))" "(formula '(forall [x] (and (P x) (P2 (f c z) x))) sign)" "(diDebug)" "(formula '(forall [x] (and (P x) (P2 (f c z) x))) sign)" "(use '[clojure.repl \:refer \:all])" "(doc map)" "(doc add-variable\!)" "(doc swap\!)" "(def s {\:c [\:const 0]\\n        \:P [\:pred 1]\\n        \:f [\:func 2]})" "(formula form s)" "s" "form" "(def s {\:c [\:const 0]\\n        \:P [\:pref 1]\\n        \:f [\:func 2]})" "(formula form s)" "form" "s" "(split-form form)" "(parse-formula s (split-form form))" "(parse-formula s (split-form '(and true (P c))))" "(parse-formula s (split-form '(forall [x] (and (or (P z) false)\\n                                               (P (f x c))))))" "(formula '(forall [x] (and (P x) (or (P (f c z)))))\\n         {\:c [\:const 0]\\n          \:P [\:pred 1]\\n          \:f [\:func 2]})" "(def s {\:c [\:const 0]\\r\\n             \:P [\:pred 1]\\r\\n             \:f [\:func 2]})" "(parse-formula s '(forall [x] (and (P x) (or (P (f c z))))))" "(split-form '(forall [x] (and (P x) (or (P (f c z))))))" "(formula '(forall [x] (and (P x) (or (P (f c z)) true))) s)" "(def s (signature {\:const [\\"c\\"]\\n                   \:pred [\\"P\\" 1 \\"Q\\" 2]\\n                   \:func [\\"f\\" 2 \\"g\\" 3]}))" "s" "(def f '(exist [x] (and (P x) (or (Q c x) (P (f z x))))))" "(formula f s)" "(meta (formula f s))" "(def s (signature {\:const [\\"c\\"]\\n                   \:pred [\\"P\\" 1 \\"Q\\" 2]\\n                   \:func [\\"f\\" 2 \\"g\\" 3]}))" "s" "(def f '(exist [y] (and (P y) (Q (f c y) (g c y x)))))" "f" "(meta (formula f s))" "(def f '(forall [x] (P x)))" "(def s (signature {\:pred [\\"P\\" 1]}))" "(meta (formula f s))" "sign" "(distinct? '[d d e g h])" "(distinct? (seq '[d d eg j]))" "(seq '[d f g])" "(apply distinct? '[d d g])" "(apply distinct? '[d e g])" "(keyword p)" "(keyword 'P)" "(signature sign)" "(def x (signature sign))" "(\:Q x)" "(def x '{q [\:pred 0]})" "x" "('q x)" "(\:q x)" "(q x)" "(signature sign)" "(vals sign)" "(flatten (vals sign))" "(merge [1 2 3] [4 5])" "(concat [1 3 4] [5 6])" "(concat [1 1 1] nil [2 3])" "(\:func sign)" "(take-nth 2 (\:func sign))" "(apply distinct? (concat (\:const sign) (take-nth 2 (\:func sign))\\n                         (take-nth 2 (\:pred sign))))" "(apply distinct? (concat (\:const sign) (take-nth 2 (\:func sign))\\r\\n                            (take-nth 2 (\:pred sign))))" "(signature sign)" "(reduce into {} [1 2 3])" "(reduce concat [] [[1 2] [3 4]])" "(into {} [1 2 3 4])" "(symbol? x)" "(symbol? 'x)" "keywords" "(contains? keywords 'forall)" "(atom? 'x)" "(expr? 'forall)" "'true?" "'true" "true" "(symbol? true)" "(symbol? 'true)" "(def a '(and a b))" "(first a)" "(\= (first a) and)" "(\= (first a) 'and)" "(defn t [a]\\n  (cond \\n    (nil? a) true\\n    (\= (first a) 1) (t (rest a))\\n    (\= (first a) 2) (throw (IllegalStateException. \\"ERROR\\"))))" "(t [1 1 2])" "(t [1 1 1 ])" "(t nil)" "(defn t [a]\\r\\n     (cond \\r\\n       (nil? (first a)) true\\r\\n       (\= (first a) 1) (t (rest a))\\r\\n       (\= (first a) 2) (throw (IllegalStateException. \\"ERROR\\"))))" "(t [1 1 1 ])" "(wff? '(1 2 3))" "(wff? \\"asd\\")" "(wff? 'x)" "(wff? '(and true false))" "(wff' '(or true))" "(wff? '(or true))" "(\= (first '(\= true false)) '\=)" "(wff? '(and true))" "(wff? '(or true))" "(wff? '(and or or))" "(wff? '(and true or))" "(wff? '(and true true))" "(first true)" "(true)" "(wff? '(and true true))" "(rest true)" "(wff? '(and))" "(wff? 'true)" "(wff? '(bla))" "(second '(and bla 2))" "(third '(a d b))" "(wff? '(and (and true false) false))" "(wff? '(and true (and true false false)))" "(rest '(and 1 3 4))" "(wff? '(and true (and false false true)))" "(wff? '(and true (and false (and true true))))" "(wff? '(and true (and false (and true true false))))^" "(wff? '(and (or true false) (and true (or false true))))" "(wff? '(and (or true false true) (and true (or false true))))" "(wff? '(and true (and false true true) true))" "(defn is1 [p] (if (\= p 1) true false))" "(is1 3)" "(is1 1)" "(every? is1 (1 1 1 1))" "(every? is1 '(1 1 1))" "(every? is1 '(1 1 1 1 2))" "(wff? '(and true (and true false) false))" "(wff? '(and true false bla))" "(rest '(and true false bla))" "(every? subform '(true false))" "(every? subform '(true false bla))" "(str bla)" "(str 'bla)" "(wff? '(and true false bla))\#" "(wff? '(and true false bla))" "'(bla b g)" "(seq? ())" "(seq? [])" "(seq? {})" "(seq? \#{})" "(seq? 'g)" "(wff? '(and true false bla))" "(wff? '(and true (yeah true false)))" "(wff? '(and true (eef true false)))" "(not true true)" "(every? subform '())" "(wff? '(and ))" "(\= true and)" "(\= true 'and)" "(\= true ())" "(rest '(and ))" "(subform ())" "(subform '())" "(every? subform ())" "(wff? '(and ))" "(count (rest '(and)))" "(< 0 2)" "(< 2 0)" "(wff? '(and ))" "(wff? '(and true (and false)))" "(wff? '(and true (forall [x y] (or false (not true))) false))" "(wff? '(and true (forall [] (or false (not true))) false))" "(defn f [i] (if (\= i 1) true false))" "(f 3)" "(f 1)" "(take 3 (iterate f))" "(take 3 (iterate 'f))" "(take 3 (cycle 'f))" "(take 3 (cycle '(f)))" "(apply f (1 1 1))" "(apply f '(1 1 1))" "(is-with-arity? (P 1) \:pred f)" "(is-with-arity? '(P 1) \:pred 'f)" "(is? 'P \:pred)" "(is? 'f2 \:func)" "(f 1)" "(f 2)" "(every? 'f (rest '(P 1)))" "(rest '(P 1))" "(every? f (1))" "(every? f '(1))" "(every? f (rest '(P 1)))" "(is-with-arity? '(P 1) \:pred f)" "(is-with-arity? '(P 1 1) \:pred f)" "(is-with-arity? '(c) \:const f)" "(is-with-arity? '(x) \:pred f)" "(def x {\:a 1 \:b 2})" "(contains? x \:c)" "(contains? x \:a)" "(is? c \:const)" "(is? 'c \:const)" "(is? 'P \:pred)" "(is? 'c \:pred)" "(is? 'x \:pred)" "(is? 'c \:const)" "(if (is? 'c \:const) \\"ba\\")" "(is-with-arity? '(P 1) \:pred f)" "(is-with-arity? '(P 1 1) \:pred f)" "(is-with-arity? '(X 1) \:pred f)" "(function '(f c x))" "(term 'x)" "(if (\= 2 3) true)" "(function '(f c x))" "(function '(f P x))" "(function '(f B B))" "(is? 'P \:const)" "(function '(f P x))" "(term 'P)" "(symbol? 'P)" "(or (is? 'P \:const) (variable? 'P))" "(and (symbol? phi) \\r\\n               (or (is? phi \:const) \\r\\n                   (variable? phi)))" "(and (symbol? 'P) \\r\\n               (or (is? 'P \:const) \\r\\n                   (variable? 'P)))" "(def phi 'P)" "(or (and (symbol? phi) \\r\\n               (or (is? phi \:const) \\r\\n                   (variable? phi)))\\r\\n          (function phi))" " (and (symbol? phi) \\r\\n               (or (is? phi \:const) \\r\\n                   (variable? phi)))" "(or (and (symbol? phi) \\r\\n               (or (is? phi \:const) \\r\\n                   (variable? phi)))\\r\\n          (function 'phi))" "'phi" "(first phi)" "(term '(f P c))" "(function '(f P c))" "(function '(f c c))" "(pred '(P (f c x)))" "(predicate '(P (f c x)))" "(function '(f c x))" "(function '(f c P))" "(function '(f c x))" "(function '(f c c c))" "(is-with-arity? '(f c c) \:func term)" "(def f '(f c c c))" "(is-with-arity? f \:func term)" "(function '(f P c))" "(function '(f c c c))" "(function '(f (c c) c))" "(function '(f c c P))" "(function '(f P c))" "(term '(f c c c))" "(predicate '(P c c))" "(predicate '(P f))" "(subform '(forall [x] (P c)))" "(subform '(and (P (f P c)) true))" "(subform '(p c))" "(subform '(P c c))" "(subform '(P f))" "(subform '(P c))" "(and (symbol? 'f) (or (is? 'f \:const) (variable? 'f)))" "(list? 'f)" "(is-with-arity? (P f) \:pred term)" "(is-with-arity? '(P f) \:pred term)" "(second ((keyword (first '(P f))) sign))" "(\= (count (rest '(P f)) 1))" "(\= (count (rest '(P f))) 1)" "(every? term (rest '(P f)))" "(every? term 'f)" "(rest '(P f))" "(defn is1 [x] (if (\= x 1) true false))" "(every? is1 (1))" "(every? is1 '(1))" "(every? is1 (1 1 1))" "(function '(f c c))" "(predicate '(P f))" "(is-with-arity? '(P f) phi \:pred \#(term % phi))" "(is-with-arity? '(P f) \:pred \#(term % phi))" "(is-with-arity? '(P f) \:pred \#(term % '(P f)))" "(subform '(and (P (f c x)) true))" "(is? 'f \:func)" "(subform '(and (P (f c x)) true))" "(subform '(P (f c x)))" "(is? (first '(P (f c x))) \:pred)" "(term '(f c x))" "(is? '(f c x) phi \:func)" "(is? '(f c x) \:func)" "(term '(f c x))" "(subform '(and (P (f c x)) true))" "(subform '(exist [x y] (or (P c) (and (not (P (f x (f c c)))) false))))" "(and (\= 1 1) (\= 1 2) (throw (Exception. (str \\"asdkladkjasd\\"))))" "(and (\= 1 1) (\= 1 1) (throw (Exception. (str \\"asdkladkjasd\\"))))" "(time (subform '(exist [x y] (or (P c) (and (not (P (f x (f c c)))) false)))))" "(subform '(exist [x y] (or (P c) (and (not (P (f x (f c c)))) false))))" "(predicate '(exist [x]))" "(is? '(exist [x]) \:pred)" "(is? (first '(exist [x]) \:pred))" "(is? (first '(exist [x])) \:pred)" "(subform '(exist [x y] (or (P c) (and (not (P (f x (f c c)))) false))))" "(term '(f c (f P c)))" "(subform '(exist [P] (P x)))" "(subform '(forall [P x] (P x)))" "(subform '(forall [x P] '(P x)))" "(subform '(\= c (f x c)))" "(subform '(or (\= (f c x) y) (P y)))" "(defn t\\n  [i & [b]]\\n  (println i (if b (str \\" + \\" b))))" "(t \\"ha\\")" "(if (\= 1 2) true)" "(defn t\\r\\n     [i & [b]]\\r\\n     (println i (if b (str \\" + \\" b) \\"\\")))" "(t \\"asd\\")" "(t \\"asd\\" \\"asd\\")" "(term '(f P c))" "(term 'P)" "(str 'and)" "(single 'c)" "sign" "(\:c sign)\=" "(\:c sign)" "(\:c @sign)" "(subform '(forall [x] (and (P (f c x)) true)))" "(wff? '(forall [x] (and (P (f c x)) true)) s)" "s" "@sign" "(is? 'P \:pred)" "(\:P sign)" "(wff? '(forall [x] (and (P (f c x)) true)) s)" "(wff? '(forall [x] (and (P (f c Q)) true)) s)" "(wff? '(forall [x] (and (P (f c P2)) true)) s)" "(\= 1 1 1)" "(reset\! sign {} {})" "(throw (ArityException. \\"asdf\\"))" "(def s (signature {\:const '[c]\\n                   \:func '[f 1 g 2]\\n                   \:pred '[P 1 Q 2]}))" "s" "(def f '(forall [x] (and (P x) (not Q x c))))" "f" "(formula f s)" "(def f '(forall [x] (P x) (not (Q x c))))" "(formula f s)" "(def f '(forall [x] (and (P x) (Q c x))))" "(formula f s)" "(meta (formula f s))" "(run* [q]\\n      (everyg \#(membero % [\:a]) [\:a \:a \:a]))" "(run* [q]\\r\\n         (everyg \#(membero % [\:a]) [\:a \:a \:a])\\n         (\=\= q false))" "(run* [q]\\n      (fresh [x]\\n             (\=\= x false)\\n             (\=\= q true)\\n             (everyg \#(membero % [\:a]) (\:a \:a \:a))))" "(run* [q]\\r\\n         (fresh [x]\\r\\n                (\=\= x false)\\r\\n                (\=\= q true)\\r\\n                (everyg \#(membero % [\:a]) [\:a \:a \:a])))" "(run* [q]\\r\\n      (fresh [x y]\\r\\n             (everyg \#(membero % [\:a \:b]) q)\\n             (\=\= q [x y])))" "(run* [q]\\r\\n      (fresh [x]\\r\\n             (\=\= x 1)\\r\\n             (is q x nil)))" "(run* [q] (and-e-l '(and x y) q))" "rule" "(defn (\:name rule) \\"asd\\")" "(symbol \\"asd\\")" "(defn (symbol (\:name rule)) \\"asd\\")" "(defmacro postfix [expr]\\n  (conj (butlast expr) (last expr)))" "(postfix (1 1 +))" "`+" "`(and a b)" "(run* [q] (and-e-l '(and a b) q))" "`('and a b)" "(defn c\\n  [c code]\\n  `(println ~c ~code))" "(def c \\"asd\\")" "c" "(defn c\\r\\n     [c code]\\r\\n     `(println ~c ~code))" "(def a \\"asd\\")" "(c \\"asdasd\\" a)" "(eval (c \\"asdasd\\" a))" "(defn c\\r\\n        [c code]\\r\\n        `(println ~c (quote ~code)))" "(c \\"asdasd\\" a)" "(eval (c \\"asdasd\\" a))" "(def a '(+ a a))" "(c \\"asdasd\\" a)" "(eval (c \\"asdasd\\" a))" "(defn c\\r\\n           [c code]\\r\\n           `(println ~c ~code))" "(eval (c \\"asdasd\\" a))" "(applyrule rule)" "(quote (applyrule rule))" "(applyrule rule)" "(symbol \\"asd)" "(symbol \\"asd\\")" "(def f (applyrule rule))" "(applyrule rule)" "(\:operator rule)" "(applyrule rule)" " (applyrule rule)" "(def a [(\:operator rule)])" "a" " (applyrule rule)" "(app rule)" "(applyrule rule)" "a" "(applyrule rule)" "rule" "(applyrule rule)" "rule" "(applyrule rule)" "(code-critic {\:good \\"bla\\" \:bad \\"blub\\"})" "(applyrule rule)" "(applyrule {\:result \\"asd\\"})" "rule" "(applyrule rule)" "(app rule)" "(eval (app rule))" "(def a (app rule))" "(a 12)" "(applyrule rule)" "(a)" "a" "(a \\"asd\\")" "(app rule)" "(a 23)" "a" "(app rule)" "(a 23)" "a" "(applyrule 'a)" "(applyrule r)" "(applyrule a [b])" "(defmacro double-it                \\r\\n  [fname args & body]         \\r\\n  `(do (defn ~fname ~args ~@body)\\r\\n       (defn ~(symbol (str fname \\"*\\")) ~args ~@body)))\\r\\n\\r\\n(double-it afunc [str] (println str))" "(afunc \\"asd\\")" "(applyrule aaa \\"asd\\")" "(applyrule bla [s])" "(bla 1)" "(applyrule a [s])" "(app rule)" "(applyrule a [s])" "(applyrule a [and a])" "(app rule)" "(and-e-l 1)" "(and-e-l)" "(and-e-l 2 3)" "(app rule)" "(applyrule f [s])" "(f 1)" "(applyrule 's [r])" "(macroexpand (applyrule s [r]))" "(macroexpand '(applyrule s [s]))" "(source and)" "(use 'clojure.repl)" "(source and)" "(t {\:name 'hallo})" "hallo" "(t {\:name \\"asd\\"})" "asd" "(n 1)" "(t {\:name bla})" "(t {\:name \\"hallo\\"})" "(t {\:name 'hallo})" "(t {\:name \\"hallo\\"})" "(t {\:name 'hallo})" "(macroexpand '(t {\:name 'hallo}))" "(t {\:name \\"hallo\\"})" "(t {\:name 'hallo})" "(macroexpand '(t {\:name 'hallo}))" "(symbol? 'hallo)" "(defn g\\n  []\\n  (let [a \\"asd\\"]\\n    (+ 1 a)))" "(g)" "(def x 12)" "(add-watch x \:re-bind (fn [key r old new] (println old \\" -> \\" new)))" "x" "(add-watch\\n  (var x)\\n  \:re-bind\\n  (fn [key r old new]\\n    (println old \\" - \\" new)))" "(def x 13)" "(defmacro def-watched [name & value]\\n  `(do\\n     (def ~name ~@value)\\n     (add-watch (var ~name)\\n                \:re-bind\\n                (fn [~'key ~'r old\# new\#]\\n                  (println old\# \\" - \\" new\#)))))" "(macroexpand '(def-watched x 14))" "(def-watched y 12)" "(def y 13)" "(defmacro t\\n  [map]\\n  `(let [~'a (\:name ~map)]\\n     (defn ~'a [s] (+ 1 1))))" "(t {\:name 'bla})" "(macroexpand '(t {\:name 'bla}))" "(defmacro t\\r\\n     [map]\\r\\n     `(let [~'a (\:name ~map)]\\r\\n        (defn ~a [s] (+ 1 1))))" "(macroexpand '(t {\:name 'bla}))" "(t {\:name 'bla})" "(defmacro t\\r\\n        [map]\\r\\n        `(let [~'a (\:name ~map)]\\r\\n           (defn a [s] (+ 1 1))))" "(macroexpand '(t {\:name a}))" "(let [a 'b]\\n  (defn a [s] (+ 1 1)))" "(a 1)" "(defmacro g\\n  []\\n  `(println \\"test\: \\" (\:name {\:name \\"Hans\\"})))" "(g)" "(defmacro g\\r\\n     []\\r\\n     `(println \\"test\: \\" ~(\:name {\:name \\"Hans\\"})))" "(g)" "(def x 12)" "(def t 12)" "t" "(def map {\:var t})" "(\:var map)" "(defmacro g\\n  [map]\\n  `(println \\"bla\: \\" (\:var ~map)))" "(g)" "(g map)" "(defmacro g\\r\\n     [map]\\r\\n     `(println \\"bla\: \\" ~(\:var ~map)))" "(g map)" "(defmacro g\\r\\n     [map]\\r\\n     `(println \\"bla\: \\" ~(\:var map)))" "(g map)" "(defmacro with [binding]\\n  `(let ~binding\\n     (println ~(binding 0))))" "(with [a \\"hallo\\"])" "([a b c] 1)" "([1 2 3] 1)" "(defmacro with [binding]\\r\\n     `(let ~binding\\r\\n        (println (~binding 0))))" "(with [a \\"bla\\"])" "(defmacro with [binding]\\r\\n     `(let ~binding\\r\\n        (println (binding 0))))" "(with [a \\"asd\\"])" "(list* 1 [1 2 3])" "(defmacro anym\\n  [fname args body]\\n  `(defn ~fname ~args ~@body))" "(anym bla [a b] (+ a b))" "(bla 1 2)" "(macroexpand '(anym bla [a b] (+ a b)))" "(fn [a b] (+ a b))" "(def a (fn [a b] (+ a b)))" "(a 1 3)" "(def a (fn ([a b] + a b)))" "(a 1 3)" "(defmacro anym\\r\\n     [fname args body]\\r\\n     `(defn ~fname ~args ~body))" "(anym bla [a b] (+ a b))" "(bla 1 2)" "(macroexpand '(anym bla [a b] (+ a b)))" "(flatten [1 2 3])" "`(~'bla ~@(1 2 3))" "(make rule)" "(def a (make rule))" "a" "(def a (eval (make rule)))" "(eval (make rule))" "(make rule)" "(eval (make rule))" "(def a (eval (make rule)))" "(run* [q] (a '(and x y) q))" "(list \\"(1 2 3)\\")" "(make rule)" "(seq \\"`(and ~a ~b)\\")" "(eval (quote 1))" "(quote 1)" "(quote and)" "and" "(eval (quote and))" "(eval '(quote and))" "(quote `())" "(\= '(and a b) ('and a b))" "(\= '(and a b) ('and 'a 'b))" "`(and ~a ~b)" "(quote `(and ~a ~b))" "(quote (and ~a ~b))" "'(and '~a '~b)" "'(quote (and ~a ~b))" "(def a (fn [and a] (fresh [b] (\=\= and `(and ~a ~b)))))" "(run* [q] (a '(and x y) q))" "(run* [q] (and-e-l '(and x y) q))" "(run 1 [q] (and-e-l '(and x y) q))" "(run* [q] (and-e-l '(and x y) q))" "(run 1 [q] (and-e-l '(and x y) q))" "(run* [q] (ande1o '(a & b) q))" "(run* [q] (ande1o q '(a & b)))" "(run* [q] (and-e-l '(and x y) q))" "(def a (fn [and a] (fresh [b] (\=\= and `(~'and ~a ~b)))))" "(run* [q] (a '(and x y) q))" "(t)" "(def f1 12)" "'(and `~f1)" "`(and ~f1)" "`(~'and ~f1)" "(quote `(~'and ~f1))" "(eval (quote `(~'and ~f1)))" "(t)" "(run* [q] ((eval (t)) '(and x y) q))" "(eval (t))" "(quote `(~a))" "(t)" "(eval (t))" "(def a (eval (t)))" "(run* [q] (a '(and x y) q))" "(run* [q] (a q '(and x y)))" "(t)" "(def a (eval (t)))" "(run* [q] (a '(and x y) q))" "(run* [q] (a q '(and x y)))" "a" "(def a (eval (t)))" "(run* [q] (a q '(and x y)))" "(t)" "(def a (eval (t)))" "(run* [q] (a '(and x y) q))" "(t)" "(def a (eval (t)))" "(run* [q] (a '(and x y) q))" "(def a (eval (t)))" "(run* [q] (a '(and x y) q))" "(t)" "(run* [q]\\n      ((fn [and a] (fresh [b]\\n                          (\=\= and `(~'and ~a ~b)))) '(and x y) q))" "(run* [q] ((t) '(and y x) q))" "(t)" "(def a '(fn [q] (+ 1 q)))" "((a) 4)" "(a 4)" "((eval a) 4)" "(run* [q] ((eval (t)) '(and x y) q))" "(t)" "(run* [q] (t '(and y x) q))" "(run* [q] ((t) '(and x y) q))" "(let [x 19]\\n  `~x)" "(run* [q] ((t) '(and x y) q))" "((h) 12)" "((g) 10)" "(g)" "((h) 10)" "(run* [q] ((t) '(and x y) q))" "(run* [q] ((t) '(and) q))" "(run* [q] ((t) 'and q))" "(run* [q] ((t) '(and) q))" "'(and a)" "'(and)" "(run* [q] ((t) '(and) q))" "(run* [q] ((t) '(and x y) q))" "(run* [q] ((t) '(and a b) q))" "(let [a 12]\\n  '(and `~x))" "(let [x 12]\\n  '(and ~x))" "(let [x 12]\\n  '(and ~`(~x)))" "(let [x 12]\\n  '(and ~`~x))" "(unquote 12)" "(let [x 'b]\\n  '(and ~`~x))" "(run* [q] ((t) '(and x y) q))" "(let [x 'a]\\n  (fn [x] `(~'and ~x)))" "((let [x 'a]\\r\\n  (fn [x] `(~'and ~x))) \\"we\\")" "(run* [q] ((t) '(and x y) q))" "(run* [q] ((t) q '(and x y)))" "(run* [q] ((t) '(and a b) q))" "((let [x 'a]\\n   (fn [x] (+ 10 a))) 12)" "(run* [q] ((t) '(and x y) q))" "(run* [q] ((t) '(and a b) q))" "(let [a '[a]]\\n  (fn a (* 1 a)))" "(run* [q] ((t) '(and a b) q))" "(run* [q] ((eval (g)) '(and a b) q))" "(run* [q] ((eval (g)) '(and a) q))" "(run* [q] ((eval (g)) 'true q))" "(run* [q] ((eval (g)) '(and a) q))" "(g)" "(run* [q] ((eval (m)) '(and) q))" "(run* [q] ((eval (m)) '(and a) q))" "(run* [q] ((eval (m)) '(and a b) q))" "(run* [q] ((eval (m)) '(and x c) q))" "(run* [q] ((eval (m)) '(and hj hj) q))" "(conj [1] [1 2])" "(concat [1] [1 2])" "(concat 12 [1 2 ])" "(contains? [4 5 6] 6)" "(contains? (seq [4 5 6]) 6)" "(seq [4 5 6])" "(use 'clojure.set)" "(intersection (set [1 2]) (set [3 2]))" "(vec \#{1 2})" "(flatten [1 2 3])" "(run* [q] ((eval (make rule)) '(and a b) q))" "rule" "(make rule)" "(first (\:operator rule))" "(doall (concat (\:operator rule) (\:result rule)))" "(make rule)" "(vec (doall (concat (\:operator rule) (\:result rule))))" "(same (\:arguments rule) (\:result rule))" "(make rule)" "(same (\:arguments rule) (\:result rule))" "(make rule)" "(vec (doall (concat (\:operator rule) (\:result rule))))" "(into [] (concat (\:operator rule) (\:result rule)))" "(make rule)" "(run* [q] ((eval (make rule)) '(and a b) q))" "(run* [q] ((eval (make rule)) '(and x h) q))" "(run* [q] ((eval (make rule)) q '(and a b)))" "(let [a [1 2 3]]\\n  `(~'hallo ~@a))" "`(~'and `(~'and))" "`(~'and `(~'and 12 13))"]
eclipse.preferences.version=1
