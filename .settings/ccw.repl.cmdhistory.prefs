cmdhistory=["(step p \\"and-i\\" 1 2)" "(use 'clojure.repl)" "(source nth)" "(flatten {\:a 1})" "(nth '(1 2 3) 2)" "(assoc-in [1 [2 3]] [1 0] 44)" "(source assoc-in)" "(update-in [1 [2 3]] [1 2] 44)" "(assoc-in [1 [2 3]] [1 2] 44)" "(find {\:a 1 \:b {\:c 2 \:d 3}} \:d)" "(scope-for-line p 7)" "(scope-for-line p 2)" "(scope-for-line p 3)" "(scope-for-line p 7)" "(time (scope-for-line p 7))" "(scope-for-line1 p1 3)" "(scope-for-line1 p1 2)" "(scope-for-line1 p1 4)" "(nth (flatten p1) 3)" "(scope-for-elem p1 (nth (flatten p1) 4))" "(scope-for-elem p1 (nth (flatten p1) 2))" "(scope-for-elem p1 (nth (flatten p1) 1))" "(scope-for-elem p1 (nth (flatten p1) 4))" "(\:body [{\:body 1} {\:body 2}])" "(scope-for-line p1 5)" "(scope-for-line p1 3)" "(def sc (scope-for-line p1 3))" "(get-todo sc)" "(get-result sc)" "(source assoc-in)" "(use 'clojure.repl)" "(source assoc-in)" "(.indexOf \:a [\:a \:b \:c])" "(.indexOf [\:a \:b \:c] \:a)" "(.indexOf [\:a \:b \:c] \:d)" "(subvec [1 2] 0 0)" "(subvec [1 2] 0 1)" "(subvec [1 2] 2 3)" "(subvec [1 2] 2)" "(subvec [1 2] 1)" "(subvec [1 2 3 4 5] 2)" "(subvec [1 2 3 4 5] 0 2)" "(subvec [1 2 3 4 5] 2)" "(add-line p1 3 {\:test 12})" "(add-line p1 (nth (flatten p1) 2) {\:test 12})" "(add-line p1 (nth (flatten p1) 2) {\:test 12})+\#" "(add-line p1 (nth (flatten p1) 2) {\:test 12})" "(add-line p2 (nth (flatten p2) 4) {\:bla 12})" "(time (add-line p2 (nth (flatten p2) 4) {\:bla 12}))" "(add-line p2 (nth (flatten p2) 4) {\:bla 12})" "(time (add-line p2 (nth (flatten p2) 4) {\:bla 12}))" "(add-line p2 (nth (flatten p2) 4) {\:bla 12})" "(add-line p2 4 {\:bla 12})" "(change-line p2 4 {\:bla 12})" "(in-scope? p4 '(1 3 4))" "(last (sort (flatten '(1 3 4))))" "(scope/scope-for-line p4 4)" "(in-scope? p4 '( 1 3 4))" "(in-scope? p4 '(1 3 4))" "(in-scope? p4 '( 1 3 4))" "(in-scope? p4 '(1 3 4))" "(def a (set [{\:body (or a b), \:rule \:premise} {\:body a, \:rule \:assumption} {\:body \:todo, \:rule nil} {\:body X, \:rule nil}]))" "(def a (set '[{\:body (or a b), \:rule \:premise} {\:body a, \:rule \:assumption} {\:body \:todo, \:rule nil} {\:body X, \:rule nil}]))" "a" "(contains? a (nth (flatten p4) 2))" "(in-scope? p4 '( 1 3 4))" "(in-scope? p4 '(2 5))" "(in-scope? p4 '(1 5 8))" "(in-scope? p4  '(1 4 8))" "(get-item p4 [2 4])" "(get-item p5 [3 5])" "(get-item p5 9)" "(in-scope? p4 '( 1 2 8))" "(in-scope? p4 '([2 4] [5 7] 8))" "(in-scope? p5 '(2 [3 5] 9))" "(step p \\"and-i\\" 1 2)" "(step p \\"or-i1\\" 1)" "(step p \\"o-i1\\" 2)" "(step p \\"or-i1\\" 2)" "(new-id)" "(infer '[a b] '(and a b))" "(infer '(or a b))" "(log/apply-rule \\"or-e-backwards\\" X)" "(log/apply-rule \\"or-e-backwards\\" 'X)" "(infer 'a 'b)" "(defn t\\n  [[bla]]\\n  bla)" "(t \\"asd\\")" "(t [\\"as\\"])" "(t 'a)" "(vec 'a)" "(vector 'a)" "(vector '[a])" "(infer 'a 'b)" "(infer 'a)" "(check-args p \\"bla\\" '(1 2))" "(check-args p \\"and-i\\" '(1 2 3))" "(check-args p \\"and-i\\" '(1 2 3 1))" "(check-args p \\"and-i\\" '(1 2))" "(step1 p \\"and-i\\" 1 2)" " (step1 p \\"and-i\\" 1 2)" "(step1 (infer '[a b] '(and a b)) \\"and-i\\" 1 2)" "(step1 (infer '[a b] '(and a b)) \\"or-i1\\"  2)" "(step1 (infer '[a b] '(and a b)) \\"or-i2\\"  3)" "(between 2 5)" "(step1 (infer '[a b] '(and a b)) \\"or-i1\\"  3)" "(log/apply-rule \\"and-i\\" false '(and a b))" "(first 1)" "(scope-for-lines '(1 [2 7] [3 5]))" "(scope-for-lines \\"\\" '(1 [2 7] [3 5]))" "(scope-for-lines p2 '(1 [4 6] [7 9]))" "(scope-for-lines p2 '(2 3 4))" "(get-todo (scope-for-lines p2 '(2 3 4)))" "(get-result (scope-for-lines p2 '(2 3 4)))" "(check-args p4 \\"or-e\\" 1 (between 2 4) (between 5 7))" "(check-args p4 \\"or-e\\" '(1 [2 3 4] [5 6 7]))" " (check-args p4 \\"or-e\\" '(1 5))" "(step1 p3 \\"and-i\\" 3 5)" "(scope/scope-for-line p3 5)" "(scope/scope-for-line p3 3)" "(scope/scope-for-line p3 4)" "(scope/scope-for-line p3 2)" "(get-item-on-line p3 2)" "(scope/scope-for-elem p3 (get-item-on-line p3 2))" "(scope/scope-for-line p3 5)" "(get-item-on-line p3 5)" "(step1 p3 \\"and-i\\" 3 5)" "(check-args p3 \\"and-i\\" '(3 5))" "(check-args p3 \\"and-i\\" '(3 4))" "(step1 p3 \\"and-i\\" 2 3)" "(log/apply-rule \\"and-i\\" true '(not f) 'f)" "(check-args p3 \\"and-i\\" '(2 3))" "(step1 p3 \\"and-i\\" 2 3)" "(concat [\\"hallo\\"] '((not f) f))" "(step1 p \\"and-i\\" 1 2)" "(step1 p3 \\"and-i\\" 2 3)" "(scope/scope-for-line p3 5)" "(step-f p \\"and-i\\" 1 2)" "(step-f p4 \\"or-e\\" 1 [2 4] [5 7])" "(filter \#(\= (\:body %) \:todo) '[{\:id 1, \:body (or a b), \:rule \:premise} [{\:id 2, \:body a, \:rule \:assumption} {\:id 3, \:body \:todo, \:rule nil} {\:id 4, \:body X, \:rule nil}] [{\:id 5, \:body b, \:rule \:assumption} {\:id 6, \:body \:todo, \:rule nil} {\:id 7, \:body X, \:rule nil}] {\:id 8, \:body \:todo, \:rule or-e (1 (2-4) (5-7))}])" "(def a '[{\:id 1, \:body (or a b), \:rule \:premise} [{\:id 2, \:body a, \:rule \:assumption} {\:id 3, \:body \:todo, \:rule nil} {\:id 4, \:body X, \:rule nil}] [{\:id 5, \:body b, \:rule \:assumption} {\:id 6, \:body \:todo, \:rule nil} {\:id 7, \:body X, \:rule nil}] \\n         {\:id 8, \:body \:todo, \:rule \\"or-e (1 (2-4) (5-7))\\"}])" "a" "(filter \#(\= (\:body %) \:todo) a)" "(filter \#(and (nil? (\:rule %))\\r\\n                (not\= (\:body %) \:todo)) a)" "(step-f p4 \\"or-e\\" 1 [2 4] [5 7])" "@id" "(step-f p4 \\"or-e\\" 1 [2 4] [5 7])" "(infer '[a] b)" "(infer '[a] 'b)" "(arg-for-line p6 2)" "(arg-for-line p6 [2 5])" "(step-f p6 \\"exists-e\\" 1 [2 5])" "(log/apply-rule \\"exists-e\\" '(exists [x] (P x)) '(infer [(actual z) (substitution (P x) z x)] X))" "(log/apply-rule \\"exists-e\\" true '(exists [x] (P x)) '(infer [(actual z) (substitution (P x) z x)] X))" "(arg-for-line p6 1)" "(arg-for-line p6 [2 5])" "(step-f p6 \\"exists-e\\" 1 [2 5])" "(step-f p6 \\"and-i\\" 1 7)" "(if-let [a '()]\\n  true\\n  false)" "(pprint proof/p)" "(take 3 (cycle \\" \\"))" "(str (take 3 (cycle \\" \\")))" "(str [\\" \\" \\" \\" \\" \\"])" "(apply str (take 3 (cycle \\" \\")))" "(count \\"asdasdasdasd\\")" "(pprint proof/p)" "(count \\"...\\")" "(pprint proof/p)" "(pprint proof/p4)" "(str )" "(apply str [])" "(pprint proof/p4)" "(pprint proof/p5)" "(pprint proof/p4)" "(pprint (proof/step-f p4 \\"or-i1\\" 1 2))" "(pprint (proof/step-f proof/p4 \\"or-i1\\" 1 2))" "(pprint (proof/step-f proof/p4 \\"or-i1\\" 2))" "(pprint proof/p4)" "(pprint (proof/step-f proof/p4 \\"or-i1\\" 2))" "(proof/step-f proof/p4 \\"or-i1\\" 2)" "(pprint (proof/step-f proof/p \\"or-i1\\" 2))" "(str '(or b _0))" "(def a (iterate inc 1))" "(take 3 a)" "(str a)" "(def a (map inc [1 2 3]))" "a" "(str a)" "(str (doall a))" "(apply str a)" "(apply str \\"hallo\\")" "(pprint (proof/step-f proof/p4 \\"or-i1\\" 2))" "(pprint (proof/step-f proof/p \\"or-i1\\" 2))" "(pprint (proof/step-f proof/p4 \\"or-i1\\" 2))" "(pprint (proof/step-f proof/p \\"and-i\\" 1 2))" "(reverse [1 2 3])" "(reverse [1 2 [3 4] 5])" "(reverse-proof [1 2 [3 4] 5 6])" "(cons 1 [2 3 4])" "(reverse-proof [1 2 [3 4] 5])" "(conj [1 2] [3])" "(reverse-proof [1 2[ 3 4] 5])" "(check-args p \\"or-e\\" '(4) false)" "(check-args p4 \\"or-e\\" '(8) false)" "(check-args p5 \\"or-e\\" '(10) false)" "(check-args p6 \\"or-e\\" '(7) false)" "(.indexOf [1 2 3] 3)" "(subvec [1 2 3] 0 2)" "(subvec [1 2 3] 2)" "(step-b p \\"efq\\" 4)" "(\= (first '(infer a b)) 'infer)" "(def a '(infer a b))" "a" "(if (\= (first a) 'infer)\\n  (eval a)\\n  false)" "(log/apply-rule \\"or-e\\" false 'X)" "(eval (conj (map \#(quote %) (rest '(infer a b))) 'infer))" "(conj (map \#(quote %) (rest '(infer a b))) 'infer)" "(rest '(infer a b))" "(map \#(quote %) '(a b))" "'a" "(conj (map \#(list (quote %)) (rest '(infer a b))) 'infer)" "(conj (map \#(quote %) '(a b)) 'infer)" "(conj (rest '(infer a b)) 'infer)" "(map % '(a b))" "(conj (map \#(list `quote %) (rest '(infer a b))) 'infer)" "(eval (conj (map \#(list `quote %) (rest '(infer a b))) 'infer))" "(def a (scope/scope-for-line p 1))" "a" "(def b '({\:id 4, \:body (and a b), \:rule nil} \\n          {\:id 3, \:body \:todo, \:rule nil}))" "b" "(reduce \#(scope/change-item %1 %2\\n                            {\:id (\:id %2)\\n                             \:body (\:body %2)\\n                             \:rule \\"Test\\"}) p b)" "(step-b p \\"efq\\" 4)" "(step-b p \\"not-i\\" 4)" "(set '(1 2 3 4 1))" "(step-b p7 \\"exists-i\\" 3)" "(filter \#(\= 1 %) [2 3 4 1])" "(step-f p8 \\"test\\" 1)" "(step-b p8 \\"and-e1\\" 3)" "(defn a \\n  [s & [todo lines]]\\n  (println s)\\n  (println todo)\\n  (println lines))" "(a \\"asd\\" 1 2 3 4)" "(defn bla \\n  ([a & b] (bla a nil b))\\n  ([a z & b] \\n    (println a)\\n    (println z)\\n    (println b)))" "(defn bla\\n  ([a] (println a))\\n  ([a & b] (println a b)))" "(bla \\"asd\\")" "(bla 1 2 3 4 )" "(defn bla\\n  ([a & b] (println a))\\n  ([a z & b] (println a)))" "(def a (infer 'a 'b))" "a" "(step-f a \\"or-i1\\" 1)" "(infer 'a 'b)" "(infer '[(not a) a] 'b)" "(step-f p \\"and-i\\" 1 2)" "(step-f p \\"or-i1\\" 1)" "(def a (infer '[a b] '(and a b)))" "a" "(line-to-id a 3)" "(id-to-line a 2)" "(flatten a)" "(id-to-line a 2)" "(def b '[{\:id 3 \:body a \:rule \:premise}\\n         {\:id 1 \:body \:todo \:rule nil}\\n         {\:id 5 \:body b \:rule nil}])" "b" "(id-to-line b 5)" "(line-to-id b 2)" "a" "(get-itema 3)" "(get-item a 3)" "(id-to-line a 3)" "(get-item a 3)" "(get-item b 5)" "(first [])" "(some \#(contains? (set [1 2 3]) %) [4 5 6 3])" "(some \#(contains? (set [1 2 3]) %) [4 5 6 7])" "(check-args a \\"\\" '(1 2) true)" "a" "(def a (infer '[a b] '(and a b)))" "a" "(check-args a \\"\\" '(1 2) true)" "(check-args a \\"\\" '(1 4) true)" "(check-args a \\"\\" '(1 3) true)" "(check-args a \\"\\" '(1 2) true)" "(check-args a \\"\\" '(1 4) true)" "(check-args a \\"\\" '(1 3) true)" "(def b '[{\:id 1 \:body a \:rule \:premise}\\n         {\:id 2 \:body b \:rule \:premise}\\n         [{\:id 3 \:body c \:rule \:assumption}\\n          [{\:id 4 \:body (not a) \:rule \:assumption}{\:id 5 \:body \:todo \:rule nil}{\:id 6 \:body d \:rule nil}]\\n          [{\:id 7 \:body (not b) \:rule \:assumption}{\:id 8 \:body \:todo \:rule nil}{\:id 9 \:body e \:rule nil}]\\n          {\:id 10 \:body (or d e) \:rule \\"bla (4 6) (7 9)\\"}]\\n         {\:id 11 \:body (or d e) \:rule \\"test\\"}])" "b" "(check-args b \\"\\" '(2 3 4) true)" "(check-args b \\"\\" '(2 3 4 7) true)" "(check-args b \\"\\" '(2 3 4 10) true)" "(check-args b \\"\\" '(1 11) true)" "(check-args b \\"\\" '(2 3 9) true)" "(check-args b \\"\\" '(2 3 4) true)" "(def a (infer 'a 'b))" "a" "(step-f a \\"\\" true 1)" "(def b '[{\:id 1 \:body a \:rule \:premise}\\n         [{\:id 2 \:body b \:rule \:assumption}\\n          {\:id 3 \:body \:todo \:rule nil}\\n          {\:id 4 \:body e \:rule nil}]\\n         {\:id 6 \:body e \:rule nil}])" "b" "(step-f b \\"\\" true 1 (between 2 4))" "b" "(def b '[{\:id 1, \:body a, \:rule \:premise} \\n         [{\:id 2, \:body b, \:rule \:assumption} \\n          {\:id 4, \:body e, \:rule nil}]\\n         {\:id 3 \:body \:todo \:rule nil}\\n         {\:id 6, \:body e, \:rule nil}])" "b" "(step-f b \\"\\" true 1 (between 2 4))" "a" "(step-f a \\"or-i1\\" 1)" "(scope/get-open (scope/scope-for-line a 1))" "(def c '[{\:id 1 \:body a \:rule \:premise}\\n         {\:id 2 \:body \:todo \:rule nil}\\n         {\:id 4 \:body b \:rule nil}\\n         {\:id 7 \:body \:todo \:rule nil}\\n         {\:id 8 \:body c \:rule nil}\\n         {\:id 9 \:body (and b c) \:rule \\"and-i (4 8)\\"}])" "(step-f c \\"and-i\\" 1 2)" "(step-f c \\"and-i\\" 1 3)" "(step-f c \\"or-i1\\" 1)" "(step-f c \\"or-i1\\" 3)" "(step-f c \\"and-i\\" 1 3)" "a" "(def aa (infer '[a b] '(and a b)))" "aa" "(step-f aa \\"and-i\\" 1 2)" "(step-f aa \\"or-i1\\" 1)" "(def bb (infer '(and a b) 'b))" "bb" "(step-f bb \\"test\\" 1)" "(def cc (infer '(and a b) 'c))" "(step-f cc \\"test\\" 1)" "(sort '(a (and a b)))" "(use 'clojure.math.combinatorics)" "(permutations '(a b c))" "(permutations '(a (and a b)))" "(for [x (permutations '(a b))]\\n  (eval (list `run* [q] (conj x (make-rule \\"and-i\\")))))" "(for [x (permutations '(a b))]\\r\\n     (eval (list `run* ['q] (conj x (make-rule \\"and-i\\")))))" "(permutations '(a b))" "(for [x (permutations '(a b))]\\r\\n    x)" "(for [x (permutations '(a b))]\\n  (apply-rule \\"and-i\\" true x))" "(for [x (permutations '(a b))]\\r\\n  (apply apply-rule (concat [\\"and-i\\" true] x)))" "(first (for [x (permutations '(a b))]\\r\\n     (apply apply-rule (concat [\\"and-i\\" true] x))))" "(for [x (permutations '((or a b)\\n                         (infer a X)\\n                         (infer b X)))]\\r\\n     (apply apply-rule (concat [\\"or-e\\" true] x)))" "(apply-rule1 \\"and-i\\" true 'a 'b)" "(apply-rule1 \\"or-e\\" true '(or a b) '(infer a X) '(infer b X))" "(apply-rule1 \\"and-i\\" true 'a 'b)" "(apply-rule1 \\"test\\" true '(and a b))" "(apply-rule1 \\"or-e\\" true '(or a b) '(infer a X) '(infer b X))" "(apply-rule1 \\"and-i\\" true 'a 'b)" "(def a (infer '[a b] '(and a b)))" "a" "(step-f a \\"and-i\\" 1 2)" "(def a (infer '[a b] '(and a b)))" "(step-f a \\"and-i\\" 1 2)" "(def b '[{\:id 1 \:body (and a b) \:rule \:premise}\\n         {\:id 2 \:body \:todo \:rule nil}\\n         {\:id 3 \:body a \:rule nil}])" "(step-f b \\"test\\" 1)" "(log/apply-rule1 \\"test\\" true '(and a b))" "(def c '[{\:id 1 \:body a \:rule \:premise}\\n         {\:id 2 \:body b \:rule \:premise}\\n         {\:id 3 \:body \:todo \:rule nil}\\n         {\:id 4 \:body (not a) \:rule nil}\\n         {\:id 5 \:body (not b) \:rule nil}])" "(log/apply-rule1 \\"multi\\" true 'a 'b)" "(log/apply-rule1 \\"or-e\\" '(infer a x) '(or a g) '(infer g x))" "(log/apply-rule1 \\"or-e\\" true '(infer a x) '(or a g) '(infer g x))" "(log/apply-rule1 \\"multi\\" true 'x 'y)" "(merge {\:1 a} {\:a b})" "(merge {\:a 1} {\:b 2})" "(map-indexed \#(hash-map %1 %2) '[a b c])" "(merge (map-indexed \#(hash-map %1 %2) '[a b c]))" "(apply merge (map-indexed \#(hash-map %1 %2) '[a b c]))" "(def rr '([(not a) b] [(not b) a]))" "rr" "(apply merge (map-indexed \#(hash-map (keyword %1) %2) rr))" "(map-indexed \#(hash-map (keyword %1) %2) rr)" "(map \#(hash-map (keyword %1) %2) (iterate inc 1) rr)" "(keyword 1)" "(keyword (str 1))" "(map-indexed \#(hash-map  %1 %2) rr)" "(apply merge (map-indexed \#(hash-map (keyword %1) %2) rr))" "(apply merge (map-indexed \#(hash-map %1 %2) rr))" "(apply merge (map-indexed \#(hash-map %1 %2) '((and a b) (and ba))))" "a" "(def a (infer '[a b] '(and a b)))" "a" "(step-f a \\"and-i\\" 1 2)" "(def b (infer '(and a b) a))" "b" "a" "(def b (infer '(and a b) 'a))" "b" "(step-f b \\"and-e1\\" 1)" "(step-f b \\"and-e2\\" 1)" "(def c '[{\:id 1 \:body (and a b) \:rule \:premise}\\n         {\:id 1 \:body (and a b) \:rule \:premise}\\n         {\:id 1 \:body (and a b) \:rule \:premise}" "(def c '[{\:id 1 \:body (and a b) \:rule \:premise}\\r\\n         {\:id 2 \:body \:todo \:rule nil}\\r\\n         {\:id 3 \:body a \:rule nil}\\n         {\:id 4 \:body b \:rule nil}])" "c" "(step-f c \\"test\\" 1)" "(def c '[{\:id 1 \:body (and a b) \:rule \:premise}\\r\\n            {\:id 2 \:body \:todo \:rule nil}\\r\\n            {\:id 3 \:body a \:rule nil}])" "(step-f c \\"test\\" 1)" "(def d '[{\:id 1 \:body a \:rule \:premise}\\n         {\:id 2 \:body b \:rule \:premise}\\n         {\:id 3 \:body \:todo \:rule nil}\\n         {\:id 4 \:body (not a) \:rule nil}])" "(step-f d \\"multi\\" 1 2)" "c" "(def e '[{\:id 1, \:body (and a b), \:rule \:premise} \\n         {\:id 2, \:body \:todo, \:rule nil} \\n         {\:id 3, \:body e, \:rule nil}])" "(step-f e \\"test\\" 1 2)" "(step-f e \\"test\\" 1)" "(get {1 \:a 2 \:b} 3)" "(get \:a 1)" "(choose-option a 1 1)" "a" "(def aa (step-f a \\"and-i\\" 1 2))" "aa" "(choose-option aa 3 1)" "(choose-option aa 3 2)" "(log/apply-rule1 \\"or-e\\" false 'X)" "(log/apply-rule1 \\"multi\\" false '(not a) '(or a b))" "(log/apply-rule1 \\"test\\" false 'a 'b)" "(drop-while \#(not\= 1 %) [2 3 4 1 2 3])" "(map \#(item-to-rule-arg %) '({\:body bla} {\:body blub}))" "(item-to-rule-arg {\:body bla})" "(item-to-rule-arg '{\:body bla})" "(list (item-to-rule-arg '{\:body bla}))" "(map \:a [{\:a 1} {\:a 2}])" "(def a (infer '[a b] '(and a b)))" "(step-b a \\"and-i\\" 4)" "a" "(log/apply-rule1 \\"and-i\\" false '(and a b))" "(step-b a \\"and-i\\" 4)" "(create-item '(infer a b))" "(create-item '(and a b))" "a" "(step-b a \\"and-i\\" 4)" "(step-b a \\"or-e\\" 4)" "(step-b a \\"and-i\\" 4)" "(step-b a \\"or-e\\" 4)" "(step-b a \\"and-i\\" 4)" "(step-b a \\"or-e\\" 4)" "(step-b a \\"and-i\\" 4)" "(step-b a \\"or-e\\" 4)" "(step-b a \\"and-i\\" 4)" "(step-b a \\"or-e\\" 4)" "(def bb (infer '[a] '(impl a b)))" "bb" "(step-b bb \\"impl-i\\" 3)" "(def a (infer '[a] '(impl a b)))" "a" "(step-b a \\"impl-e\\" 1)" "(step-f a \\"or-i2\\" 1)" "(step-b a \\"impl-i\\" 1)" "(step-b a \\"impl-i\\" 3)" "(step-b a \\"impl-e\\" 1)" "(step-b a \\"impl-e\\" 3)" "(step-b a \\"impl-i\\" 3)" "a" "(step-b a \\"not-i\\" 3)" "(step-f (step-b a \\"not-i\\" 3) \\"not-e\\" 1 2)" "(step-b b \\"raa\\" 3)" "(step-f (step-b b \\"raa\\" 3) \\"not-e\\" 1 2)" "d" "(step-b d \\"raa\\" 2)" "e" "(step-b e \\"impl-i\\" 3)" "d" "e" "f" "h" "l" "(use 'deduction-playground.auto-logic)" "(apply-rule1 \\"not-e\\" false 'contradiction)" "(def tt '[[{\:id 1 \:body (not a) \:rule \:assumption}\\n           {\:id 2 \:body \:todo \:rule nil}\\n           {\:id 3 \:body contradiction \:rule nil}]\\n          {\:id 4 \:body a \:rule \\"bla (1 3)\\"}])" "tt" "(step-b tt \\"not-e\\" 3)" "e" "a" "(def a (infer '[a] '(impl a b)))" "(step-b a \\"impl-i\\" 3)" "(def b (infer '[c] '(and a b)))" "(step-b b \\"and-i\\" 3)" "b" "(log/apply-rule1 \\"and-i\\" false '(and a b))" "(step-b b \\"and-i\\" 3)" "(create-item 'a)" "(seq? '(1 2 3))" "(seq? [1 2 3])" "(step-b b \\"and-i\\" 3)" "(def c (infer '[a] 'contradiction))" "c" "(step-b c \\"not-e\\" 3)" "(proof '(infer a))" "a" "(proof '(infer g))" "(proof '(infer a))" "(proof '(infer [a b] (and a b)))" "(defn tt [a & [start?]]\\n  (println a start?))" "(tt \\"asd\\" true)" "(tt \\"asd\\")" "(tt \\"asd\\" \:mode)" "(proof '[a b] '(and a b))" "(proof '(and a b))" "(log/apply-rule1 \\"multi\\" true 'a 'b)" "(def a (proof '[a b] '(and a b)))" "a" "(step-f a \\"and-i\\" 1 2)" "(def aa (step-f a \\"and-i\\" 1 2))" "(choose-option aa 3 1)" "(choose-option aa 3 2)" "(def a (proof '[a b] '(and (not a) b)))" "a" "(step-b a \\"and-i\\" 4)" "(def a2 (step-b a \\"and-i\\" 4))" "a2" "(def a3 (step-f a2 \\"multi\\" 1 2))" "a3" "(choose-option a3 3 1)" "(choose-option a3 3 2)" "(def b (proof '[(and a b) (and a c)] '(and ab)))" "(def b2 (step-b b \\"and-i\\" 4))" "b" "(def b (proof '[(and a b) (and a c)] '(and a b)))" "(def b2 (step-b b \\"and-i\\" 4))" "b2" "(step-f b2 \\"test\\" 1)" "(def c (proof '[(and a b) (and a c)] '(and a b)))" "(def c2 (step-b c \\"and-i\\" 4))" "c2" "(step-f c2 \\"test\\" 1)" "(step-f c2 \\"test\\" 2)" "(step-f (step-f c2 \\"test\\" 2) \\"test\\" 1)" "\\n(id-to-line c2 5)" "c2" "(id-to-line c2 4)" "(id-to-line c2 [1 4])" "(id-to-line c2 [2 5])" "a" "(step-b a \\"not-i\\" 3)" "(deduction-playground.proof-new/create-item '(infer (not p) contradiction))" "(map deduction-playground.proof-new/create-item \\n     '((infer (not p) contradiction)))" "(def a (proof '(not a)))" "(step-b a \\"not-i\\" 2)" "(map create-item '((infer a contradiction)))" "(create-item '((infer a contradiction)))" "(create-item '(infer a contradiction))" "(def b (proof 'X))" "(step-b b \\"or-e\\" 2)" "(def a (proof 'X))" "(step-b a \\"or-e\\" 2)" "(create-item 'a)" "(create-item '(infer a))" "(step-b a \\"or-e\\" 2)" "(first '((or _0 _1) (infer _0 X) (infer _1 X)))" "(map create-item '((or _0 _1) (infer _0 X) (infer _1 X)))" "(step-b a \\"or-e\\" 2)" "(map create-item '((and a c) (and c b)))" "(step-b a \\"or-e\\" 2)" "(remove even? [1 2 3 4 5])" "(class (remove even? [1 2 3 4 5]))" "(class (first (remove even? [1 2 3 4 5])))" "(step-b a \\"or-e\\" 2)" "(defn step-b\\r\\n  [proof rule & lines]\\r\\n  (let [info (check-args proof rule lines false)\\r\\n        item (\:item info)\\r\\n        todos (\:todos info)\\r\\n        results (\:results info)\\r\\n        rule-args (item-to-rule-arg item)\\r\\n        rule-result (apply log/apply-rule1 (concat [rule false] (list rule-args)))]\\r\\n    (cond\\r\\n      (empty? rule-result)\\r\\n      (throw (Exception. \\"Incorrect parameters for the given rule\\"))\\r\\n      \\r\\n      \:else\\r\\n      (let [res (if (vector? (first rule-result)) (first rule-result) rule-result)\\r\\n            bresults (set (map \:body results))\\r\\n            match (filter \#(contains? bresults %) res)\\r\\n            match-ids (map \#(if (vector? %) [(\:id (first %)) (\:id (last %))] (\:id %)) (filter \#(contains? (set match) (\:body %)) results))\\r\\n            rest (remove \#(contains? bresults %) res)\\r\\n            rest-items (map create-item rest)\\r\\n            rest-ids (map \#(if (vector? %) [(\:id (first %)) (\:id (last %))] (\:id %)) rest-items)]\\r\\n        (cond-> (reduce \#(scope/add-before-item %1 item %2) proof rest-items)\\r\\n          (or (empty? rest)\\r\\n              (every? vector? rest-items)) (scope/remove-item (first todos))\\r\\n          true (scope/change-item item {\:id (\:id item)\\r\\n                                        \:body (\:body item)\\r\\n                                        \:rule (pr-str rule (concat match-ids rest-ids))}))))))" "(step-b a \\"or-e\\" 2)" "(def g (lazy-seq (iterate inc 1)))" "(first g)" "(class g)" "(coll? g)" "(coll? '(a b d))" "(coll? [1 2 3])" "(def a [1 2 [3 4] [5 6 7] 8])" "(scope-for-elem a 6)" "(scope-for-elem a 3)" "(scope-for-item a 5)" "(scope-for-item a 3)" "(scope-for-item a 5)" "(scope-for-item a 4)" "(def b '[{\:id 1 \:body \:todo \:rule nil}\\n         {\:id 2 \:body (or a b) \:rule nil}\\n         [{\:id 3 \:body a \:rule \:assumption}\\n          {\:id 4 \:body \:todo \:rule nil}\\n          {\:id 5 \:body X \:rule nil}]\\n         {\:id 6 \:body X \:rule \\"asd\\"}])" "(get-scope b 3)" "(get-scope b (get-item-on-line b 3))" "(get-scope b (get-item-on-line b 2))" "(get-item-on-line b 2)" "(get-scope b (get-item-on-line b 2))" "(scope-for-item b (get-item-on-line b 2))" "(get-scope b (get-item-on-line b 2))" "(get-scope b (get-item-on-line b 3))" "(get-scope b (get-item-on-line b 2))" "(get-scope b (get-item-on-line b 3))" "(first '())" "(remove-item b nil)" "(proof '[(and a b)] 'a)" "(def a (proof '[(and a b)] 'a))" "(step-f a \\"test\\" 1)" "(step-f a \\"and-e1\\" 1)" "(step-f a \\"and-e2\\" 1)" "(def b (proof '[a b] '(or a b)))" "(step-f b \\"multi\\" 1 2)" "(def c '[{\:id 1 \:body (and a b) \:rule \:premise}\\n         {\:id 5 \:body (and a c) \:rule \:premise}\\n         {\:id 2 \:body \:todo \:rule nil}\\n         {\:id 3 \:body a \:rule nil}\\n         {\:id 4 \:body b \:rule nil}])" "(step-f c \\"test\\" 1)" "(step-f c \\"test\\" 2)" "(def cc (step-f c \\"test\\" 2))" "(step-f cc \\"and-e2\\" 1)" "(step-f (step-f cc \\"and-e2\\" 1) \\"and-e1\\" 1)" "(def c (proof '[a b] '(and a b)))" "(step-b c \\"and-i\\" 4)" "(def a (proof '[a b] '(and a b)))" "(step-b a \\"and-i\\" 4)" "(step-b c \\"and-i\\" 4)" "(step-b a \\"and-i\\" 4)" "(def b (proof '[(or a b)] 'X))" "(step-b b \\"or-e\\" 3)" "a" "m" "(def a (proof '[a b] '(and a b)))" "(def aa (step-f a \\"and-i\\" 1 2))" "aa" "(choose-option aa 3 2)" "(choose-option aa 3 1)" "(def b (proof '[a b] '(or a b)))" "(def bb (step-f b \\"multi\\" 1 2))" "bb" "(choose-option bb 3 1)" "(choose-option bb 3 2)" "(def c '[{\:id 1 \:body (and a b) \:rule \:premise}\\n         {\:id 2 \:body \:todo \:rule nil}\\n         {\:id 3 \:body a \:rule nil}\\n         {\:id 4 \:body b \:rule nil}])" "(step-b c \\"test\\" 3 4)" "(step-f c \\"test\\" 1)" "(log/apply-rule1 \\"test\\" false 'a 'b)" "(step-b c \\"test\\" 3 4)" "(def a '[{\:id 1 \:body (and a b) \:rule \:premise}\\n         {\:id 2 \:body (impl a c) \:rule \:premise}\\n         {\:id 3 \:body \:todo \:rule \:nil}\\n         {\:id 4 \:body a \:rule nil}\\n         {\:id 5 \:body c \:rule nil}])" "(step-f a \\"test\\" 1)" "(step-f (step-f a \\"test\\" 1) \\"impl-e\\" 3 5)" "'(and _0 b)" "(replace {_0 'A} '(and _0 b))" "(replace '{_0 A} '(and _0 b))" "(filter \#(> 1 %)  {\:a 2 \:b 1})" "(str 'a)" "(.startsWith (str '_0) \\"_\\")" "(.startsWith (str 'a) \\"_\\")" "(init-vars '(and a _0))" "(new-var)" "(init-vars '(and _0 _1))" "(map inc \#{1 2 3})" "(init-vars '(and _0 _1))" "(\:_0 (init-vars '(and _0 _1)))" "(get (init-vars '(and _0 _1)) '_0)" "(init-vars '(and _0 _1))" "(flatten '((and a b) b (not c)))" "(flatten '(and a b))" "(init-vars '((and _0 _1) (infer _0 x) (infer _1 x)))" "(def a (proof 'X))" "(step-b a \\"or-e\\" 2)" "(def b (proof '[a b] '(and a b)))" "(step-f b \\"or-i1\\" 1)" "(step-b (proof 'X) \\"or-e\\" 2)" "(rename-var (step-b (proof 'X) \\"or-e\\" 2)\\n            'V1 'a)" "(step-b (proof 'X) \\"or-e\\" 2)" "(rename-var '{\:id 1 \:body (and V1 b) \:rule nil} 'V1 'a)" "(rename-var '[{\:id 1 \:body (and V1 b) \:rule nil}] 'V1 'a)" "(rename-var (step-b (proof 'X) \\"or-e\\" 2)\\r\\n               'V1 'a)" "(step-b (proof 'X) \\"or-e\\" 2)" "(rename-var '[{\:id 1, \:body \:todo, \:rule nil} {\:id 3, \:body (or V1 V2), \:rule nil} [{\:id 4, \:body V1, \:rule \:assumption} {\:id 5, \:body \:todo, \:rule nil} {\:id 6, \:body X, \:rule nil}] [{\:id 7, \:body V2, \:rule \:assumption} {\:id 8, \:body \:todo, \:rule nil} {\:id 9, \:body X, \:rule nil}] {\:id 2, \:body X, \:rule \\"\\\\\\"or-e\\\\\\" (3 [4 6] [7 9])\\"}]\\n            'V1 'a)" "(rename-var '[{\:id 1 \:body a \:rule \:premise}\\n              [{\:id 2 \:body b \:rule \:assumption}\\n               {\:id 3 \:body c \:rule \\"bla\\"}]\\n              {\:id 4 \:body c \:rule \\"blub 2 3\\"}]\\n            'b 'B)" "(replace '{b B} 'b)" "(replace '{b B} \:todo)" "(rename-var (step-b (proof 'X) \\"or-e\\" 2)\\r\\n               'V1 'a)" "(def j (proof '[(impl p q) (impl r s)]\\r\\n              '(impl (or p r) (or q s))))" "(-> (def j (proof '[(impl p q) (impl r s)]\\r\\n                 '(impl (or p r) (or q s))))\\n  (step-b \\"impl-i\\" 4))" "(-> (proof '[(impl p q) (impl r s)]\\r\\n                    '(impl (or p r) (or q s)))\\r\\n     (step-b \\"impl-i\\" 4))" "(-> (proof '[(impl p q) (impl r s)]\\r\\n                       '(impl (or p r) (or q s)))\\r\\n        (step-b \\"impl-i\\" 4)\\n        (step-b \\"or-e\\" 5))" "(-> (proof '[(impl p q) (impl r s)]\\r\\n                          '(impl (or p r) (or q s)))\\r\\n           (step-b \\"impl-i\\" 4)\\r\\n           (step-b \\"or-e\\" 5)\\n           (rename-var 'V1 'p)\\n           (rename-var 'V2 'r))" "(def a '[{\:id 1 \:body (and a b) \:rule \:premise}\\n         {\:id 2 \:body \:todo \:rule nil}\\n         {\:id 3 \:body a \:rule nil}\\n         {\:id 4 \:body b \:rule nil}])" "(step-b a \\"test\\" 3 4)" "(check-duplicates (rename-var (step-b (proof 'X) \\"or-e\\" 2)\\r\\n                  'V1 'a))" "(check-duplicates (rename-var (step-b (proof 'X) \\"or-e\\" 2)\\r\\n                     'V1 'a))" "(check-duplicates (rename-var (step-b (proof 'X) \\"or-e\\" 2)\\r\\n                        'V1 'a))" "a" "(def b '[{\:id 1 \:body a \:rule \:premise}\\n         {\:id 2 \:body (or a b) \:rule \\"or-i1 1\\"}\\n         {\:id 3 \:body \:todo \:rule nil}\\n         {\:id 4 \:body (or a b) \:rule nil}])" "(check-duplicates b)" "(filter \:rule [{\:rule \\"asd\\"} {\:rule nil}])" "(check-duplicates b)" "(def c (proof '[(or a b)] 'X))" "(-> c\\n  (step-b \\"or-e\\" 3)\\n  (rename-var 'V1 'a)\\n  (rename-var 'V2 'b)\\n  (check-duplicates))" "(use 'clojure.walk)" "(postwalk-demo '[1 2 [3 4] [5 6 7] 8])" "(postwalk inc [1 2 [3 4] [5 6 7] 8])" "(postwalk \\n  (fn [node]\\n    (if (vector? node)\\n      node\\n      (inc node))) [1 2 [3 4] [5 6 7] 8])" "(def a (proof '[(or a b)] 'X))" "(-> a\\n  (step-b \\"or-e\\" 3)\\n  (rename-var 'V1 'a)\\n  (rename-var 'V2 b))" "<type clojure code here>" "(def a (proof '[(or a b)] 'X))" "a" "(step-b a \\"or-e\\" 3)" "(def a (proof '[(or a b)] 'X))" "(-> a\\n  (step-b \\"or-e\\" 3)\\n  (rename-var 'V1 'a))" "(def a (proof '[(or a b)] 'X))" "(-> a\\n  (step-b \\"or-e\\" 3)\\n  (rename-var 'V1 'a)\\n  (rename-var 'V2 'b))" "(prewalk-demo [1 2 [3 4] [5 6 7] 8])" "(coll? 'a)" "(create-item 'a)" "(create-item '(infer a b))" "(coll? (lazy-seq 1 2))" "(set (filter \#(.startsWith (str %) \\"_\\") (flatten '(q))))" "(reduce \#(assoc %1 %2 (new-var)) {} \#{})" "(reduce \#(assoc %1 %2 1) {} \#{})" "(map \#(replace {} %) '(q))" "(set (filter \#(.startsWith (str %) \\"_\\") (flatten '(_0))))" "(deduction-playground.proof-new/init-vars '(q))" "(infer '[p] 'p)" "(rename (infer '[p] 'p) 'v 'p)" "(rename-var (infer '[p] 'p) 'v 'p)" "o" "(use 'clojure-walk)" "(use 'clojure.walk)" "(postwalk-demo [1 2 [3 4] [5 6 7] 8])" "(def a '[{\:id 1 \:body a \:rule \:assumption}\\n         {\:id 2 \:body b \:rule \:assumption}\\n         {\:id 3 \:body \:todo \:rule nil}\\n         {\:id 4 \:body a \:rule nil}\\n         {\:id 5 \:body b \:rule nil}])" "(remove-duplicates1 a)" "(use 'clojure.walk)" "(postwalk-demo [1 2 [3 4] [5 6 7] 8])" "a" "(remove-duplicates1 a)" "(nil? (\:rule '{\:id 3, \:body (not (or p (not p))), \:rule \:assumption}))" "(clojure.walk (fn [node]\\n                (if (vector? node)\\n                  nil\\n                  (inc node))) [1 2 [3 4] [5 6 7] 8])" "(clojure.walk/postwalk (fn [node]\\r\\n                   (if (vector? node)\\r\\n                     nil\\r\\n                     (inc node))) [1 2 [3 4] [5 6 7] 8])" "(clojure.walk/postwalk (fn [node]\\r\\n                      (if (vector? node)\\r\\n                        node\\r\\n                        (inc node))) [1 2 [3 4] [5 6 7] 8])" "(use 'clojure.walk)" "(postwalk-demo [1 2 [3 4] 5])" "(prewalk-demo [1 2 [3 4] 5])" "(clojure.string/replace \\"and-i (1 [3 1])\\" 1 2)" "(clojure.string/replace \\"and-i (1 [3 1])\\" \\"1\\" \\"2\\")" "(prewalk-demo [1 2 [3 4] 5])" "(postwalk-demo [1 2 [3 4] 5])" "(filter \#{1 2} [1 2 3 4 2 1])" "a" "(def a (proof '[a (or a V1)] '(or a b)))" "a" "(deduction-playground.proof-new/remove-duplicates1\\n  a)" "(def a (proof '[a (or a V1)] '(or a b)))" "a" "(remove-duplicates1 a)" "(remove-duplicates1 q)" "(remove-duplicates1 a)" "(rename-var a 'V1 'b)" "(def b '[{\:rule \:premise, \:id 1, \:body a} {\:id 2, \:body (or a b), \:rule \:premise} {\:id 3, \:body \:todo, \:rule nil} {\:id 4, \:body (or a b), \:rule nil}])" "b" "(remove-duplicates1 b)" "(def a '[[{\:id 1 \:body a \:rule \:assumption}\\n          {\:id 2 \:body (or a b) \:rule \\"or-1 1\\"}\\n          {\:id 3 \:body \:todo \:rule nil}\\n          {\:id 4 \:body (or a b) \:rule nil}]\\n         {\:id 5 \:body (or a b) \:rule \\"or-i [1 4]\\"}])" "a" "(remove-duplicates1 a)" "(meta (remove-duplicates1 a))" "(remove-duplicates1 a)" "(def t (with-meta \\"asd\\" {\:a 1}))" "(def t (with-meta 1 {\:a 1}))" "(def t (with-meta [1 2 3] {\:a 1}))" "(meta t)" "(remove-duplicates1 a)" "(merge {} nil)" "(remove-duplicates1 a)" "(meta (remove-duplicates1 a))" "(clojure.string/replace \\"1 2 3 4\\" \\"1|2\\" \\"3|4\\")" "(clojure.string/replace \\"1 2 3 4\\" \#\\"1|2\\" \#\\"3|4\\")" "(clojure.string/replace \\"1 2 3 4\\" \\"12\\" \\"34\\")" "(clojure.string/replace \\"1 2 3 4\\" \#\\"12\\" \\"34\\")" "(clojure.string/replace \\"1 2 3 4\\" \#\\"[12]\\" \\"34\\")" "(clojure.string/replace \\"1 2 3 4\\" \#\\"[12]\\" {\\"1\\" \\"3\\" \\"2\\" \\"4\\"})" "(map inc {1 2 3 4})" "(map (key %) {1 2 3 4})" "(map key {1 2 3 4})" "(clojure.string/replace nil \\"a\\" \\"b\\")" "(clojure.string/replace \\"a b a\\" {\\"a\\" \\"c\\"})" "(class \#\\"a|a\\")" "(java.util.regex.Pattern. \\"a|b\\")" "(new java.util.regex.Pattern \\"a|b\\")" "(java.util.regex.Pattern/compile \\"a|b\\")" "(remove-duplicates1 a)" "(meta (remove-duplicates1 a))" "(map \#(str (key %) \\"|\\") {4 2})" "(map \#(str (key %) \\"|\\") {4 2 3 1})" "(apply str (\\"4|\\" \\"3|\\"))" "(apply str '(\\"4|\\" \\"3|\\"))" "(drop-last (apply str '(\\"4|\\" \\"3|\\")))" "(clojure.string/join {4 2 5 1})" "(clojure.string/join (map key {4 2 3 1}) \\"|\\")" "(clojure.string/join (map key {4 2 5 1}))" "(clojure.string/join \\"|\\" (map key {4 2 5 1}))" "(remove-duplicates1 a)" "(correct-ids (remove-duplicates1 a))" "(let [regex (java.util.regex.Pattern/compile \\"a|b\\")\\n      map {\\"a\\" \\"1\\" \\"b\\" \\"2\\"}]\\n  (clojure.string/replace \\"a b a\\" regex map))" "(correct-ids (remove-duplicates1 a))" "(num \\"1\\")" "(Integer. \\"1\\")" "(correct-ids (remove-duplicates1 a))" "(correct-ids (with-meta\\n               '[[{\:id 1, \:body a, \:rule \:assumption} {\:id 2, \:body (or a b), \:rule \\"or-1 1\\"} {\:id 3, \:body \:todo, \:rule nil}] {\:id 5, \:body (or a b), \:rule \\"or-i [1 2]\\"}]\\n               {1 5}))" "(symbol? \:todo)" "(clojure.walk [{\:id 1 \:body 2} {\:id 3 \:body 4}])" "(clojure.walk/postwalk \\n  (fn [node] node)\\n  [{\:id 1 \:body 2} {\:id 3 \:body 4}])" "(clojure.walk/postwalk-demo\\r\\n     [{\:id 1 \:body 2} {\:id 3 \:body 4}])" "(def a '[[{\:id 1 \:body p \:rule \:assumption}\\n          {\:id 2 \:body \:todo \:rule nil}\\n          {\:id 3 \:body p \:rule nil}]\\n         {\:id 4 \:body p \:rule \\"bla [1 3]\\"}])" "(remove-duplicates1 a)" "(check-duplicates a)" "(def a '[[{\:id 1 \:body p \:rule \:assumption}\\n         {\:id 2 \:body \:todo \:rule nil}\\n         {\:id 3 \:body p \:rule nil}]\\n         {\:id 4 \:body p \:rule \\"bla [1 3]\\"}])" "a" "(remove-duplicates1 a)" "(check-duplicates a)" "(def a (proof '[a b] '(and a b)))" "(step-f a \\"and-i\\" 1 2)" "(replace {'a 'p} '{1 (and a b), 2 (and b a)})" "(list? '(and a b))" "(coll? {})" "(seq? {})" "a" "(rename-var a 'a 'c)" "(rename-var (step-f a \\"and-i\\" 1 2) 'a 'c)" "(def b '[[{\:id 1 \:body a \:rule \:assumption}\\n          {\:id 2 \:body \:todo  \:rule nil}\\n          {\:id 3 \:body a \:rule nil}]\\n         {\:id 4 \:body a \:rule \\"bla [1 3]\\"}])" "(remove-duplicates1 b)" "(correct-ids (remove-duplicates1 b))" "(clojure.walk/postwalk-demo [1 2 [3 4] [5 6 7] 8])" "(remove-dup  [1 2 [3 4] [5 6 7] 8])" "(remove-dup [1 2 [3 4] [5 6 7] 8])" "(meta (remove-dup [1 2 [3 4] [5 6 7] 8]))" "(frequencies [1 2 3 1])" "(frequencies [a b a])" "(frequencies '[a b a])" "(filter \#(> (val %) 1) (frequencies '[a b a]))" "(map first (filter \#(> (val %) 1) (frequencies '[a b a])))" "(map first (filter \#(> (val %) 1) (frequencies '[a b a a b c])))" "(set (map first (filter \#(> (val %) 1) (frequencies '[a b a]))))" "a" "(time (set (map first (filter \#(> (val %) 1) (frequencies (map \:body (remove vector? a)))))))" "(time (set (for [[body freq] (frequencies (map \:body (remove vector? a)))\\r\\n                              \:when (> freq 1)]\\r\\n                          body)))" "a" "b" "(remove-dup b)" "(remove-duplicates1 b)" "(remove-dup b)" "b" "(set (map first (filter \#(> (val %) 1) (frequencies (map \:body \\n                                                         (remove vector? '[{\:id 1, \:body a, \:rule \:assumption} {\:id 2, \:body \:todo, \:rule nil} {\:id 3, \:body a, \:rule nil}]))))))" "(remove-dup b)" "(def a '[[{\:id 1 \:body a \:rule \:assumption}\\n          {\:id 2 \:body \:todo \:rule nil}\\n          {\:id 3 \:body a \:rule nil}]\\n         {\:id 4 \:body a \:rule nil}])" "(remove-dup a)" "(clojure.walk/postwalk-demo '[{\:a 1} {\:a 2}])" "a" "(rename-var a 'a 'b)" "(rename-var (step-f a \\"and-i\\" 1 1) 'a 'b)" "(step-f a \\"and-i\\" 1 1)" "(rename-var '[[{\:id 1, \:body a, \:rule \:assumption} {\:id 2, \:body (and a a), \:rule \\"\\\\\\"and-i\\\\\\" (1 1)\\"} {\:id 2, \:body \:todo, \:rule nil} {\:id 3, \:body a, \:rule nil}] {\:id 4, \:body a, \:rule nil}]\\n            'a 'b)" "(def b (proof '[a b] '(and a b)))" "(step-f b \\"and-i\\" 1 2)" "(rename-var '[{\:rule \:premise, \:id 1, \:body a} {\:rule \:premise, \:id 2, \:body b} {\:id 5, \:body {1 (and a b), 2 (and b a)}, \:rule \\"\\\\\\"and-i\\\\\\" (1 2)\\"} {\:id 3, \:body \:todo, \:rule nil} {\:id 4, \:body (and a b), \:rule nil}]\\n            'a 'c)" "(rename-var '[{\:rule \:premise, \:id 1, \:body a} {\:rule \:premise, \:id 2, \:body b} {\:id 5, \:body {1 (and a b), 2 (and b a)}, \:rule \\"\\\\\\"and-i\\\\\\" (1 2)\\"} {\:id 3, \:body \:todo, \:rule nil} {\:id 4, \:body (and a b), \:rule nil}]\\r\\n               'a 'c)" "(remove-dup a)" "(remove-duplicates1 a)" "(time (remove-duplicates1 a))" "(check-duplicates a)" "a" "(def a (assoc (last a) \:rule \\"bla [1 3]\\"))" "a" "(def a '[[{\:id 1, \:body a, \:rule \:assumption} {\:id 2, \:body \:todo, \:rule nil} {\:id 3, \:body a, \:rule nil}] \\n         {\:id 4, \:body a, \:rule \\"bla [1 3]\\"}])" "a" "(check-duplicates a)" "(rename-var '[[{\:id 3, \:body (not (or p (not p))), \:rule \:assumption} [{\:id 9, \:body p, \:rule \:assumption} {\:id 12, \:body (or p V2), \:rule \\"\\\\\\"or-i1\\\\\\" (9)\\"} {\:id 10, \:body \:todo, \:rule nil} {\:id 11, \:body contradiction, \:rule nil}] {\:id 8, \:body (not p), \:rule \\"\\\\\\"not-i\\\\\\" ([9 11])\\"} {\:id 6, \:body (or p (not p)), \:rule \\"\\\\\\"or-i2\\\\\\" (8)\\"} {\:id 7, \:body (not V1), \:rule nil} {\:id 5, \:body contradiction, \:rule \\"\\\\\\"not-e\\\\\\" (6 7)\\"}] {\:id 2, \:body (or p (not p)), \:rule \\"\\\\\\"raa\\\\\\" ([3 5])\\"}]\\n            'V2 '(not p))" "(step-f '[[{\:id 3, \:body (not (or p (not p))), \:rule \:assumption} [{\:id 9, \:body p, \:rule \:assumption} {\:id 12, \:body (or p (not p)), \:rule \\"\\\\\\"or-i1\\\\\\" (9)\\"} {\:id 10, \:body \:todo, \:rule nil} {\:id 11, \:body contradiction, \:rule nil}] {\:id 8, \:body (not p), \:rule \\"\\\\\\"not-i\\\\\\" ([9 11])\\"} {\:id 6, \:body (or p (not p)), \:rule \\"\\\\\\"or-i2\\\\\\" (8)\\"} {\:id 7, \:body (not V1), \:rule nil} {\:id 5, \:body contradiction, \:rule \\"\\\\\\"not-e\\\\\\" (6 7)\\"}] {\:id 2, \:body (or p (not p)), \:rule \\"\\\\\\"raa\\\\\\" ([3 5])\\"}] \\"not-e\\" 1 3)" "(def a (proof '[a (or a V1)] '(or a b)))" "a" "(rename-var a 'V1 'b)" "(def b (proof '[a] '(or a b)))" "(rename-var (step-f a \\"or-i1\\" 1) 'V1 'b)" "b" "(reset\! var-id 0)" "(rename-var (step-f b \\"or-i1\\" 1) 'V1 'b)" "(step-f b \\"or-i1\\" 1)" "(rename-var '[{\:rule \:premise, \:id 1, \:body a} {\:id 6, \:body (or a V2), \:rule \\"\\\\\\"or-i1\\\\\\" (1)\\"} {\:id 2, \:body \:todo, \:rule nil} {\:id 3, \:body (or a b), \:rule nil}]\\r\\n'V2 'b)" "(reset\! var-id 0)" "(rename-var (step-f b \\"or-i1\\" 1) 'V1 'b)" "(rename-var (step-f b \\"or-i1\\" 1) 'V2 'b)" "(rename-var '[{\:rule \:premise, \:id 1, \:body a} {\:id 8, \:body (or a V2), \:rule \\"\\\\\\"or-i1\\\\\\" (1)\\"} {\:id 2, \:body \:todo, \:rule nil} {\:id 3, \:body (or a b), \:rule nil}](step-f b \\"or-i1\\" 1) 'V2 'b)" "(rename-var '[{\:rule \:premise, \:id 1, \:body a} {\:id 8, \:body (or a V2), \:rule \\"\\\\\\"or-i1\\\\\\" (1)\\"} {\:id 2, \:body \:todo, \:rule nil} {\:id 3, \:body (or a b), \:rule nil}]\\n             'V2 'b)" "(rename-var '[{\:rule \:premise, \:id 1, \:body a} {\:id 8, \:body (or a V2), \:rule \\"\\\\\\"or-i1\\\\\\" (1)\\"} {\:id 2, \:body \:todo, \:rule nil} {\:id 3, \:body (or a b), \:rule nil}]\\r\\n                'V2 'b)" "(reset\! var-id 0)" "(rename-var (step-f b \\"or-i1\\" 1) 'V1 'b)" "(use 'clojure.repl)" "(source clojure.walk/postwalk)" "(source clojure.walk/walk)" "b" "(reset\! var-id 0)" "(rename-var (step-f b \\"or-i1\\" 1) 'V1 'b)" "(rename-var (step-f b \\"or-i1\\" 1) 'V2 'b)" "(rename-var (step-f b \\"or-i1\\" 1) 'V3 'b)" "(rename-var (step-f b \\"or-i1\\" 1) 'V4 'b)" "(lazy-seq 1 2 3)" "(lazy-seq (list 1 2 3))" "(class (lazy-seq (list 1 2 3)))" "(class (list (lazy-seq (list 1 2 3))))" "(list (lazy-seq (list 1 2 3)))" "(doall (lazy-seq (list 1 2 3)))" "(class (doall (lazy-seq (list 1 2 3))))" "(into () (lazy-seq (list 1 2 3)))" "(apply list (lazy-seq (list 1 2 3)))" "(class (apply list (lazy-seq (list 1 2 3))))" "(def c '[{\:id 1 \:body a \:rule \:assupmtion}])" "(step-f c \\"or-i1\\" 1)" "(class (\:body (second (step-f c \\"or-i1\\" 1))))" "(class (\:body (first (step-f c \\"or-i1\\" 1))))" "(def c '[{\:id 1 \:body (and a b) \:rule \:assumption}])" "(step-f c \\"or-i1\\" 1)" "(class (\:body (first (step-f c \\"or-i1\\" 1))))" "(class (\:body (second (step-f c \\"or-i1\\" 1))))" "(class (\:body (first (step-f c \\"or-i1\\" 1))))" "(class (\:body (second (step-f c \\"or-i1\\" 1))))" "(\:body (second (step-f c \\"or-i1\\" 1)))" "a" "(reset\! var-id 0)" "b" "(rename-var (step-f b \\"or-i1\\" 1) 'V1 'b)" "(def a (proof '[(and a b)] '(or a b)))" "a" "(step-f a \\"and-e1\\" 1)" "(def b (proof '[a] '(or a b)))" "(step-f b \\"or-i1\\" 1)" "(step-f a \\"and-e1\\" 1)" "(empty? \#{})" "(def a '[{\:id 1 \:body (or a b) \:rule \:premise}\\n         [{\:id 2 \:body a \:rule \:assumption}\\n          {\:id 3 \:body (or a c) \:rule \\"or-i1 2\\"}\\n          {\:id 4 \:body \:todo \:rule nil}\\n          {\:id 5 \:bode (or a c) \:rule nil}]\\n         [{\:id 6 \:body b \:rule \:assumption}\\n          {\:id 7 \:body \:todo \:rule nil}\\n          {\:id 8 \:body (or a c) \:rule nil}]\\n         {\:id 9 \:body (or a c) \:rule \\"or-e 1 [2 5] [6 8]\\"}])" "(def b '[{\:id 1 \:body (not (or a b)) \:rule \:premise}\\n         [{\:id 2 \:body (not (and a b)) \:rule \:assumption}\\n          {\:id 3 \:body \:todo \:rule nil}\\n          {\:id 4 \:body (not (or a b)) \:rule nil}\\n          {\:id 5 \:body (or a b) \:rule nil}\\n          {\:id 6 \:body contradiction \:rule \\"not-e 4 5\\"}]\\n         {\:id 7 \:body (and a b) \:rule \\"raa [2 6]\\"}])" "(remove-dup a)" "(remove-dup b)" "(remove a)" "(remove-dup a)" "(def a '[{\:id 1 \:body (or a b) \:rule \:premise}\\r\\n            [{\:id 2 \:body a \:rule \:assumption}\\r\\n             {\:id 3 \:body (or a c) \:rule \\"or-i1 2\\"}\\r\\n             {\:id 4 \:body \:todo \:rule nil}\\r\\n             {\:id 5 \:bode (or a c) \:rule nil}]\\r\\n            [{\:id 6 \:body b \:rule \:assumption}\\r\\n             {\:id 7 \:body \:todo \:rule nil}\\r\\n             {\:id 8 \:body (or a c) \:rule nil}]\\r\\n            {\:id 9 \:body (or a c) \:rule \\"or-e 1 [2 5] [6 8]\\"}])" "(def b '[{\:id 1 \:body (not (or a b)) \:rule \:premise}\\r\\n            [{\:id 2 \:body (not (and a b)) \:rule \:assumption}\\r\\n             {\:id 3 \:body \:todo \:rule nil}\\r\\n             {\:id 4 \:body (not (or a b)) \:rule nil}\\r\\n             {\:id 5 \:body (or a b) \:rule nil}\\r\\n             {\:id 6 \:body contradiction \:rule \\"not-e 4 5\\"}]\\r\\n            {\:id 7 \:body (and a b) \:rule \\"raa [2 6]\\"}])" "(remove-dup a)" "(remove-dup b)" "(first [])" "a" "(remove-d a)" "(remove-d b)" "(remove-d a)" "a" "b" "(remove-d b)" "a\#" "a" "(def a '[{\:id 1, \:body (or a b), \:rule \:premise} \\n         [{\:id 2, \:body a, \:rule \:assumption}\\n          {\:id 3, \:body (or a c), \:rule \\"or-i1 2\\"} \\n          {\:id 4, \:body \:todo, \:rule nil} {\:id 5, \:body (or a c), \:rule nil}] [{\:id 6, \:body b, \:rule \:assumption} {\:id 7, \:body \:todo, \:rule nil} {\:id 8, \:body (or a c), \:rule nil}] {\:id 9, \:body (or a c), \:rule \\"or-e 1 [2 5] [6 8]\\"}])" "(remove-d a)" "(remove-d b)" "(remove-d a)" "(remove-d b)" "(def c '[{\:id 1 \:body a \:rule \:premise}\\n         {\:id 2 \:body \:todo \:rule nil}\\n         {\:id 3 \:body (or a b) \:rule nil}\\n         [{\:id 4 \:body a \:rule \:assumption}\\n          {\:id 5 \:body (or a b) \:rule \\"or-i1 4\\"}\\n          {\:id 6 \:body \:todo \:rule nil}\\n          {\:id 7 \:body X \:rule nil}]\\n         [{\:id 8 \:body b \:rule \:assumption}\\n          {\:id 9 \:body \:todo \:rule nil}\\n          {\:id 10 \:body X \:rule nil}]\\n         {\:id 11 \:body X \:rule \\"or-e 3 [4 7] [8 10]\\"}])" "(remove-d c)" "(dissoc \#{1 2 3} 1)" "(disj \#{1 2 3} 1)" "(disj \#{1 2 3} 4)" "(remove-d c)" "a" "(remove-d a)" "(remove-d b)" "(meta (remove-d a))" "(remove-d a)" "(remove a)" "(remove-d a)" "(merge nil {})" "(def t [1 [2 3] 4])" "(def p\\n  [t] \\n  (let [t2 (if (contains? (set t) 2)\\n             (with-meta t {\:found true})\\n             t)]\\n    (reduce \#(if (vector? %) (p %)) t)))" "(defn p\\r\\n     [t] \\r\\n     (let [t2 (if (contains? (set t) 2)\\r\\n                (with-meta t {\:found true})\\r\\n                t)]\\r\\n       (reduce \#(if (vector? %) (p %)) t)))" "(p t)" "t" "(p t)" "(remove-d a)" "(meta (remove-d a))" "(remove-d a)" "(remove-d c)" "(remove-d b)" "(remove-d a)" "(remove-d (with-meta a {\:a 1}))" "(meta (with-meta a {\:a 1}))" "(def a (with-meta a {\:a 1}))" "a" "(meta a)" "(remove-d a)" "(remove-d b)" "(remove-d c)" "(def a (with-meta a {}))" "a" "(met a)" "(meta a)" "(meta b)" "(def a (with-meta a nil))" "(remove-d a)" "a" "(remove-d b)" "b" "(remove-d b)" "(merge nil {4 1})" "(def t (with-meta [1 2 3] {\:a 1}))" "(reduce conj t [4 5 6])" "(meta (reduce conj t [4 5 6]))" "(remove-d a)" "(meta (remove-d a))" "(meta (remove-d b))" "(meta (remove-d c))" "(remove-d c)" "(meta (remove-d b))" "(meta b)" "(remove-d b)" "t" "(meta t)" "(let [a (map inc t)\\n      b (meta t)]\\n  b)" "(remove-d b)" "(meta (remove-d b))" "(check-duplicates a)" "(check-duplicates b)" "(check-duplicates c)" "(check-duplicates a)" "(deduction-playground.proof-new/init-vars \\n  '[(infer (actual _0) (substitution (P x) _0 x))])" "(set (filter \#(.startsWith (str %) \\"_\\") (flatten \\n                                          '[(infer (actual _0) (substitution (P x) _0 x))])))" "(reduce \#(assoc %1 %2 (new-var)) {} \#{_0})" "(reduce \#(assoc %1 %2 (deduction-playground.proof-new/new-var)) {} \#{_0})" "(reduce \#(assoc %1 %2 (deduction-playground.proof-new/new-var)) {} \#{'_0})" "(replace '{_0 V1} '(infer (actual _0) (substitution (P x) _0 x)))" "(def g '[{\:id 1 \:body (and (or a b) b) \:rule \:premise}])" "(rename-var g 'b 'Y)" "(replace '{a b} '(and (or a b) a))" "(clojure.walk/prewalk-replace '{a b} \\n                              '(and (or a b) a))" "g" "(rename-var g 'b 'Y)"]
eclipse.preferences.version=1
