cmdhistory=["(merge (map-indexed \#(hash-map %1 %2) '[a b c]))" "(apply merge (map-indexed \#(hash-map %1 %2) '[a b c]))" "(def rr '([(not a) b] [(not b) a]))" "rr" "(apply merge (map-indexed \#(hash-map (keyword %1) %2) rr))" "(map-indexed \#(hash-map (keyword %1) %2) rr)" "(map \#(hash-map (keyword %1) %2) (iterate inc 1) rr)" "(keyword 1)" "(keyword (str 1))" "(map-indexed \#(hash-map  %1 %2) rr)" "(apply merge (map-indexed \#(hash-map (keyword %1) %2) rr))" "(apply merge (map-indexed \#(hash-map %1 %2) rr))" "(apply merge (map-indexed \#(hash-map %1 %2) '((and a b) (and ba))))" "a" "(def a (infer '[a b] '(and a b)))" "a" "(step-f a \\"and-i\\" 1 2)" "(def b (infer '(and a b) a))" "b" "a" "(def b (infer '(and a b) 'a))" "b" "(step-f b \\"and-e1\\" 1)" "(step-f b \\"and-e2\\" 1)" "(def c '[{\:id 1 \:body (and a b) \:rule \:premise}\\n         {\:id 1 \:body (and a b) \:rule \:premise}\\n         {\:id 1 \:body (and a b) \:rule \:premise}" "(def c '[{\:id 1 \:body (and a b) \:rule \:premise}\\r\\n         {\:id 2 \:body \:todo \:rule nil}\\r\\n         {\:id 3 \:body a \:rule nil}\\n         {\:id 4 \:body b \:rule nil}])" "c" "(step-f c \\"test\\" 1)" "(def c '[{\:id 1 \:body (and a b) \:rule \:premise}\\r\\n            {\:id 2 \:body \:todo \:rule nil}\\r\\n            {\:id 3 \:body a \:rule nil}])" "(step-f c \\"test\\" 1)" "(def d '[{\:id 1 \:body a \:rule \:premise}\\n         {\:id 2 \:body b \:rule \:premise}\\n         {\:id 3 \:body \:todo \:rule nil}\\n         {\:id 4 \:body (not a) \:rule nil}])" "(step-f d \\"multi\\" 1 2)" "c" "(def e '[{\:id 1, \:body (and a b), \:rule \:premise} \\n         {\:id 2, \:body \:todo, \:rule nil} \\n         {\:id 3, \:body e, \:rule nil}])" "(step-f e \\"test\\" 1 2)" "(step-f e \\"test\\" 1)" "(get {1 \:a 2 \:b} 3)" "(get \:a 1)" "(choose-option a 1 1)" "a" "(def aa (step-f a \\"and-i\\" 1 2))" "aa" "(choose-option aa 3 1)" "(choose-option aa 3 2)" "(log/apply-rule1 \\"or-e\\" false 'X)" "(log/apply-rule1 \\"multi\\" false '(not a) '(or a b))" "(log/apply-rule1 \\"test\\" false 'a 'b)" "(drop-while \#(not\= 1 %) [2 3 4 1 2 3])" "(map \#(item-to-rule-arg %) '({\:body bla} {\:body blub}))" "(item-to-rule-arg {\:body bla})" "(item-to-rule-arg '{\:body bla})" "(list (item-to-rule-arg '{\:body bla}))" "(map \:a [{\:a 1} {\:a 2}])" "(def a (infer '[a b] '(and a b)))" "(step-b a \\"and-i\\" 4)" "a" "(log/apply-rule1 \\"and-i\\" false '(and a b))" "(step-b a \\"and-i\\" 4)" "(create-item '(infer a b))" "(create-item '(and a b))" "a" "(step-b a \\"and-i\\" 4)" "(step-b a \\"or-e\\" 4)" "(step-b a \\"and-i\\" 4)" "(step-b a \\"or-e\\" 4)" "(step-b a \\"and-i\\" 4)" "(step-b a \\"or-e\\" 4)" "(step-b a \\"and-i\\" 4)" "(step-b a \\"or-e\\" 4)" "(step-b a \\"and-i\\" 4)" "(step-b a \\"or-e\\" 4)" "(def bb (infer '[a] '(impl a b)))" "bb" "(step-b bb \\"impl-i\\" 3)" "(def a (infer '[a] '(impl a b)))" "a" "(step-b a \\"impl-e\\" 1)" "(step-f a \\"or-i2\\" 1)" "(step-b a \\"impl-i\\" 1)" "(step-b a \\"impl-i\\" 3)" "(step-b a \\"impl-e\\" 1)" "(step-b a \\"impl-e\\" 3)" "(step-b a \\"impl-i\\" 3)" "a" "(step-b a \\"not-i\\" 3)" "(step-f (step-b a \\"not-i\\" 3) \\"not-e\\" 1 2)" "(step-b b \\"raa\\" 3)" "(step-f (step-b b \\"raa\\" 3) \\"not-e\\" 1 2)" "d" "(step-b d \\"raa\\" 2)" "e" "(step-b e \\"impl-i\\" 3)" "d" "e" "f" "h" "l" "(use 'deduction-playground.auto-logic)" "(apply-rule1 \\"not-e\\" false 'contradiction)" "(def tt '[[{\:id 1 \:body (not a) \:rule \:assumption}\\n           {\:id 2 \:body \:todo \:rule nil}\\n           {\:id 3 \:body contradiction \:rule nil}]\\n          {\:id 4 \:body a \:rule \\"bla (1 3)\\"}])" "tt" "(step-b tt \\"not-e\\" 3)" "e" "a" "(def a (infer '[a] '(impl a b)))" "(step-b a \\"impl-i\\" 3)" "(def b (infer '[c] '(and a b)))" "(step-b b \\"and-i\\" 3)" "b" "(log/apply-rule1 \\"and-i\\" false '(and a b))" "(step-b b \\"and-i\\" 3)" "(create-item 'a)" "(seq? '(1 2 3))" "(seq? [1 2 3])" "(step-b b \\"and-i\\" 3)" "(def c (infer '[a] 'contradiction))" "c" "(step-b c \\"not-e\\" 3)" "(proof '(infer a))" "a" "(proof '(infer g))" "(proof '(infer a))" "(proof '(infer [a b] (and a b)))" "(defn tt [a & [start?]]\\n  (println a start?))" "(tt \\"asd\\" true)" "(tt \\"asd\\")" "(tt \\"asd\\" \:mode)" "(proof '[a b] '(and a b))" "(proof '(and a b))" "(log/apply-rule1 \\"multi\\" true 'a 'b)" "(def a (proof '[a b] '(and a b)))" "a" "(step-f a \\"and-i\\" 1 2)" "(def aa (step-f a \\"and-i\\" 1 2))" "(choose-option aa 3 1)" "(choose-option aa 3 2)" "(def a (proof '[a b] '(and (not a) b)))" "a" "(step-b a \\"and-i\\" 4)" "(def a2 (step-b a \\"and-i\\" 4))" "a2" "(def a3 (step-f a2 \\"multi\\" 1 2))" "a3" "(choose-option a3 3 1)" "(choose-option a3 3 2)" "(def b (proof '[(and a b) (and a c)] '(and ab)))" "(def b2 (step-b b \\"and-i\\" 4))" "b" "(def b (proof '[(and a b) (and a c)] '(and a b)))" "(def b2 (step-b b \\"and-i\\" 4))" "b2" "(step-f b2 \\"test\\" 1)" "(def c (proof '[(and a b) (and a c)] '(and a b)))" "(def c2 (step-b c \\"and-i\\" 4))" "c2" "(step-f c2 \\"test\\" 1)" "(step-f c2 \\"test\\" 2)" "(step-f (step-f c2 \\"test\\" 2) \\"test\\" 1)" "\\n(id-to-line c2 5)" "c2" "(id-to-line c2 4)" "(id-to-line c2 [1 4])" "(id-to-line c2 [2 5])" "a" "(step-b a \\"not-i\\" 3)" "(deduction-playground.proof-new/create-item '(infer (not p) contradiction))" "(map deduction-playground.proof-new/create-item \\n     '((infer (not p) contradiction)))" "(def a (proof '(not a)))" "(step-b a \\"not-i\\" 2)" "(map create-item '((infer a contradiction)))" "(create-item '((infer a contradiction)))" "(create-item '(infer a contradiction))" "(def b (proof 'X))" "(step-b b \\"or-e\\" 2)" "(def a (proof 'X))" "(step-b a \\"or-e\\" 2)" "(create-item 'a)" "(create-item '(infer a))" "(step-b a \\"or-e\\" 2)" "(first '((or _0 _1) (infer _0 X) (infer _1 X)))" "(map create-item '((or _0 _1) (infer _0 X) (infer _1 X)))" "(step-b a \\"or-e\\" 2)" "(map create-item '((and a c) (and c b)))" "(step-b a \\"or-e\\" 2)" "(remove even? [1 2 3 4 5])" "(class (remove even? [1 2 3 4 5]))" "(class (first (remove even? [1 2 3 4 5])))" "(step-b a \\"or-e\\" 2)" "(defn step-b\\r\\n  [proof rule & lines]\\r\\n  (let [info (check-args proof rule lines false)\\r\\n        item (\:item info)\\r\\n        todos (\:todos info)\\r\\n        results (\:results info)\\r\\n        rule-args (item-to-rule-arg item)\\r\\n        rule-result (apply log/apply-rule1 (concat [rule false] (list rule-args)))]\\r\\n    (cond\\r\\n      (empty? rule-result)\\r\\n      (throw (Exception. \\"Incorrect parameters for the given rule\\"))\\r\\n      \\r\\n      \:else\\r\\n      (let [res (if (vector? (first rule-result)) (first rule-result) rule-result)\\r\\n            bresults (set (map \:body results))\\r\\n            match (filter \#(contains? bresults %) res)\\r\\n            match-ids (map \#(if (vector? %) [(\:id (first %)) (\:id (last %))] (\:id %)) (filter \#(contains? (set match) (\:body %)) results))\\r\\n            rest (remove \#(contains? bresults %) res)\\r\\n            rest-items (map create-item rest)\\r\\n            rest-ids (map \#(if (vector? %) [(\:id (first %)) (\:id (last %))] (\:id %)) rest-items)]\\r\\n        (cond-> (reduce \#(scope/add-before-item %1 item %2) proof rest-items)\\r\\n          (or (empty? rest)\\r\\n              (every? vector? rest-items)) (scope/remove-item (first todos))\\r\\n          true (scope/change-item item {\:id (\:id item)\\r\\n                                        \:body (\:body item)\\r\\n                                        \:rule (pr-str rule (concat match-ids rest-ids))}))))))" "(step-b a \\"or-e\\" 2)" "(def g (lazy-seq (iterate inc 1)))" "(first g)" "(class g)" "(coll? g)" "(coll? '(a b d))" "(coll? [1 2 3])" "(def a [1 2 [3 4] [5 6 7] 8])" "(scope-for-elem a 6)" "(scope-for-elem a 3)" "(scope-for-item a 5)" "(scope-for-item a 3)" "(scope-for-item a 5)" "(scope-for-item a 4)" "(def b '[{\:id 1 \:body \:todo \:rule nil}\\n         {\:id 2 \:body (or a b) \:rule nil}\\n         [{\:id 3 \:body a \:rule \:assumption}\\n          {\:id 4 \:body \:todo \:rule nil}\\n          {\:id 5 \:body X \:rule nil}]\\n         {\:id 6 \:body X \:rule \\"asd\\"}])" "(get-scope b 3)" "(get-scope b (get-item-on-line b 3))" "(get-scope b (get-item-on-line b 2))" "(get-item-on-line b 2)" "(get-scope b (get-item-on-line b 2))" "(scope-for-item b (get-item-on-line b 2))" "(get-scope b (get-item-on-line b 2))" "(get-scope b (get-item-on-line b 3))" "(get-scope b (get-item-on-line b 2))" "(get-scope b (get-item-on-line b 3))" "(first '())" "(remove-item b nil)" "(proof '[(and a b)] 'a)" "(def a (proof '[(and a b)] 'a))" "(step-f a \\"test\\" 1)" "(step-f a \\"and-e1\\" 1)" "(step-f a \\"and-e2\\" 1)" "(def b (proof '[a b] '(or a b)))" "(step-f b \\"multi\\" 1 2)" "(def c '[{\:id 1 \:body (and a b) \:rule \:premise}\\n         {\:id 5 \:body (and a c) \:rule \:premise}\\n         {\:id 2 \:body \:todo \:rule nil}\\n         {\:id 3 \:body a \:rule nil}\\n         {\:id 4 \:body b \:rule nil}])" "(step-f c \\"test\\" 1)" "(step-f c \\"test\\" 2)" "(def cc (step-f c \\"test\\" 2))" "(step-f cc \\"and-e2\\" 1)" "(step-f (step-f cc \\"and-e2\\" 1) \\"and-e1\\" 1)" "(def c (proof '[a b] '(and a b)))" "(step-b c \\"and-i\\" 4)" "(def a (proof '[a b] '(and a b)))" "(step-b a \\"and-i\\" 4)" "(step-b c \\"and-i\\" 4)" "(step-b a \\"and-i\\" 4)" "(def b (proof '[(or a b)] 'X))" "(step-b b \\"or-e\\" 3)" "a" "m" "(def a (proof '[a b] '(and a b)))" "(def aa (step-f a \\"and-i\\" 1 2))" "aa" "(choose-option aa 3 2)" "(choose-option aa 3 1)" "(def b (proof '[a b] '(or a b)))" "(def bb (step-f b \\"multi\\" 1 2))" "bb" "(choose-option bb 3 1)" "(choose-option bb 3 2)" "(def c '[{\:id 1 \:body (and a b) \:rule \:premise}\\n         {\:id 2 \:body \:todo \:rule nil}\\n         {\:id 3 \:body a \:rule nil}\\n         {\:id 4 \:body b \:rule nil}])" "(step-b c \\"test\\" 3 4)" "(step-f c \\"test\\" 1)" "(log/apply-rule1 \\"test\\" false 'a 'b)" "(step-b c \\"test\\" 3 4)" "(def a '[{\:id 1 \:body (and a b) \:rule \:premise}\\n         {\:id 2 \:body (impl a c) \:rule \:premise}\\n         {\:id 3 \:body \:todo \:rule \:nil}\\n         {\:id 4 \:body a \:rule nil}\\n         {\:id 5 \:body c \:rule nil}])" "(step-f a \\"test\\" 1)" "(step-f (step-f a \\"test\\" 1) \\"impl-e\\" 3 5)" "'(and _0 b)" "(replace {_0 'A} '(and _0 b))" "(replace '{_0 A} '(and _0 b))" "(filter \#(> 1 %)  {\:a 2 \:b 1})" "(str 'a)" "(.startsWith (str '_0) \\"_\\")" "(.startsWith (str 'a) \\"_\\")" "(init-vars '(and a _0))" "(new-var)" "(init-vars '(and _0 _1))" "(map inc \#{1 2 3})" "(init-vars '(and _0 _1))" "(\:_0 (init-vars '(and _0 _1)))" "(get (init-vars '(and _0 _1)) '_0)" "(init-vars '(and _0 _1))" "(flatten '((and a b) b (not c)))" "(flatten '(and a b))" "(init-vars '((and _0 _1) (infer _0 x) (infer _1 x)))" "(def a (proof 'X))" "(step-b a \\"or-e\\" 2)" "(def b (proof '[a b] '(and a b)))" "(step-f b \\"or-i1\\" 1)" "(step-b (proof 'X) \\"or-e\\" 2)" "(rename-var (step-b (proof 'X) \\"or-e\\" 2)\\n            'V1 'a)" "(step-b (proof 'X) \\"or-e\\" 2)" "(rename-var '{\:id 1 \:body (and V1 b) \:rule nil} 'V1 'a)" "(rename-var '[{\:id 1 \:body (and V1 b) \:rule nil}] 'V1 'a)" "(rename-var (step-b (proof 'X) \\"or-e\\" 2)\\r\\n               'V1 'a)" "(step-b (proof 'X) \\"or-e\\" 2)" "(rename-var '[{\:id 1, \:body \:todo, \:rule nil} {\:id 3, \:body (or V1 V2), \:rule nil} [{\:id 4, \:body V1, \:rule \:assumption} {\:id 5, \:body \:todo, \:rule nil} {\:id 6, \:body X, \:rule nil}] [{\:id 7, \:body V2, \:rule \:assumption} {\:id 8, \:body \:todo, \:rule nil} {\:id 9, \:body X, \:rule nil}] {\:id 2, \:body X, \:rule \\"\\\\\\"or-e\\\\\\" (3 [4 6] [7 9])\\"}]\\n            'V1 'a)" "(rename-var '[{\:id 1 \:body a \:rule \:premise}\\n              [{\:id 2 \:body b \:rule \:assumption}\\n               {\:id 3 \:body c \:rule \\"bla\\"}]\\n              {\:id 4 \:body c \:rule \\"blub 2 3\\"}]\\n            'b 'B)" "(replace '{b B} 'b)" "(replace '{b B} \:todo)" "(rename-var (step-b (proof 'X) \\"or-e\\" 2)\\r\\n               'V1 'a)" "(def j (proof '[(impl p q) (impl r s)]\\r\\n              '(impl (or p r) (or q s))))" "(-> (def j (proof '[(impl p q) (impl r s)]\\r\\n                 '(impl (or p r) (or q s))))\\n  (step-b \\"impl-i\\" 4))" "(-> (proof '[(impl p q) (impl r s)]\\r\\n                    '(impl (or p r) (or q s)))\\r\\n     (step-b \\"impl-i\\" 4))" "(-> (proof '[(impl p q) (impl r s)]\\r\\n                       '(impl (or p r) (or q s)))\\r\\n        (step-b \\"impl-i\\" 4)\\n        (step-b \\"or-e\\" 5))" "(-> (proof '[(impl p q) (impl r s)]\\r\\n                          '(impl (or p r) (or q s)))\\r\\n           (step-b \\"impl-i\\" 4)\\r\\n           (step-b \\"or-e\\" 5)\\n           (rename-var 'V1 'p)\\n           (rename-var 'V2 'r))" "(def a '[{\:id 1 \:body (and a b) \:rule \:premise}\\n         {\:id 2 \:body \:todo \:rule nil}\\n         {\:id 3 \:body a \:rule nil}\\n         {\:id 4 \:body b \:rule nil}])" "(step-b a \\"test\\" 3 4)" "(check-duplicates (rename-var (step-b (proof 'X) \\"or-e\\" 2)\\r\\n                  'V1 'a))" "(check-duplicates (rename-var (step-b (proof 'X) \\"or-e\\" 2)\\r\\n                     'V1 'a))" "(check-duplicates (rename-var (step-b (proof 'X) \\"or-e\\" 2)\\r\\n                        'V1 'a))" "a" "(def b '[{\:id 1 \:body a \:rule \:premise}\\n         {\:id 2 \:body (or a b) \:rule \\"or-i1 1\\"}\\n         {\:id 3 \:body \:todo \:rule nil}\\n         {\:id 4 \:body (or a b) \:rule nil}])" "(check-duplicates b)" "(filter \:rule [{\:rule \\"asd\\"} {\:rule nil}])" "(check-duplicates b)" "(def c (proof '[(or a b)] 'X))" "(-> c\\n  (step-b \\"or-e\\" 3)\\n  (rename-var 'V1 'a)\\n  (rename-var 'V2 'b)\\n  (check-duplicates))" "(use 'clojure.walk)" "(postwalk-demo '[1 2 [3 4] [5 6 7] 8])" "(postwalk inc [1 2 [3 4] [5 6 7] 8])" "(postwalk \\n  (fn [node]\\n    (if (vector? node)\\n      node\\n      (inc node))) [1 2 [3 4] [5 6 7] 8])" "(def a (proof '[(or a b)] 'X))" "(-> a\\n  (step-b \\"or-e\\" 3)\\n  (rename-var 'V1 'a)\\n  (rename-var 'V2 b))" "<type clojure code here>" "(def a (proof '[(or a b)] 'X))" "a" "(step-b a \\"or-e\\" 3)" "(def a (proof '[(or a b)] 'X))" "(-> a\\n  (step-b \\"or-e\\" 3)\\n  (rename-var 'V1 'a))" "(def a (proof '[(or a b)] 'X))" "(-> a\\n  (step-b \\"or-e\\" 3)\\n  (rename-var 'V1 'a)\\n  (rename-var 'V2 'b))" "(prewalk-demo [1 2 [3 4] [5 6 7] 8])" "(coll? 'a)" "(create-item 'a)" "(create-item '(infer a b))" "(coll? (lazy-seq 1 2))" "(set (filter \#(.startsWith (str %) \\"_\\") (flatten '(q))))" "(reduce \#(assoc %1 %2 (new-var)) {} \#{})" "(reduce \#(assoc %1 %2 1) {} \#{})" "(map \#(replace {} %) '(q))" "(set (filter \#(.startsWith (str %) \\"_\\") (flatten '(_0))))" "(deduction-playground.proof-new/init-vars '(q))" "(infer '[p] 'p)" "(rename (infer '[p] 'p) 'v 'p)" "(rename-var (infer '[p] 'p) 'v 'p)" "o" "(use 'clojure-walk)" "(use 'clojure.walk)" "(postwalk-demo [1 2 [3 4] [5 6 7] 8])" "(def a '[{\:id 1 \:body a \:rule \:assumption}\\n         {\:id 2 \:body b \:rule \:assumption}\\n         {\:id 3 \:body \:todo \:rule nil}\\n         {\:id 4 \:body a \:rule nil}\\n         {\:id 5 \:body b \:rule nil}])" "(remove-duplicates1 a)" "(use 'clojure.walk)" "(postwalk-demo [1 2 [3 4] [5 6 7] 8])" "a" "(remove-duplicates1 a)" "(nil? (\:rule '{\:id 3, \:body (not (or p (not p))), \:rule \:assumption}))" "(clojure.walk (fn [node]\\n                (if (vector? node)\\n                  nil\\n                  (inc node))) [1 2 [3 4] [5 6 7] 8])" "(clojure.walk/postwalk (fn [node]\\r\\n                   (if (vector? node)\\r\\n                     nil\\r\\n                     (inc node))) [1 2 [3 4] [5 6 7] 8])" "(clojure.walk/postwalk (fn [node]\\r\\n                      (if (vector? node)\\r\\n                        node\\r\\n                        (inc node))) [1 2 [3 4] [5 6 7] 8])" "(use 'clojure.walk)" "(postwalk-demo [1 2 [3 4] 5])" "(prewalk-demo [1 2 [3 4] 5])" "(clojure.string/replace \\"and-i (1 [3 1])\\" 1 2)" "(clojure.string/replace \\"and-i (1 [3 1])\\" \\"1\\" \\"2\\")" "(prewalk-demo [1 2 [3 4] 5])" "(postwalk-demo [1 2 [3 4] 5])" "(filter \#{1 2} [1 2 3 4 2 1])" "a" "(def a (proof '[a (or a V1)] '(or a b)))" "a" "(deduction-playground.proof-new/remove-duplicates1\\n  a)" "(def a (proof '[a (or a V1)] '(or a b)))" "a" "(remove-duplicates1 a)" "(remove-duplicates1 q)" "(remove-duplicates1 a)" "(rename-var a 'V1 'b)" "(def b '[{\:rule \:premise, \:id 1, \:body a} {\:id 2, \:body (or a b), \:rule \:premise} {\:id 3, \:body \:todo, \:rule nil} {\:id 4, \:body (or a b), \:rule nil}])" "b" "(remove-duplicates1 b)" "(def a '[[{\:id 1 \:body a \:rule \:assumption}\\n          {\:id 2 \:body (or a b) \:rule \\"or-1 1\\"}\\n          {\:id 3 \:body \:todo \:rule nil}\\n          {\:id 4 \:body (or a b) \:rule nil}]\\n         {\:id 5 \:body (or a b) \:rule \\"or-i [1 4]\\"}])" "a" "(remove-duplicates1 a)" "(meta (remove-duplicates1 a))" "(remove-duplicates1 a)" "(def t (with-meta \\"asd\\" {\:a 1}))" "(def t (with-meta 1 {\:a 1}))" "(def t (with-meta [1 2 3] {\:a 1}))" "(meta t)" "(remove-duplicates1 a)" "(merge {} nil)" "(remove-duplicates1 a)" "(meta (remove-duplicates1 a))" "(clojure.string/replace \\"1 2 3 4\\" \\"1|2\\" \\"3|4\\")" "(clojure.string/replace \\"1 2 3 4\\" \#\\"1|2\\" \#\\"3|4\\")" "(clojure.string/replace \\"1 2 3 4\\" \\"12\\" \\"34\\")" "(clojure.string/replace \\"1 2 3 4\\" \#\\"12\\" \\"34\\")" "(clojure.string/replace \\"1 2 3 4\\" \#\\"[12]\\" \\"34\\")" "(clojure.string/replace \\"1 2 3 4\\" \#\\"[12]\\" {\\"1\\" \\"3\\" \\"2\\" \\"4\\"})" "(map inc {1 2 3 4})" "(map (key %) {1 2 3 4})" "(map key {1 2 3 4})" "(clojure.string/replace nil \\"a\\" \\"b\\")" "(clojure.string/replace \\"a b a\\" {\\"a\\" \\"c\\"})" "(class \#\\"a|a\\")" "(java.util.regex.Pattern. \\"a|b\\")" "(new java.util.regex.Pattern \\"a|b\\")" "(java.util.regex.Pattern/compile \\"a|b\\")" "(remove-duplicates1 a)" "(meta (remove-duplicates1 a))" "(map \#(str (key %) \\"|\\") {4 2})" "(map \#(str (key %) \\"|\\") {4 2 3 1})" "(apply str (\\"4|\\" \\"3|\\"))" "(apply str '(\\"4|\\" \\"3|\\"))" "(drop-last (apply str '(\\"4|\\" \\"3|\\")))" "(clojure.string/join {4 2 5 1})" "(clojure.string/join (map key {4 2 3 1}) \\"|\\")" "(clojure.string/join (map key {4 2 5 1}))" "(clojure.string/join \\"|\\" (map key {4 2 5 1}))" "(remove-duplicates1 a)" "(correct-ids (remove-duplicates1 a))" "(let [regex (java.util.regex.Pattern/compile \\"a|b\\")\\n      map {\\"a\\" \\"1\\" \\"b\\" \\"2\\"}]\\n  (clojure.string/replace \\"a b a\\" regex map))" "(correct-ids (remove-duplicates1 a))" "(num \\"1\\")" "(Integer. \\"1\\")" "(correct-ids (remove-duplicates1 a))" "(correct-ids (with-meta\\n               '[[{\:id 1, \:body a, \:rule \:assumption} {\:id 2, \:body (or a b), \:rule \\"or-1 1\\"} {\:id 3, \:body \:todo, \:rule nil}] {\:id 5, \:body (or a b), \:rule \\"or-i [1 2]\\"}]\\n               {1 5}))" "(symbol? \:todo)" "(clojure.walk [{\:id 1 \:body 2} {\:id 3 \:body 4}])" "(clojure.walk/postwalk \\n  (fn [node] node)\\n  [{\:id 1 \:body 2} {\:id 3 \:body 4}])" "(clojure.walk/postwalk-demo\\r\\n     [{\:id 1 \:body 2} {\:id 3 \:body 4}])" "(def a '[[{\:id 1 \:body p \:rule \:assumption}\\n          {\:id 2 \:body \:todo \:rule nil}\\n          {\:id 3 \:body p \:rule nil}]\\n         {\:id 4 \:body p \:rule \\"bla [1 3]\\"}])" "(remove-duplicates1 a)" "(check-duplicates a)" "(def a '[[{\:id 1 \:body p \:rule \:assumption}\\n         {\:id 2 \:body \:todo \:rule nil}\\n         {\:id 3 \:body p \:rule nil}]\\n         {\:id 4 \:body p \:rule \\"bla [1 3]\\"}])" "a" "(remove-duplicates1 a)" "(check-duplicates a)" "(def a (proof '[a b] '(and a b)))" "(step-f a \\"and-i\\" 1 2)" "(replace {'a 'p} '{1 (and a b), 2 (and b a)})" "(list? '(and a b))" "(coll? {})" "(seq? {})" "a" "(rename-var a 'a 'c)" "(rename-var (step-f a \\"and-i\\" 1 2) 'a 'c)" "(def b '[[{\:id 1 \:body a \:rule \:assumption}\\n          {\:id 2 \:body \:todo  \:rule nil}\\n          {\:id 3 \:body a \:rule nil}]\\n         {\:id 4 \:body a \:rule \\"bla [1 3]\\"}])" "(remove-duplicates1 b)" "(correct-ids (remove-duplicates1 b))" "(clojure.walk/postwalk-demo [1 2 [3 4] [5 6 7] 8])" "(remove-dup  [1 2 [3 4] [5 6 7] 8])" "(remove-dup [1 2 [3 4] [5 6 7] 8])" "(meta (remove-dup [1 2 [3 4] [5 6 7] 8]))" "(frequencies [1 2 3 1])" "(frequencies [a b a])" "(frequencies '[a b a])" "(filter \#(> (val %) 1) (frequencies '[a b a]))" "(map first (filter \#(> (val %) 1) (frequencies '[a b a])))" "(map first (filter \#(> (val %) 1) (frequencies '[a b a a b c])))" "(set (map first (filter \#(> (val %) 1) (frequencies '[a b a]))))" "a" "(time (set (map first (filter \#(> (val %) 1) (frequencies (map \:body (remove vector? a)))))))" "(time (set (for [[body freq] (frequencies (map \:body (remove vector? a)))\\r\\n                              \:when (> freq 1)]\\r\\n                          body)))" "a" "b" "(remove-dup b)" "(remove-duplicates1 b)" "(remove-dup b)" "b" "(set (map first (filter \#(> (val %) 1) (frequencies (map \:body \\n                                                         (remove vector? '[{\:id 1, \:body a, \:rule \:assumption} {\:id 2, \:body \:todo, \:rule nil} {\:id 3, \:body a, \:rule nil}]))))))" "(remove-dup b)" "(def a '[[{\:id 1 \:body a \:rule \:assumption}\\n          {\:id 2 \:body \:todo \:rule nil}\\n          {\:id 3 \:body a \:rule nil}]\\n         {\:id 4 \:body a \:rule nil}])" "(remove-dup a)" "(clojure.walk/postwalk-demo '[{\:a 1} {\:a 2}])" "a" "(rename-var a 'a 'b)" "(rename-var (step-f a \\"and-i\\" 1 1) 'a 'b)" "(step-f a \\"and-i\\" 1 1)" "(rename-var '[[{\:id 1, \:body a, \:rule \:assumption} {\:id 2, \:body (and a a), \:rule \\"\\\\\\"and-i\\\\\\" (1 1)\\"} {\:id 2, \:body \:todo, \:rule nil} {\:id 3, \:body a, \:rule nil}] {\:id 4, \:body a, \:rule nil}]\\n            'a 'b)" "(def b (proof '[a b] '(and a b)))" "(step-f b \\"and-i\\" 1 2)" "(rename-var '[{\:rule \:premise, \:id 1, \:body a} {\:rule \:premise, \:id 2, \:body b} {\:id 5, \:body {1 (and a b), 2 (and b a)}, \:rule \\"\\\\\\"and-i\\\\\\" (1 2)\\"} {\:id 3, \:body \:todo, \:rule nil} {\:id 4, \:body (and a b), \:rule nil}]\\n            'a 'c)" "(rename-var '[{\:rule \:premise, \:id 1, \:body a} {\:rule \:premise, \:id 2, \:body b} {\:id 5, \:body {1 (and a b), 2 (and b a)}, \:rule \\"\\\\\\"and-i\\\\\\" (1 2)\\"} {\:id 3, \:body \:todo, \:rule nil} {\:id 4, \:body (and a b), \:rule nil}]\\r\\n               'a 'c)" "(remove-dup a)" "(remove-duplicates1 a)" "(time (remove-duplicates1 a))" "(check-duplicates a)" "a" "(def a (assoc (last a) \:rule \\"bla [1 3]\\"))" "a" "(def a '[[{\:id 1, \:body a, \:rule \:assumption} {\:id 2, \:body \:todo, \:rule nil} {\:id 3, \:body a, \:rule nil}] \\n         {\:id 4, \:body a, \:rule \\"bla [1 3]\\"}])" "a" "(check-duplicates a)" "(rename-var '[[{\:id 3, \:body (not (or p (not p))), \:rule \:assumption} [{\:id 9, \:body p, \:rule \:assumption} {\:id 12, \:body (or p V2), \:rule \\"\\\\\\"or-i1\\\\\\" (9)\\"} {\:id 10, \:body \:todo, \:rule nil} {\:id 11, \:body contradiction, \:rule nil}] {\:id 8, \:body (not p), \:rule \\"\\\\\\"not-i\\\\\\" ([9 11])\\"} {\:id 6, \:body (or p (not p)), \:rule \\"\\\\\\"or-i2\\\\\\" (8)\\"} {\:id 7, \:body (not V1), \:rule nil} {\:id 5, \:body contradiction, \:rule \\"\\\\\\"not-e\\\\\\" (6 7)\\"}] {\:id 2, \:body (or p (not p)), \:rule \\"\\\\\\"raa\\\\\\" ([3 5])\\"}]\\n            'V2 '(not p))" "(step-f '[[{\:id 3, \:body (not (or p (not p))), \:rule \:assumption} [{\:id 9, \:body p, \:rule \:assumption} {\:id 12, \:body (or p (not p)), \:rule \\"\\\\\\"or-i1\\\\\\" (9)\\"} {\:id 10, \:body \:todo, \:rule nil} {\:id 11, \:body contradiction, \:rule nil}] {\:id 8, \:body (not p), \:rule \\"\\\\\\"not-i\\\\\\" ([9 11])\\"} {\:id 6, \:body (or p (not p)), \:rule \\"\\\\\\"or-i2\\\\\\" (8)\\"} {\:id 7, \:body (not V1), \:rule nil} {\:id 5, \:body contradiction, \:rule \\"\\\\\\"not-e\\\\\\" (6 7)\\"}] {\:id 2, \:body (or p (not p)), \:rule \\"\\\\\\"raa\\\\\\" ([3 5])\\"}] \\"not-e\\" 1 3)" "(def a (proof '[a (or a V1)] '(or a b)))" "a" "(rename-var a 'V1 'b)" "(def b (proof '[a] '(or a b)))" "(rename-var (step-f a \\"or-i1\\" 1) 'V1 'b)" "b" "(reset\! var-id 0)" "(rename-var (step-f b \\"or-i1\\" 1) 'V1 'b)" "(step-f b \\"or-i1\\" 1)" "(rename-var '[{\:rule \:premise, \:id 1, \:body a} {\:id 6, \:body (or a V2), \:rule \\"\\\\\\"or-i1\\\\\\" (1)\\"} {\:id 2, \:body \:todo, \:rule nil} {\:id 3, \:body (or a b), \:rule nil}]\\r\\n'V2 'b)" "(reset\! var-id 0)" "(rename-var (step-f b \\"or-i1\\" 1) 'V1 'b)" "(rename-var (step-f b \\"or-i1\\" 1) 'V2 'b)" "(rename-var '[{\:rule \:premise, \:id 1, \:body a} {\:id 8, \:body (or a V2), \:rule \\"\\\\\\"or-i1\\\\\\" (1)\\"} {\:id 2, \:body \:todo, \:rule nil} {\:id 3, \:body (or a b), \:rule nil}](step-f b \\"or-i1\\" 1) 'V2 'b)" "(rename-var '[{\:rule \:premise, \:id 1, \:body a} {\:id 8, \:body (or a V2), \:rule \\"\\\\\\"or-i1\\\\\\" (1)\\"} {\:id 2, \:body \:todo, \:rule nil} {\:id 3, \:body (or a b), \:rule nil}]\\n             'V2 'b)" "(rename-var '[{\:rule \:premise, \:id 1, \:body a} {\:id 8, \:body (or a V2), \:rule \\"\\\\\\"or-i1\\\\\\" (1)\\"} {\:id 2, \:body \:todo, \:rule nil} {\:id 3, \:body (or a b), \:rule nil}]\\r\\n                'V2 'b)" "(reset\! var-id 0)" "(rename-var (step-f b \\"or-i1\\" 1) 'V1 'b)" "(use 'clojure.repl)" "(source clojure.walk/postwalk)" "(source clojure.walk/walk)" "b" "(reset\! var-id 0)" "(rename-var (step-f b \\"or-i1\\" 1) 'V1 'b)" "(rename-var (step-f b \\"or-i1\\" 1) 'V2 'b)" "(rename-var (step-f b \\"or-i1\\" 1) 'V3 'b)" "(rename-var (step-f b \\"or-i1\\" 1) 'V4 'b)" "(lazy-seq 1 2 3)" "(lazy-seq (list 1 2 3))" "(class (lazy-seq (list 1 2 3)))" "(class (list (lazy-seq (list 1 2 3))))" "(list (lazy-seq (list 1 2 3)))" "(doall (lazy-seq (list 1 2 3)))" "(class (doall (lazy-seq (list 1 2 3))))" "(into () (lazy-seq (list 1 2 3)))" "(apply list (lazy-seq (list 1 2 3)))" "(class (apply list (lazy-seq (list 1 2 3))))" "(def c '[{\:id 1 \:body a \:rule \:assupmtion}])" "(step-f c \\"or-i1\\" 1)" "(class (\:body (second (step-f c \\"or-i1\\" 1))))" "(class (\:body (first (step-f c \\"or-i1\\" 1))))" "(def c '[{\:id 1 \:body (and a b) \:rule \:assumption}])" "(step-f c \\"or-i1\\" 1)" "(class (\:body (first (step-f c \\"or-i1\\" 1))))" "(class (\:body (second (step-f c \\"or-i1\\" 1))))" "(class (\:body (first (step-f c \\"or-i1\\" 1))))" "(class (\:body (second (step-f c \\"or-i1\\" 1))))" "(\:body (second (step-f c \\"or-i1\\" 1)))" "a" "(reset\! var-id 0)" "b" "(rename-var (step-f b \\"or-i1\\" 1) 'V1 'b)" "(def a (proof '[(and a b)] '(or a b)))" "a" "(step-f a \\"and-e1\\" 1)" "(def b (proof '[a] '(or a b)))" "(step-f b \\"or-i1\\" 1)" "(step-f a \\"and-e1\\" 1)" "(empty? \#{})" "(def a '[{\:id 1 \:body (or a b) \:rule \:premise}\\n         [{\:id 2 \:body a \:rule \:assumption}\\n          {\:id 3 \:body (or a c) \:rule \\"or-i1 2\\"}\\n          {\:id 4 \:body \:todo \:rule nil}\\n          {\:id 5 \:bode (or a c) \:rule nil}]\\n         [{\:id 6 \:body b \:rule \:assumption}\\n          {\:id 7 \:body \:todo \:rule nil}\\n          {\:id 8 \:body (or a c) \:rule nil}]\\n         {\:id 9 \:body (or a c) \:rule \\"or-e 1 [2 5] [6 8]\\"}])" "(def b '[{\:id 1 \:body (not (or a b)) \:rule \:premise}\\n         [{\:id 2 \:body (not (and a b)) \:rule \:assumption}\\n          {\:id 3 \:body \:todo \:rule nil}\\n          {\:id 4 \:body (not (or a b)) \:rule nil}\\n          {\:id 5 \:body (or a b) \:rule nil}\\n          {\:id 6 \:body contradiction \:rule \\"not-e 4 5\\"}]\\n         {\:id 7 \:body (and a b) \:rule \\"raa [2 6]\\"}])" "(remove-dup a)" "(remove-dup b)" "(remove a)" "(remove-dup a)" "(def a '[{\:id 1 \:body (or a b) \:rule \:premise}\\r\\n            [{\:id 2 \:body a \:rule \:assumption}\\r\\n             {\:id 3 \:body (or a c) \:rule \\"or-i1 2\\"}\\r\\n             {\:id 4 \:body \:todo \:rule nil}\\r\\n             {\:id 5 \:bode (or a c) \:rule nil}]\\r\\n            [{\:id 6 \:body b \:rule \:assumption}\\r\\n             {\:id 7 \:body \:todo \:rule nil}\\r\\n             {\:id 8 \:body (or a c) \:rule nil}]\\r\\n            {\:id 9 \:body (or a c) \:rule \\"or-e 1 [2 5] [6 8]\\"}])" "(def b '[{\:id 1 \:body (not (or a b)) \:rule \:premise}\\r\\n            [{\:id 2 \:body (not (and a b)) \:rule \:assumption}\\r\\n             {\:id 3 \:body \:todo \:rule nil}\\r\\n             {\:id 4 \:body (not (or a b)) \:rule nil}\\r\\n             {\:id 5 \:body (or a b) \:rule nil}\\r\\n             {\:id 6 \:body contradiction \:rule \\"not-e 4 5\\"}]\\r\\n            {\:id 7 \:body (and a b) \:rule \\"raa [2 6]\\"}])" "(remove-dup a)" "(remove-dup b)" "(first [])" "a" "(remove-d a)" "(remove-d b)" "(remove-d a)" "a" "b" "(remove-d b)" "a\#" "a" "(def a '[{\:id 1, \:body (or a b), \:rule \:premise} \\n         [{\:id 2, \:body a, \:rule \:assumption}\\n          {\:id 3, \:body (or a c), \:rule \\"or-i1 2\\"} \\n          {\:id 4, \:body \:todo, \:rule nil} {\:id 5, \:body (or a c), \:rule nil}] [{\:id 6, \:body b, \:rule \:assumption} {\:id 7, \:body \:todo, \:rule nil} {\:id 8, \:body (or a c), \:rule nil}] {\:id 9, \:body (or a c), \:rule \\"or-e 1 [2 5] [6 8]\\"}])" "(remove-d a)" "(remove-d b)" "(remove-d a)" "(remove-d b)" "(def c '[{\:id 1 \:body a \:rule \:premise}\\n         {\:id 2 \:body \:todo \:rule nil}\\n         {\:id 3 \:body (or a b) \:rule nil}\\n         [{\:id 4 \:body a \:rule \:assumption}\\n          {\:id 5 \:body (or a b) \:rule \\"or-i1 4\\"}\\n          {\:id 6 \:body \:todo \:rule nil}\\n          {\:id 7 \:body X \:rule nil}]\\n         [{\:id 8 \:body b \:rule \:assumption}\\n          {\:id 9 \:body \:todo \:rule nil}\\n          {\:id 10 \:body X \:rule nil}]\\n         {\:id 11 \:body X \:rule \\"or-e 3 [4 7] [8 10]\\"}])" "(remove-d c)" "(dissoc \#{1 2 3} 1)" "(disj \#{1 2 3} 1)" "(disj \#{1 2 3} 4)" "(remove-d c)" "a" "(remove-d a)" "(remove-d b)" "(meta (remove-d a))" "(remove-d a)" "(remove a)" "(remove-d a)" "(merge nil {})" "(def t [1 [2 3] 4])" "(def p\\n  [t] \\n  (let [t2 (if (contains? (set t) 2)\\n             (with-meta t {\:found true})\\n             t)]\\n    (reduce \#(if (vector? %) (p %)) t)))" "(defn p\\r\\n     [t] \\r\\n     (let [t2 (if (contains? (set t) 2)\\r\\n                (with-meta t {\:found true})\\r\\n                t)]\\r\\n       (reduce \#(if (vector? %) (p %)) t)))" "(p t)" "t" "(p t)" "(remove-d a)" "(meta (remove-d a))" "(remove-d a)" "(remove-d c)" "(remove-d b)" "(remove-d a)" "(remove-d (with-meta a {\:a 1}))" "(meta (with-meta a {\:a 1}))" "(def a (with-meta a {\:a 1}))" "a" "(meta a)" "(remove-d a)" "(remove-d b)" "(remove-d c)" "(def a (with-meta a {}))" "a" "(met a)" "(meta a)" "(meta b)" "(def a (with-meta a nil))" "(remove-d a)" "a" "(remove-d b)" "b" "(remove-d b)" "(merge nil {4 1})" "(def t (with-meta [1 2 3] {\:a 1}))" "(reduce conj t [4 5 6])" "(meta (reduce conj t [4 5 6]))" "(remove-d a)" "(meta (remove-d a))" "(meta (remove-d b))" "(meta (remove-d c))" "(remove-d c)" "(meta (remove-d b))" "(meta b)" "(remove-d b)" "t" "(meta t)" "(let [a (map inc t)\\n      b (meta t)]\\n  b)" "(remove-d b)" "(meta (remove-d b))" "(check-duplicates a)" "(check-duplicates b)" "(check-duplicates c)" "(check-duplicates a)" "(deduction-playground.proof-new/init-vars \\n  '[(infer (actual _0) (substitution (P x) _0 x))])" "(set (filter \#(.startsWith (str %) \\"_\\") (flatten \\n                                          '[(infer (actual _0) (substitution (P x) _0 x))])))" "(reduce \#(assoc %1 %2 (new-var)) {} \#{_0})" "(reduce \#(assoc %1 %2 (deduction-playground.proof-new/new-var)) {} \#{_0})" "(reduce \#(assoc %1 %2 (deduction-playground.proof-new/new-var)) {} \#{'_0})" "(replace '{_0 V1} '(infer (actual _0) (substitution (P x) _0 x)))" "(def g '[{\:id 1 \:body (and (or a b) b) \:rule \:premise}])" "(rename-var g 'b 'Y)" "(replace '{a b} '(and (or a b) a))" "(clojure.walk/prewalk-replace '{a b} \\n                              '(and (or a b) a))" "g" "(rename-var g 'b 'Y)" "(def a (proof/proof '(and a b) 'X))" "a" "(def aa (proof/step-b a \\"or-e\\" 3))" "(pprint1 a)" "(def a (proof/proof '(and a b) 'X))" "(def aa (proof/step-b a \\"or-e\\" 3))" "aa" "(pprint1 aa)" "(if 0 true)" "(pprint1 aa)" "(pp/cl-format nil \\"~2d\\" 100)" "(pp/cl-format nil \\"~2d\\" 1)" "(pprint1 aa)" "(def reg (java.util.regex.Pattern/compile \\"0-9\\"))" "(str/replace \\"hallo 1 10 2\\" reg {\\"1\\" \\"a\\" \\"10\\" b \\"2\\" \\"c\\"})" "(str/replace \\"hallo 1 10 2\\" reg {\\"1\\" \\"a\\" \\"10\\" \\"b\\" \\"2\\" \\"c\\"})" "(def reg (java.util.regex.Pattern/compile \\"[0-9]\\"))" "(str/replace \\"hallo 1 10 2\\" reg {\\"1\\" \\"a\\" \\"10\\" \\"b\\" \\"2\\" \\"c\\"})" "(str/replace \\"hallo 1 10 2\\" \#\\"[0-9]\\" {\\"1\\" \\"a\\" \\"10\\" \\"b\\" \\"2\\" \\"c\\"})" "(str/replace \\"hallo 1 [2 10]\\" \#\\"1|2|10\\" {\\"1\\" \\"a\\"\\n                                         \\"2\\" \\"b\\"\\n                                         \\"10\\" \\"c\\"})" "(str/join \\"|\\" '(1 10 2))" "(def b (proof '(and V1 a) '(and b a)))" "(def (proof/proof '(and a V1) '(and a b)))" "(def b (proof/proof '(and a V1) '(and a b)))" "aa" "(pprint1 aa)" "(pprint-line aa 0 (last aa))" "(last aa)" "(str/replace \\"\\\\\\"or-e\\\\\\" (4 [5 7] [8 10])\\"\\n             \#\\"\\\\b[0-9]+\\\\b\\" \\"a\\")" "(str/replace \\"\\\\\\"or-e\\\\\\" (4 [5 7] [8 10])\\"\\r\\n                \#\\"\\\\b[0-9]+\\\\b\\" \#(inc %))" "(str/replace \\"\\\\\\"or-e\\\\\\" (4 [5 7] [8 10])\\"\\r\\n                   \#\\"\\\\b[0-9]+\\\\b\\" \#(inc (Integer. %)))" "(str/replace \\"\\\\\\"or-e\\\\\\" (4 [5 7] [8 10])\\"\\r\\n                      \#\\"\\\\b[0-9]+\\\\b\\" \#(str (inc (Integer. %))))" "(pprint-line aa 0 (last aa))" "(pprint1 aa)" "(pprint-line aa 0 (last aa))" "(count (str 'X))" "(pprint-line aa 0 (last aa))" "(pprint1 aa)" "(pprint1 (proof/rename-var (proof/rename-var aa 'V1 a)\\n                           'V2 'b))" "(pprint1 (proof/rename-var 'V1 'a))" "(pprint1 (proof/rename-var aa 'V1 'a))" "(pprint1 (proof/rename-var (proof/rename-var aa 'V1 'a)\\n                           'V2 'b))" "(pprint aa)" "(dotimes [_ -1] (print \\"a\\"))" "(dec 0)" "(- 0 (dec 0))" "(% 0 1)" "(/ 0 1)" "(/ 0 0)" "(do (print \\"a\\") (println \\"b\\"))\#" "(str \\"\\\\b\\")" "(str \\"\\\\n\\")" "(str \\"\\\\b\\" 1 \\"\\\\b\\")" "(clojure.string/replace \\"\\\\\\"bla\\\\\\" (1 4)\\"\\n                        \#\\"\\\\b1\\\\b|\\\\b4\\\\b\\"\\n                        {\\"1\\" \\"a\\" \\"4\\" \\"b\\"})" "(clojure.walk/postwalk-replace \\n  '(P x) 'x 't)" "(clojure.walk/postwalk-replace \\r\\n     '{x y} '(P x))" "(def a '(infer (substitution (P x) x t) A))" "a" "(eval-item a)" "(eval-item a nil)" "(eval-item a \\"asd\\")" "(eval-item a a)" "(defn tt \\n  [a b]\\n  (+ a b))" "(tt 2 3)" "(tt 3)" "(eval-item a 12)" "a" "(eval-item 'a 1)" "(eval-item '(infer (substitution (P x) x t) A) \\"asd\\")" "(eval-item a \\"asd\\")" "(def b '(infer (infer a b) X))" "b" "(eval-item b \\"asd\\")" "(eval-item '(infer a b) \\"as\\")" "(list `quote [{\:id 12, \:body a, \:rule \:assumption} {\:id 13, \:body \:todo, \:rule nil} {\:id 14, \:body b, \:rule nil}])" "(infer (infer 'a 'b) 'c)" "(coll? [])" "(coll? {})" "(coll? ())" "(coll? \#{})" "a" "(create-item a)" "(create-item '(substitution (Q x y) x c) \\"hallo\\")" "(log/apply-rule1 \\"forward-i\\" false '(forall [x] (P x)))" "(log/apply-rule1 \\"forall-i\\" false '(forall [x] (P x)))" "(create-items '(infer (actual _0) (substitution (P x) x _0)))" "(init-vars '(infer (actual _0) (substitution (P x) x _0)))" "(create-items ['(infer (actual _0) (substitution (P x) x _0))])" "(-> (proof '[(not (forall [x] (P x)))]\\r\\n              '(exists [x] (not (P x))))\\r\\n          (step-b \\"raa\\" 3) \\r\\n          (step-b \\"not-e\\" 4)\\r\\n          (rename-var 'V1 '(forall [x] (P x)))\\r\\n          (step-b \\"forall-i\\" 4))" "(-> (proof '[(not (forall [x] (P x)))]\\r\\n              '(exists [x] (not (P x))))\\r\\n          (step-b \\"raa\\" 3) \\r\\n          (step-b \\"not-e\\" 4)\\r\\n          (rename-var 'V1 '(forall [x] (P x))))" "(step-b (-> (proof '[(not (forall [x] (P x)))]\\r\\n                 '(exists [x] (not (P x))))\\r\\n             (step-b \\"raa\\" 3) \\r\\n             (step-b \\"not-e\\" 4)\\r\\n             (rename-var 'V1 '(forall [x] (P x))))\\n        \\"forall-i\\" 4)" "(step-b (-> (proof '[(not (forall [x] (P x)))]\\r\\n                    '(exists [x] (not (P x))))\\r\\n                (step-b \\"raa\\" 3) \\r\\n                (step-b \\"not-e\\" 4)\\r\\n                (rename-var 'V1 '(forall [x] (P x))))\\r\\n           \\"forall-i\\" 4)" "(create-item '(infer (actual V2) (substitution (P x) x V2)))" "(create-items '((infer (actual V2) (substitution (P x) x V2))))" "(step-b (-> (proof '[(not (forall [x] (P x)))]\\r\\n                       '(exists [x] (not (P x))))\\r\\n                   (step-b \\"raa\\" 3) \\r\\n                   (step-b \\"not-e\\" 4)\\r\\n                   (rename-var 'V1 '(forall [x] (P x))))\\r\\n              \\"forall-i\\" 4)" "(clojure.walk/postwalk-demo [1 2 [3 4]])" "(step-b (-> (proof '[(not (forall [x] (P x)))]\\r\\n                          '(exists [x] (not (P x))))\\r\\n                      (step-b \\"raa\\" 3) \\r\\n                      (step-b \\"not-e\\" 4)\\r\\n                      (rename-var 'V1 '(forall [x] (P x))))\\r\\n                 \\"forall-i\\" 4)" "(step-b (-> (proof '[(not (forall [x] (P x)))]\\r\\n                             '(exists [x] (not (P x))))\\r\\n                         (step-b \\"raa\\" 3) \\r\\n                         (step-b \\"not-e\\" 4)\\r\\n                         (rename-var 'V1 '(forall [x] (P x))))\\r\\n                    \\"forall-i\\" 4)" "(-> (proof '[(not (forall [x] (P x)))]\\r\\n                                '(exists [x] (not (P x))))\\r\\n                            (step-b \\"raa\\" 3))" "(-> (proof '[(not (forall [x] (P x)))]\\r\\n                                '(exists [x] (not (P x))))\\r\\n                            (step-b \\"raa\\" 3) \\r\\n                            (step-b \\"not-e\\" 4))" "(-> (proof '[(not (forall [x] (P x)))]\\r\\n                                '(exists [x] (not (P x))))\\r\\n                            (step-b \\"raa\\" 3) \\r\\n                            (step-b \\"not-e\\" 4)\\r\\n                            (rename-var 'V1 '(forall [x] (P x))))" "(step-b (-> (proof '[(not (forall [x] (P x)))]\\r\\n                                '(exists [x] (not (P x))))\\r\\n                            (step-b \\"raa\\" 3) \\r\\n                            (step-b \\"not-e\\" 4)\\r\\n                            (rename-var 'V1 '(forall [x] (P x))))\\r\\n                       \\"forall-i\\" 4)" "(def a '(P (f x) y))" "a" "(substitution a 'x 'y)" "(flatten '(P f(x)))" "a" "(substitution a 'x 'y)" "(substitution a 'x 't)" "(log/make-rule \\"not-e\\")" "(eval (log/make-rule \\"not-e\\"))" "`run" "`log/run" "(eval (list `log/run* '[q] ((eval (log/make-rule \\"not-e\\")) 'a q 'contradicition)))" "(eval (list `log/run* '[q] ((eval (log/make-rule \\"not-e\\")) 'a 'q 'contradicition)))" "(eval (list `run* '[q] ((eval (make-rule \\"not-e\\")) 'a q 'contradicition)))" "(eval (list `run* '[q] ((eval (make-rule \\"not-e\\")) 'a 'q 'contradicition)))" "(run* [q] ((eval (make-rule \\"not-e\\")) 'a q 'contradiction))" "(run* [q] ((eval (make-rule \\"not-e\\")) '(not a) q 'contradiction))" "(deduction-playground.proof-new/create-item \\n  '(infer [(actual _2) (substitution _1 _0 _2)] contradiction))" "(flatten  '(infer [(actual _2) (substitution _1 _0 _2)] contradiction))" "(deduction-playground.proof-new/create-item \\r\\n     '(infer  (substitution _1 _0 _2) contradiction))" "(apply-rule1 \\"not-e\\" false 'a 'contradiction)" "(make-rule \\"not-e\\")" "(def a {\:given '[contradiction]\\n        \:conclusion '[a (not a)]})" "(make-rule a)" "(apply-rule1 \\"exists-e\\" false '(exists [x] (P x)) 'Y)" "(make-rule \\"efq\\")" "(make-rule a)" "(apply-rule1 \\"not-e\\" false 'a 'contradiction)" "(apply-rule1 \\"not-e\\" true 'a 'contradiction)" "(apply-rule1 \\"not-e\\" true 'a '(not a))" "(apply-rule1 \\"not-e\\" true 'a '(not b))" "(apply-rule1 \\"not-e\\" false 'contradiction '(not b))" "(apply-rule1 \\"or-e\\" true '(or a b) 'X)" "(apply-rule1 \\"or-e\\" false '(or a b) 'X)" "(def a (proof '(exists [x] (P x)) 'Y))" "a" "(def a (proof '(exists [x] (P x)) 'Y))" "(step-b a \\"exists-e\\" 1 3)" "(log/apply-rule1 \\"exists-e\\" '(exists [x] (P x)) 'Y)" "(step-b a \\"exists-e\\" 1 3)" "a" "(step-b a \\"exists-e\\" 1 3)" "(reduce \#(scope/add-before-line %1 lastline %2) a \\n        '([{\:rule \:assumption, \:id 45, \:body (actual V20)} {\:rule \:assumption, \:id 46, \:body (substitution (P x) x V20)} {\:id 47, \:body \:todo, \:rule nil} {\:id 48, \:body Y, \:rule nil}]))" "(reduce \#(scope/add-before-line %1 3 %2) a \\r\\n           '([{\:rule \:assumption, \:id 45, \:body (actual V20)} {\:rule \:assumption, \:id 46, \:body (substitution (P x) x V20)} {\:id 47, \:body \:todo, \:rule nil} {\:id 48, \:body Y, \:rule nil}]))" "(scope/add-before-line a 3 \\n                       '[{\:rule \:assumption, \:id 45, \:body (actual V20)} {\:rule \:assumption, \:id 46, \:body (substitution (P x) x V20)} {\:id 47, \:body \:todo, \:rule nil} {\:id 48, \:body Y, \:rule nil}])" "(scope/add-after-line a 2\\n                      '[{\:rule \:assumption, \:id 45, \:body (actual V20)} {\:rule \:assumption, \:id 46, \:body (substitution (P x) x V20)} {\:id 47, \:body \:todo, \:rule nil} {\:id 48, \:body Y, \:rule nil}])" "(step-b a \\"exists-e\\" 1 3)" "(list [1 2] 2)" "(step-b a \\"exists-e\\" 1 3)" "(def a {\:hallo 1})" "((keyword \\"bla\\") a)" "(\:hallo nil)" "(count nil)" "(apply-rule1 \\"notnot-e\\" true '(not (not a)))" "(\:notnot-e rules)" "(apply-rule1 \\"notnot-e\\" true '(not (not a)))" "(apply-rule1 \\"not-e\\" true 'a 'b)" "(apply-rule1 \\"not-e\\" true 'a '(not a))" "(apply-rule1 \\"not-e\\" true 'a 'contradiction)" "(apply-rule1 \\"not-e\\" false 'a 'contradiction)" "(deduction-playground.auto-logic/apply-rule1\\n  \\"raa\\" false '(not (forall [x] (P x))))" "(deduction-playground.auto-logic/apply-rule1\\r\\n     \\"raa\\" false '(not (forall [x] (P x))))" "(deduction-playground.auto-logic/make-rule \\"raa\\")" "(deduction-playground.auto-logic/apply-rule1 \\n  \\"not-e\\" true 'a '(not a))" "(deduction-playground.auto-logic/apply-rule1\\n  \\"not-e\\" false 'contradiction)" "(deduction-playground.auto-logic/apply-rule1\\r\\n     \\"not-e\\" false 'contradiction)" "(deduction-playground.auto-logic/apply-rule1\\n  \\"not-e\\" false '(not a) 'contradiction)" "(apply str '(3 4 5))" "(clojure.string/join \\" \\" '(3 4 5))" "(def a '[{\:id 1 \:body (and a b) \:rule \:premise}\\n         {\:id 2 \:body \:todo \:rule nil}\\n         {\:id 3 \:body a \:rule nil}\\n         {\:id 4 \:body b \:rule nil}])" "a" "(step-b a \\"test\\" false 3 4)" "(step-b a \\"test\\" 3 4)" "(choose-option (step-b a \\"test\\" 3 4) 3 1)" "(scope/get-scope (choose-option (step-b a \\"test\\" 3 4) 3 1)\\n                 (get-item (choose-option (step-b a \\"test\\" 3 4) 3 1)\\n                           2))" "a" "(choose-option (step-b a \\"test\\" 3 4) 3 1)" "(def b (proof '(not a) 'contradiction))" "b" "(step-b b \\"not-e\\" 1 3)" "(choose-option (step-b b \\"not-e\\" 1 3) 3 2)" "(def c (proof '[a b] '(and a b)))" "(step-f c \\"and-i\\" 1 2)" "(choose-option (step-f c \\"and-i\\" 1 2)\\n               3 1)" "(choose-option (step-f c \\"and-i\\" 1 2)\\n               3 2)" "(step-b c \\"and-i\\" 1 3)" "(step-b c \\"and-i\\" 1 4)" "(choose-option (step-b c \\"and-i\\" 1 4)\\n               4 1)" "(choose-option (step-b c \\"and-i\\" 1 4)\\n               4 2)" "(step-b c \\"and-i\\" 4)" "(empty? nil)" "(step-b c \\"and-i\\" 4)" "(step-f c \\"and-i\\" 1 2)" "a" "b" "(step-b b \\"not-e\\" 1 3)" "(choose-option (step-b c \\"and-i\\" 4)\\n               3 2)" "(choose-option (step-b b \\"not-e\\" 1 3)\\n               3 2)" "a" "(step-f a \\"and-e2\\" 1)" "(step-f (step-f a \\"and-e2\\" 1) \\"and-e1\\" 1)" "(def a (proof 'a 'b))" "(step-f \\"or-i1\\" a 1)" "(step-f a \\"or-i1\\" 1)" "\\ndeduction-playground.proof-new/var-id" "(reset\! deduction-playground.proof-new/var-id 0)" "(step-f a \\"or-i1\\" 1)" "(deduction-playground.auto-logic/apply-rule2\\n  \\"exists-i\\" false \\n  '(actual g) 'contradiction)" "(deduction-playground.auto-logic/apply-rule2\\r\\n     \\"exists-i\\" false \\r\\n     '(actual g) '(exists [x] (P x)))" "(deduction-playground.auto-logic/apply-rule2\\r\\n        \\"exists-i\\" false \\r\\n        '[(actual g)] '[(exists [x] (P x))])" "(deduction-playground.auto-logic/apply-rule2\\r\\n           \\"exists-i\\" false \\r\\n           '[(exists [x] (P x))] '[(actual g)] )" "(deduction-playground.proof-new/create-items \\n  '((substitution (P x) x g)))" "(map \#(if (vector? %) \\r\\n        [(\:id (first %)) (\:id (last %))]\\r\\n        (\:id %)) '({\:id 13, \:body (P g), \:rule nil}))" "(deduction-playground.auto-logic/apply-rule2\\n  \\"not-e\\" false '[contradiction]\\n  '[(not a)])" "(step-f (proof '(and a b) 'c) \\"and-e1\\" 1)" "(def a (step-f (proof '(and a b) 'c) \\"and-e1\\" 1))" "(step-f a \\"test\\" 1 2)" "(def b '[{\:id 1 \:body (and a b) \:rule \:premise}\\n         {\:id 2 \:body \:todo \:rule nil}\\n         {\:id 3 \:body a \:rule nil}])" "(step-f b \\"test\\" 1 3)" "(def c '[{\:id 1 \:body a \:rule \:premise}\\n         {\:id 2 \:body b \:rule \:premise}\\n         {\:id 3 \:body \:todo \:rule nil}\\n         {\:id 4 \:body c \:rule nil}])" "(step-f c \\"multi\\" 1 2)" "(def c '[{\:id 1 \:body a \:rule \:premise}\\r\\n            {\:id 2 \:body b \:rule \:premise}\\r\\n            {\:id 3 \:body \:todo \:rule nil}\\r\\n            {\:id 4 \:body (not a) \:rule nil}])" "(step-f c \\"multi\\" 1 2 4)" "(deduction-playground.proof-new/check-duplicates\\n  '[{\:id 1 \:body a \:rule \:assumption}\\n    {\:id 2 \:body b \:rule \\"blabla\\"}\\n    {\:id 3 \:body \:todo \:rule nil}\\n    {\:id 12 \:body a \:rule nil}\\n    {\:id 13 \:body b \:rule nil}\\n    {\:id 4 \:body (and a b) \:rule \\"and-i (12 13)\\"}])" "(deduction-playground.proof-new/check-duplicates\\r\\n  '[{\:id 1 \:body a \:rule \:assumption}\\r\\n    {\:id 2 \:body b \:rule \\"blabla\\"}\\r\\n    {\:id 3 \:body \:todo \:rule nil}\\r\\n    {\:id 12 \:body a \:rule nil}\\r\\n    {\:id 13 \:body b \:rule nil}\\r\\n    {\:id 4 \:body (and a b) \:rule \\"and-i (12 13)\\"}])" "(def a '{a [{\:id 1, \:body a, \:rule \:assumption} {\:id 12, \:body a, \:rule nil}], b [{\:id 2, \:body b, \:rule blabla} {\:id 13, \:body b, \:rule nil}]})" "(map val a)" "(map \#(let [remain (filter \:rule %)\\n            delete (remove \:rule %)]\\n        (for [x remain\\n              y delete]\\n          (hash-map x y))) (map val a))" "(map \#(let [remain (map \:id (filter \:rule %))\\r\\n            delete (map \:id (remove \:rule %))]\\r\\n        (for [x remain\\r\\n              y delete]\\r\\n          (hash-map x y))) (map val a))" "(map \#(let [remain (map \:id (filter \:rule %))\\r\\n            delete (map \:id (remove \:rule %))]\\r\\n        (first (for [x remain\\r\\n              y delete]\\r\\n          (hash-map x y)))) (map val a))" "(map \#(let [remain (map \:id (filter \:rule %))\\r\\n            delete (map \:id (remove \:rule %))]\\r\\n        (apply merge (first (for [x remain\\r\\n              y delete]\\r\\n          (hash-map x y))))) (map val a))" "(apply merge ({1 2} {3 4}))" "(apply merge '({1 2} {3 4}))" "(map \#(apply merge (let [remain (map \:id (filter \:rule %))\\r\\n               delete (map \:id (remove \:rule %))]\\r\\n           (first (for [x remain\\r\\n                 y delete]\\r\\n             (hash-map x y))))) (map val a))" "(map \#(let [remain (map \:id (filter \:rule %))\\r\\n               delete (map \:id (remove \:rule %))]\\r\\n           (first (for [x remain\\r\\n                 y delete]\\r\\n             (hash-map x y)))) (map val a))" "(map \#(apply merge (let [remain (map \:id (filter \:rule %))\\r\\n                         delete (map \:id (remove \:rule %))]\\r\\n                     (first (for [x remain\\r\\n                                  y delete]\\r\\n                              (hash-map x y))))) (map val a))" "(apply merge (map \#(let [remain (map \:id (filter \:rule %))\\r\\n               delete (map \:id (remove \:rule %))]\\r\\n           (first (for [x remain\\r\\n                 y delete]\\r\\n             (hash-map x y)))) (map val a)))" "(deduction-playground.proof-new/check-duplicates\\r\\n     '[{\:id 1 \:body a \:rule \:assumption}\\r\\n       {\:id 2 \:body b \:rule \\"blabla\\"}\\r\\n       {\:id 3 \:body \:todo \:rule nil}\\r\\n       {\:id 12 \:body a \:rule nil}\\r\\n       {\:id 13 \:body b \:rule nil}\\r\\n       {\:id 4 \:body (and a b) \:rule \\"and-i (12 13)\\"}])" "a" "(def b '{a [{\:id 1, \:body a, \:rule \:assumption} {\:id 12, \:body a, \:rule nil} {\:id 23 \:body a \:rule nil}], b [{\:id 2, \:body b, \:rule blabla} {\:id 13, \:body b, \:rule nil}]})" "b" "(apply merge (map \#(let [remain (map \:id (filter \:rule %))\\r\\n                  delete (map \:id (remove \:rule %))]\\r\\n              (first (for [x remain\\r\\n                    y delete]\\r\\n                (hash-map x y)))) (map val b)))" "(apply merge (map \#(let [remain (map \:id (filter \:rule %))\\r\\n                  delete (map \:id (remove \:rule %))]\\r\\n              (for [x remain\\r\\n                    y delete]\\r\\n                (hash-map x y))) (map val a)))" "(let [remain (map \:id (filter \:rule (first b)))\\n      delete (map \:id (remove \:rule (first b)))]\\n  delete)" "(first b)" "(let [remain (map \:id (filter \:rule (val (first b))))\\r\\n      delete (map \:id (remove \:rule (val (first b))))]\\r\\n     delete)" "(let [remain (map \:id (filter \:rule (val (first b))))\\r\\n         delete (map \:id (remove \:rule (val (first b))))]\\r\\n        remain)" "(let [remain (map \:id (filter \:rule (val (first b))))\\r\\n      delete (map \:id (remove \:rule (val (first b))))]\\r\\n  (reduce \#(assoc %1 %2 (last remain)) {} delete))" "(deduction-playground.proof-new/check-duplicates\\r\\n        '[{\:id 1 \:body a \:rule \:assumption}\\r\\n          {\:id 2 \:body b \:rule \\"blabla\\"}\\r\\n          {\:id 3 \:body \:todo \:rule nil}\\r\\n          {\:id 12 \:body a \:rule nil}\\r\\n          {\:id 13 \:body b \:rule nil}\\r\\n          {\:id 4 \:body (and a b) \:rule \\"and-i (12 13)\\"}])" "(def c '[{\:id 1 \:body (and a b) \:rule \:premise}\\n         {\:id 2 \:body \:todo \:rule nil}\\n         {\:id 3 \:body (and a b) \:rule nil}\\n         [{\:id 4 \:body a \:rule \:assumption}\\n          {\:id 5 \:body \:todo \:rule nil}\\n          {\:id 12 \:body (and a b) \:rule nil}\\n          {\:id 6 \:body b \:rule \\"bla\\"}]])" "(deduction-playground.proof-new/check-duplicates\\n  c)" "(def d '[{\:id 1 \:body (and a b) \:rule \:premise}\\r\\n         {\:id 2 \:body \:todo \:rule nil}\\r\\n         {\:id 3 \:body a \:rule nil}\\r\\n         [{\:id 4 \:body a \:rule \:assumption}\\r\\n          {\:id 5 \:body \:todo \:rule nil}\\r\\n          {\:id 12 \:body a \:rule nil}\\r\\n          {\:id 6 \:body b \:rule \\"bla\\"}]])" "(deduction-playground.proof-new/check-duplicates\\n  d)" "(deduction-playground.proof-new/check-duplicates\\r\\n     d)" "(deduction-playground.proof-new/check-duplicates\\r\\n     c)" "(deduction-playground.proof-new/check-duplicates\\r\\n           '[{\:id 1 \:body a \:rule \:assumption}\\r\\n             {\:id 2 \:body b \:rule \\"blabla\\"}\\r\\n             {\:id 3 \:body \:todo \:rule nil}\\r\\n             {\:id 12 \:body a \:rule nil}\\r\\n             {\:id 13 \:body b \:rule nil}\\r\\n             {\:id 4 \:body (and a b) \:rule \\"and-i (12 13)\\"}])" "(def a '[{\:id 1 \:body a \:rule \:premise}\\n         [{\:id 2 \:body a \: rule \:assumption}\\n          {\:id 3 \:body \:todo \:rule nil}\\n          {\:id 4 \:body b \:rule nil}]\\n         {\:id 5 \:body \:todo \:rule nil}\\n         {\:id 6 \:body (impl a b) \:rule nil}])" "(def a '[{\:id 1 \:body a \:rule \:premise}\\r\\n         [{\:id 2 \:body a \:rule \:assumption}\\r\\n          {\:id 3 \:body \:todo \:rule nil}\\r\\n          {\:id 4 \:body b \:rule nil}]\\r\\n         {\:id 5 \:body \:todo \:rule nil}\\r\\n         {\:id 6 \:body (impl a b) \:rule nil}])" "(step-f a \\"impl-i\\" (between 2 4))" "(step-f a \\"impl-i\\" [2 4])" "(infer 'a 'b)" "(infer '[a] 'b)" "(step-f a \\"impl-i\\" [2 4])" "(def b '[{\:id 1 \:body (or a b) \:rule \:premise}\\n         [{\:id 2 \:body a \:rule \:assumption}\\n          {\:id 3 \:body \:todo \:rule nil}\\n          {\:id 4 \:body X \:rule nil}]\\n         {\:id 5 \:body \:todo \:rule nil}\\n         {\:id 6 \:body X \:rule nil}])" "(step-b b \\"or-e\\" 1 [2 4] 6)" "(step-f a \\"impl-i\\" [2 4])" "(step-b b \\"or-e\\" 1 [2 4] 6)" "(if (vector? %) [(\:id (first %)) (\:id (last %))] (\:id %))" "(step-b b \\"or-e\\" 1 [2 4] 6)" "b" "(step-b b \\"or-e\\" 1 [2 4] 6)" "(def c (proof '[a b] '(and a b)))" "(step-f c \\"multi\\" 1 2)" "(def c (proof '[a b c] '(not c)))" "(step-f c \\"smulti\\" 1 2 3 5)" "c" "(def a (proof '[a b c] '(not c)))" "(step-f a \\"smulti\\" 1 2 3 5)" "(choose-option (step-f a \\"smulti\\" 1 2 3 5) 4 1)" "(step-f a \\"smulti\\" 1 2 3 5)" "(choose-option (step-f a \\"smulti\\" 1 2 3 5) 4 2)" "(step-f a \\"smulti\\" 1 2 3 5)" "(choose-option (step-f a \\"smulti\\" 1 2 3 5) 4 1)" "(def a '[{\:id 1 \:body a \:rule \:premise}\\n         {\:id 2 \:body {1 [a (and a b)]\\n                       2 [a (and b a)]} \:rule \\"bla\\"}\\n         {\:id 3 \:body \:todo \:rule nil}\\n         {\:id 4 \:body (and a b) \:rule nil}])" "(choose-option a 2 1)" "(choose-option a 2 2)" "(def a '[{\:id 1 \:body a \:rule \:premise}\\n         {\:id 3 \:body \:todo \:rule nil}\\r\\n         {\:id 2 \:body {1 [a (and a b)]\\r\\n                       2 [a (and b a)]} \:rule nil}\\r\\n         {\:id 4 \:body (and a b) \:rule \\"bla\\"}])" "(choose-option a 3 1)" "(choose-option a 3 2)" "(def a '[{\:id 1 \:body (and a b) \:rule \:prem}\\n         {\:id 2 \:body \:todo \:rule nil}\\n         {\:id 3 \:body a \:rule nil}\\n         {\:id 4 \:body b \:rule nil}])" "(step-b a \\"test\\" 3 4)" "(choose-option (step-b a \\"test\\" 3 4) 3 1)" "(choose-option (step-b a \\"test\\" 3 4) 3 2)" "(def b '[{\:id 1 \:body a \:rule \:premise}\\n         {\:id 2 \:body b \:rule \:premise}\\n         {\:id 3 \:body \:todo \:rule nil}\\n         {\:id 4 \:body (not a) \:rule nil}\\n         {\:id 5 \:body (and a b) \:rule nil}])" "(step-b b \\"multi\\" 4 5)" "(def b '[{\:id 1 \:body a \:rule \:premise}\\r\\n            {\:id 2 \:body b \:rule \:premise}\\r\\n            {\:id 3 \:body \:todo \:rule nil}\\r\\n            {\:id 4 \:body (not a) \:rule nil}\\r\\n            {\:id 5 \:body (or a b) \:rule nil}])" "(step-b b \\"multi\\" 4 5)" "(distinct? '(1 2 3 [3 4]))" "(distinct? '(1 3 [3 4] [3 4] 2))" "(distinct? 1 3 2 [3 4] [3 4] )" "(distinct? 1 2 3 [3 4])" "(< 2 1)" "(deduction-playground.proof-new/get-item\\n  '[1 2 [3 4] 5]\\n  [3 4])" "(def a (proof '[a b] '(and a b)))" "(deduction-playground.proof/proved? a)" "a" "(deduction-playground.proof/proved?\\n  (-> (proof '(not (or p q))\\r\\n                   '(and (not p) (not q)))\\r\\n          (step-b \\"and-i\\" 3)\\r\\n          (step-b \\"not-i\\" 3)\\r\\n          (step-b \\"not-i\\" 7)\\r\\n          (step-b \\"not-e\\" 1 4)\\r\\n          (choose-option 4 2)))" "(deduction-playground.proof/proved?\\r\\n     (-> (proof '(not (or p q))\\r\\n                      '(and (not p) (not q)))\\r\\n             (step-b \\"and-i\\" 3)\\r\\n             (step-b \\"not-i\\" 3)\\r\\n             (step-b \\"not-i\\" 7)\\r\\n             (step-b \\"not-e\\" 1 4)\\r\\n             (choose-option 4 2)))" "(conj [1 2] '(3 4 5))" "(apply \#(conj [1 2] %) '(3 4 5))" "(conj [1 2] 3 4 5)" "(apply \#(conj [1 2]) '(3 4 5))" "(deduction-playground.proof/proved?1\\r\\n        (-> (proof '(not (or p q))\\r\\n                         '(and (not p) (not q)))\\r\\n                (step-b \\"and-i\\" 3)\\r\\n                (step-b \\"not-i\\" 3)\\r\\n                (step-b \\"not-i\\" 7)\\r\\n                (step-b \\"not-e\\" 1 4)\\r\\n                (choose-option 4 2)))" "(deduction-playground.proof/proved?\\r\\n        (-> (proof '(not (or p q))\\r\\n                         '(and (not p) (not q)))\\r\\n                (step-b \\"and-i\\" 3)\\r\\n                (step-b \\"not-i\\" 3)\\r\\n                (step-b \\"not-i\\" 7)\\r\\n                (step-b \\"not-e\\" 1 4)\\r\\n                (choose-option 4 2)))" "(deduction-playground.proof/proved?1\\r\\n        (-> (proof '(not (or p q))\\r\\n                         '(and (not p) (not q)))\\r\\n                (step-b \\"and-i\\" 3)\\r\\n                (step-b \\"not-i\\" 3)\\r\\n                (step-b \\"not-i\\" 7)\\r\\n                (step-b \\"not-e\\" 1 4)\\r\\n                (choose-option 4 2)))" "(-> (proof '(not (or p q))\\r\\n                            '(and (not p) (not q)))\\r\\n                   (step-b \\"and-i\\" 3)\\r\\n                   (step-b \\"not-i\\" 3)\\r\\n                   (step-b \\"not-i\\" 7)\\r\\n                   (step-b \\"not-e\\" 1 4)\\r\\n                   (choose-option 4 2))" "(deduction-playground.proof/proved?1\\r\\n           (-> (proof '(not (or p q))\\r\\n                            '(and (not p) (not q)))\\r\\n                   (step-b \\"and-i\\" 3)\\r\\n                   (step-b \\"not-i\\" 3)\\r\\n                   (step-b \\"not-i\\" 7)\\r\\n                   (step-b \\"not-e\\" 1 4)\\r\\n                   (choose-option 4 2)))" "(def b {\:a 2 \:b 2})" "(deduction-playground.read-rules/export-theorem\\n  \\"src/deduction_playground/theorems.clj\\"\\n  b)" "(deduction-playground.read-rules/export-theorem\\r\\n     \\"src/deduction_playground/theorems.clj\\"\\r\\n     b)" "(deduction-playground.read-rules/export-theorem\\n  \\"src/deduction_playground/theorems.clj\\"\\n  (-> (proof '(not (or p q))\\r\\n                   '(and (not p) (not q)))\\r\\n          (step-b \\"and-i\\" 3)\\r\\n          (step-b \\"not-i\\" 3)\\r\\n          (step-b \\"not-i\\" 7)\\r\\n          (step-b \\"not-e\\" 1 4)\\r\\n          (choose-option 4 2)\\r\\n          (step-f \\"or-i1\\" 2)\\r\\n          (rename-var 'V1 'q)\\r\\n          (step-b \\"not-e\\" 7 1)\\r\\n          (choose-option 7 2)\\r\\n          (step-f \\"or-i2\\" 5)\\r\\n          (rename-var 'V2 'p)\\r\\n          )\\n  \\"TestTheorem\\")" "(deduction-playground.read-rules/export-theorem\\r\\n     \\"src/deduction_playground/theorems.clj\\"\\r\\n     (-> (proof '(not (or p q))\\r\\n                      '(and (not p) (not q)))\\r\\n             (step-b \\"and-i\\" 3)\\r\\n             (step-b \\"not-i\\" 3)\\r\\n             (step-b \\"not-i\\" 7)\\r\\n             (step-b \\"not-e\\" 1 4)\\r\\n             (choose-option 4 2)\\r\\n             (step-f \\"or-i1\\" 2)\\r\\n             (rename-var 'V1 'q)\\r\\n             (step-b \\"not-e\\" 7 1)\\r\\n             (choose-option 7 2)\\r\\n             (step-f \\"or-i2\\" 5)\\r\\n             (rename-var 'V2 'p)\\r\\n             )\\r\\n     \\"TestTheorem\\")" "(vector '(and a b))" "(deduction-playground.read-rules/export-theorem\\r\\n     \\"src/deduction_playground/theorems.clj\\"\\r\\n     (-> (proof '(not (or p q))\\r\\n                      '(and (not p) (not q)))\\r\\n             (step-b \\"and-i\\" 3)\\r\\n             (step-b \\"not-i\\" 3)\\r\\n             (step-b \\"not-i\\" 7)\\r\\n             (step-b \\"not-e\\" 1 4)\\r\\n             (choose-option 4 2)\\r\\n             (step-f \\"or-i1\\" 2)\\r\\n             (rename-var 'V1 'q)\\r\\n             (step-b \\"not-e\\" 7 1)\\r\\n             (choose-option 7 2)\\r\\n             (step-f \\"or-i2\\" 5)\\r\\n             (rename-var 'V2 'p)\\r\\n             )\\r\\n     \\"TestTheorem\\")" "(deduction-playground.read-rules/export-theorem\\n  \\"src/deduction_playground/theorems.clj\\"\\n  (-> (proof '[(impl a b) (not b)] '(not a))\\r\\n          (step-b \\"not-i\\" 4)\\r\\n          (step-f \\"impl-e\\" 1 3)\\r\\n          (step-f \\"not-e\\" 2 4)\\r\\n          )\\n  \\"modus-tollens\\")" "(or false 1)" "(or 1 2)" "(or nil 3)" "(def a (proof '(not b) '(not a)))" "a" "(step-b a \\"modus-tollens\\" 1 3)" "(list (list 1 2 3))" "(get-term-arg '[x (not y)])" "(map + [1 2 3] [4 5 6])" "(gen-logic-function '[a b] '[(and a b)])" "(gen-logic-function '[a (not a)] '[contradiction])" "(apply-rule2 \\"not-e\\" true '[a (not a)])" "(deduction-playground.auto-logic/make-rule \\"not-e\\")" "(deduction-playground.auto-logic/gen-logic-function\\n  '[a (not a)] '[contradiction])" "(deduction-playground.auto-logic/make-rule\\n  \\"not-e\\")" "(deduction-playground.auto-logic/make-rule\\n  {\:given '[contradiction]\\n   \:conclusion '[a (not a)]})" "(run* [q] ((eval (clojure.core/fn [contradiction q1 q2] (clojure.core.logic/fresh [a] (clojure.core.logic/\=\= contradiction (quote contradiction)) (clojure.core.logic/\=\= q1 a) (clojure.core.logic/\=\= q2 (clojure.core/seq (clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list a)))))))\\n            q '(not a) 'contradiction))" "(clojure.core.logic/run* [q] ((eval (clojure.core/fn [contradiction q1 q2] (clojure.core.logic/fresh [a] (clojure.core.logic/\=\= contradiction (quote contradiction)) (clojure.core.logic/\=\= q1 a) (clojure.core.logic/\=\= q2 (clojure.core/seq (clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list a)))))))\\r\\n               q '(not a) 'contradiction))" "(clojure.core.logic/run* [q] ((eval (clojure.core/fn [contradiction q1 q2] (clojure.core.logic/fresh [a] (clojure.core.logic/\=\= contradiction (quote contradiction)) (clojure.core.logic/\=\= q1 a) (clojure.core.logic/\=\= q2 (clojure.core/seq (clojure.core/concat (clojure.core/list (quote not)) (clojure.core/list a)))))))\\r\\n                  q 'contradiction '(not a)))" "(def a (proof '[(impl p q) (not q)] '(not p)))" "a" "(deduction-playground.proof/get-scope\\n  a {\:rule \:premise, \:id 1, \:body (impl p q)})" "(deduction-playground.proof/get-scope\\n  [1 2 [3 4] [5 6 7] 8]\\n  5)" "(deduction-playground.proof/get-scope\\r\\n     [1 2 [3 4] [5 6 7] 8]\\r\\n     5)"]
eclipse.preferences.version=1
