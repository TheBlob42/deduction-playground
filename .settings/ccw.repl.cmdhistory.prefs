cmdhistory=["((optional (item 2)) [2])" "((pand (optional (item 2)) (item 3)) [2 3])" "((pand (optional (item \\"(\\")) (item \\"true\\") (optional \\")\\")) [\\"(\\" \\"true\\"])" "((optional (item \\"(\\")) [\\"(\\"])" "((pand (optional (item \\"(\\")) (item \\"true\\")) [\\"(\\" \\"true\\"])" "(pForm (fts '(true)))" "(pForm (fts '(and true false)))" "(pForm (fts '(true)))" "(pForm (fts '(false)))" "(pForm (fts '(and false true)))" "(pForm (fts '(P c)))" "(pForm (fts '(P (f c c))))" "(pForm (fts '(P c c)))" "(pForm (fts '(P2 c c)))" "(pForm (fts '(P x)))" "@variables" "(r)" "(pForm (fts '(P2 x y)))" "@variables" "(r)" "(pForm (fts '(\= c c)))" "(pForm (fts '(\= c c c)))" "(pForm (fts '(\= x z)))" "@variables" "(r)" "(pForm (fts '(\= (f c x) z)))" "@variables" "(r)" "(pForm (fts '(and true x)))" "@variables" "(pForm (fts '(and (or true (not false)) (or (and true (not false)) true))))" "(pForm (fts '(forall [x y] \\n                     (and (P2 (f x z) ) (not c)))))" "@variables" "(r)" "(pForm (fts '(exist [x] (and (P x) (not (P2 (f x z)))))))" "@variables" "(r)" "(formula '(and (not (P x)) true))" "@variables" "(formula '(exist [x] (P x)))" "(formula '(forall [x] (P2 x z)))" "(formula '(forall [x] (and (P x) (P2 (f c z) x))) sign)" "(diDebug)" "(formula '(forall [x] (and (P x) (P2 (f c z) x))) sign)" "(use '[clojure.repl \:refer \:all])" "(doc map)" "(doc add-variable\!)" "(doc swap\!)" "(def s {\:c [\:const 0]\\n        \:P [\:pred 1]\\n        \:f [\:func 2]})" "(formula form s)" "s" "form" "(def s {\:c [\:const 0]\\n        \:P [\:pref 1]\\n        \:f [\:func 2]})" "(formula form s)" "form" "s" "(split-form form)" "(parse-formula s (split-form form))" "(parse-formula s (split-form '(and true (P c))))" "(parse-formula s (split-form '(forall [x] (and (or (P z) false)\\n                                               (P (f x c))))))" "(formula '(forall [x] (and (P x) (or (P (f c z)))))\\n         {\:c [\:const 0]\\n          \:P [\:pred 1]\\n          \:f [\:func 2]})" "(def s {\:c [\:const 0]\\r\\n             \:P [\:pred 1]\\r\\n             \:f [\:func 2]})" "(parse-formula s '(forall [x] (and (P x) (or (P (f c z))))))" "(split-form '(forall [x] (and (P x) (or (P (f c z))))))" "(formula '(forall [x] (and (P x) (or (P (f c z)) true))) s)" "(def s (signature {\:const [\\"c\\"]\\n                   \:pred [\\"P\\" 1 \\"Q\\" 2]\\n                   \:func [\\"f\\" 2 \\"g\\" 3]}))" "s" "(def f '(exist [x] (and (P x) (or (Q c x) (P (f z x))))))" "(formula f s)" "(meta (formula f s))" "(def s (signature {\:const [\\"c\\"]\\n                   \:pred [\\"P\\" 1 \\"Q\\" 2]\\n                   \:func [\\"f\\" 2 \\"g\\" 3]}))" "s" "(def f '(exist [y] (and (P y) (Q (f c y) (g c y x)))))" "f" "(meta (formula f s))" "(def f '(forall [x] (P x)))" "(def s (signature {\:pred [\\"P\\" 1]}))" "(meta (formula f s))" "sign" "(distinct? '[d d e g h])" "(distinct? (seq '[d d eg j]))" "(seq '[d f g])" "(apply distinct? '[d d g])" "(apply distinct? '[d e g])" "(keyword p)" "(keyword 'P)" "(signature sign)" "(def x (signature sign))" "(\:Q x)" "(def x '{q [\:pred 0]})" "x" "('q x)" "(\:q x)" "(q x)" "(signature sign)" "(vals sign)" "(flatten (vals sign))" "(merge [1 2 3] [4 5])" "(concat [1 3 4] [5 6])" "(concat [1 1 1] nil [2 3])" "(\:func sign)" "(take-nth 2 (\:func sign))" "(apply distinct? (concat (\:const sign) (take-nth 2 (\:func sign))\\n                         (take-nth 2 (\:pred sign))))" "(apply distinct? (concat (\:const sign) (take-nth 2 (\:func sign))\\r\\n                            (take-nth 2 (\:pred sign))))" "(signature sign)" "(reduce into {} [1 2 3])" "(reduce concat [] [[1 2] [3 4]])" "(into {} [1 2 3 4])" "(symbol? x)" "(symbol? 'x)" "keywords" "(contains? keywords 'forall)" "(atom? 'x)" "(expr? 'forall)" "'true?" "'true" "true" "(symbol? true)" "(symbol? 'true)" "(def a '(and a b))" "(first a)" "(\= (first a) and)" "(\= (first a) 'and)" "(defn t [a]\\n  (cond \\n    (nil? a) true\\n    (\= (first a) 1) (t (rest a))\\n    (\= (first a) 2) (throw (IllegalStateException. \\"ERROR\\"))))" "(t [1 1 2])" "(t [1 1 1 ])" "(t nil)" "(defn t [a]\\r\\n     (cond \\r\\n       (nil? (first a)) true\\r\\n       (\= (first a) 1) (t (rest a))\\r\\n       (\= (first a) 2) (throw (IllegalStateException. \\"ERROR\\"))))" "(t [1 1 1 ])" "(wff? '(1 2 3))" "(wff? \\"asd\\")" "(wff? 'x)" "(wff? '(and true false))" "(wff' '(or true))" "(wff? '(or true))" "(\= (first '(\= true false)) '\=)" "(wff? '(and true))" "(wff? '(or true))" "(wff? '(and or or))" "(wff? '(and true or))" "(wff? '(and true true))" "(first true)" "(true)" "(wff? '(and true true))" "(rest true)" "(wff? '(and))" "(wff? 'true)" "(wff? '(bla))" "(second '(and bla 2))" "(third '(a d b))" "(wff? '(and (and true false) false))" "(wff? '(and true (and true false false)))" "(rest '(and 1 3 4))" "(wff? '(and true (and false false true)))" "(wff? '(and true (and false (and true true))))" "(wff? '(and true (and false (and true true false))))^" "(wff? '(and (or true false) (and true (or false true))))" "(wff? '(and (or true false true) (and true (or false true))))" "(wff? '(and true (and false true true) true))" "(defn is1 [p] (if (\= p 1) true false))" "(is1 3)" "(is1 1)" "(every? is1 (1 1 1 1))" "(every? is1 '(1 1 1))" "(every? is1 '(1 1 1 1 2))" "(wff? '(and true (and true false) false))" "(wff? '(and true false bla))" "(rest '(and true false bla))" "(every? subform '(true false))" "(every? subform '(true false bla))" "(str bla)" "(str 'bla)" "(wff? '(and true false bla))\#" "(wff? '(and true false bla))" "'(bla b g)" "(seq? ())" "(seq? [])" "(seq? {})" "(seq? \#{})" "(seq? 'g)" "(wff? '(and true false bla))" "(wff? '(and true (yeah true false)))" "(wff? '(and true (eef true false)))" "(not true true)" "(every? subform '())" "(wff? '(and ))" "(\= true and)" "(\= true 'and)" "(\= true ())" "(rest '(and ))" "(subform ())" "(subform '())" "(every? subform ())" "(wff? '(and ))" "(count (rest '(and)))" "(< 0 2)" "(< 2 0)" "(wff? '(and ))" "(wff? '(and true (and false)))" "(wff? '(and true (forall [x y] (or false (not true))) false))" "(wff? '(and true (forall [] (or false (not true))) false))" "(defn f [i] (if (\= i 1) true false))" "(f 3)" "(f 1)" "(take 3 (iterate f))" "(take 3 (iterate 'f))" "(take 3 (cycle 'f))" "(take 3 (cycle '(f)))" "(apply f (1 1 1))" "(apply f '(1 1 1))" "(is-with-arity? (P 1) \:pred f)" "(is-with-arity? '(P 1) \:pred 'f)" "(is? 'P \:pred)" "(is? 'f2 \:func)" "(f 1)" "(f 2)" "(every? 'f (rest '(P 1)))" "(rest '(P 1))" "(every? f (1))" "(every? f '(1))" "(every? f (rest '(P 1)))" "(is-with-arity? '(P 1) \:pred f)" "(is-with-arity? '(P 1 1) \:pred f)" "(is-with-arity? '(c) \:const f)" "(is-with-arity? '(x) \:pred f)" "(def x {\:a 1 \:b 2})" "(contains? x \:c)" "(contains? x \:a)" "(is? c \:const)" "(is? 'c \:const)" "(is? 'P \:pred)" "(is? 'c \:pred)" "(is? 'x \:pred)" "(is? 'c \:const)" "(if (is? 'c \:const) \\"ba\\")" "(is-with-arity? '(P 1) \:pred f)" "(is-with-arity? '(P 1 1) \:pred f)" "(is-with-arity? '(X 1) \:pred f)" "(function '(f c x))" "(term 'x)" "(if (\= 2 3) true)" "(function '(f c x))" "(function '(f P x))" "(function '(f B B))" "(is? 'P \:const)" "(function '(f P x))" "(term 'P)" "(symbol? 'P)" "(or (is? 'P \:const) (variable? 'P))" "(and (symbol? phi) \\r\\n               (or (is? phi \:const) \\r\\n                   (variable? phi)))" "(and (symbol? 'P) \\r\\n               (or (is? 'P \:const) \\r\\n                   (variable? 'P)))" "(def phi 'P)" "(or (and (symbol? phi) \\r\\n               (or (is? phi \:const) \\r\\n                   (variable? phi)))\\r\\n          (function phi))" " (and (symbol? phi) \\r\\n               (or (is? phi \:const) \\r\\n                   (variable? phi)))" "(or (and (symbol? phi) \\r\\n               (or (is? phi \:const) \\r\\n                   (variable? phi)))\\r\\n          (function 'phi))" "'phi" "(first phi)" "(term '(f P c))" "(function '(f P c))" "(function '(f c c))" "(pred '(P (f c x)))" "(predicate '(P (f c x)))" "(function '(f c x))" "(function '(f c P))" "(function '(f c x))" "(function '(f c c c))" "(is-with-arity? '(f c c) \:func term)" "(def f '(f c c c))" "(is-with-arity? f \:func term)" "(function '(f P c))" "(function '(f c c c))" "(function '(f (c c) c))" "(function '(f c c P))" "(function '(f P c))" "(term '(f c c c))" "(predicate '(P c c))" "(predicate '(P f))" "(subform '(forall [x] (P c)))" "(subform '(and (P (f P c)) true))" "(subform '(p c))" "(subform '(P c c))" "(subform '(P f))" "(subform '(P c))" "(and (symbol? 'f) (or (is? 'f \:const) (variable? 'f)))" "(list? 'f)" "(is-with-arity? (P f) \:pred term)" "(is-with-arity? '(P f) \:pred term)" "(second ((keyword (first '(P f))) sign))" "(\= (count (rest '(P f)) 1))" "(\= (count (rest '(P f))) 1)" "(every? term (rest '(P f)))" "(every? term 'f)" "(rest '(P f))" "(defn is1 [x] (if (\= x 1) true false))" "(every? is1 (1))" "(every? is1 '(1))" "(every? is1 (1 1 1))" "(function '(f c c))" "(predicate '(P f))" "(is-with-arity? '(P f) phi \:pred \#(term % phi))" "(is-with-arity? '(P f) \:pred \#(term % phi))" "(is-with-arity? '(P f) \:pred \#(term % '(P f)))" "(subform '(and (P (f c x)) true))" "(is? 'f \:func)" "(subform '(and (P (f c x)) true))" "(subform '(P (f c x)))" "(is? (first '(P (f c x))) \:pred)" "(term '(f c x))" "(is? '(f c x) phi \:func)" "(is? '(f c x) \:func)" "(term '(f c x))" "(subform '(and (P (f c x)) true))" "(subform '(exist [x y] (or (P c) (and (not (P (f x (f c c)))) false))))" "(and (\= 1 1) (\= 1 2) (throw (Exception. (str \\"asdkladkjasd\\"))))" "(and (\= 1 1) (\= 1 1) (throw (Exception. (str \\"asdkladkjasd\\"))))" "(time (subform '(exist [x y] (or (P c) (and (not (P (f x (f c c)))) false)))))" "(subform '(exist [x y] (or (P c) (and (not (P (f x (f c c)))) false))))" "(predicate '(exist [x]))" "(is? '(exist [x]) \:pred)" "(is? (first '(exist [x]) \:pred))" "(is? (first '(exist [x])) \:pred)" "(subform '(exist [x y] (or (P c) (and (not (P (f x (f c c)))) false))))" "(term '(f c (f P c)))" "(subform '(exist [P] (P x)))" "(subform '(forall [P x] (P x)))" "(subform '(forall [x P] '(P x)))" "(subform '(\= c (f x c)))" "(subform '(or (\= (f c x) y) (P y)))" "(defn t\\n  [i & [b]]\\n  (println i (if b (str \\" + \\" b))))" "(t \\"ha\\")" "(if (\= 1 2) true)" "(defn t\\r\\n     [i & [b]]\\r\\n     (println i (if b (str \\" + \\" b) \\"\\")))" "(t \\"asd\\")" "(t \\"asd\\" \\"asd\\")" "(term '(f P c))" "(term 'P)" "(str 'and)" "(single 'c)" "sign" "(\:c sign)\=" "(\:c sign)" "(\:c @sign)" "(subform '(forall [x] (and (P (f c x)) true)))" "(wff? '(forall [x] (and (P (f c x)) true)) s)" "s" "@sign" "(is? 'P \:pred)" "(\:P sign)" "(wff? '(forall [x] (and (P (f c x)) true)) s)" "(wff? '(forall [x] (and (P (f c Q)) true)) s)" "(wff? '(forall [x] (and (P (f c P2)) true)) s)" "(\= 1 1 1)" "(reset\! sign {} {})" "(throw (ArityException. \\"asdf\\"))" "(def s (signature {\:const '[c]\\n                   \:func '[f 1 g 2]\\n                   \:pred '[P 1 Q 2]}))" "s" "(def f '(forall [x] (and (P x) (not Q x c))))" "f" "(formula f s)" "(def f '(forall [x] (P x) (not (Q x c))))" "(formula f s)" "(def f '(forall [x] (and (P x) (Q c x))))" "(formula f s)" "(meta (formula f s))" "(run* [q]\\n      (everyg \#(membero % [\:a]) [\:a \:a \:a]))" "(run* [q]\\r\\n         (everyg \#(membero % [\:a]) [\:a \:a \:a])\\n         (\=\= q false))" "(run* [q]\\n      (fresh [x]\\n             (\=\= x false)\\n             (\=\= q true)\\n             (everyg \#(membero % [\:a]) (\:a \:a \:a))))" "(run* [q]\\r\\n         (fresh [x]\\r\\n                (\=\= x false)\\r\\n                (\=\= q true)\\r\\n                (everyg \#(membero % [\:a]) [\:a \:a \:a])))" "(run* [q]\\r\\n      (fresh [x y]\\r\\n             (everyg \#(membero % [\:a \:b]) q)\\n             (\=\= q [x y])))" "(run* [q]\\r\\n      (fresh [x]\\r\\n             (\=\= x 1)\\r\\n             (is q x nil)))" "(run* [q] (and-e-l '(and x y) q))" "rule" "(defn (\:name rule) \\"asd\\")" "(symbol \\"asd\\")" "(defn (symbol (\:name rule)) \\"asd\\")" "(defmacro postfix [expr]\\n  (conj (butlast expr) (last expr)))" "(postfix (1 1 +))" "`+" "`(and a b)" "(run* [q] (and-e-l '(and a b) q))" "`('and a b)" "(defn c\\n  [c code]\\n  `(println ~c ~code))" "(def c \\"asd\\")" "c" "(defn c\\r\\n     [c code]\\r\\n     `(println ~c ~code))" "(def a \\"asd\\")" "(c \\"asdasd\\" a)" "(eval (c \\"asdasd\\" a))" "(defn c\\r\\n        [c code]\\r\\n        `(println ~c (quote ~code)))" "(c \\"asdasd\\" a)" "(eval (c \\"asdasd\\" a))" "(def a '(+ a a))" "(c \\"asdasd\\" a)" "(eval (c \\"asdasd\\" a))" "(defn c\\r\\n           [c code]\\r\\n           `(println ~c ~code))" "(eval (c \\"asdasd\\" a))" "(applyrule rule)" "(quote (applyrule rule))" "(applyrule rule)" "(symbol \\"asd)" "(symbol \\"asd\\")" "(def f (applyrule rule))" "(applyrule rule)" "(\:operator rule)" "(applyrule rule)" " (applyrule rule)" "(def a [(\:operator rule)])" "a" " (applyrule rule)" "(app rule)" "(applyrule rule)" "a" "(applyrule rule)" "rule" "(applyrule rule)" "rule" "(applyrule rule)" "(code-critic {\:good \\"bla\\" \:bad \\"blub\\"})" "(applyrule rule)" "(applyrule {\:result \\"asd\\"})" "rule" "(applyrule rule)" "(app rule)" "(eval (app rule))" "(def a (app rule))" "(a 12)" "(applyrule rule)" "(a)" "a" "(a \\"asd\\")" "(app rule)" "(a 23)" "a" "(app rule)" "(a 23)" "a" "(applyrule 'a)" "(applyrule r)" "(applyrule a [b])" "(defmacro double-it                \\r\\n  [fname args & body]         \\r\\n  `(do (defn ~fname ~args ~@body)\\r\\n       (defn ~(symbol (str fname \\"*\\")) ~args ~@body)))\\r\\n\\r\\n(double-it afunc [str] (println str))" "(afunc \\"asd\\")" "(applyrule aaa \\"asd\\")" "(applyrule bla [s])" "(bla 1)" "(applyrule a [s])" "(app rule)" "(applyrule a [s])" "(applyrule a [and a])" "(app rule)" "(and-e-l 1)" "(and-e-l)" "(and-e-l 2 3)" "(app rule)" "(applyrule f [s])" "(f 1)" "(applyrule 's [r])" "(macroexpand (applyrule s [r]))" "(macroexpand '(applyrule s [s]))" "(source and)" "(use 'clojure.repl)" "(source and)" "(t {\:name 'hallo})" "hallo" "(t {\:name \\"asd\\"})" "asd" "(n 1)" "(t {\:name bla})" "(t {\:name \\"hallo\\"})" "(t {\:name 'hallo})" "(t {\:name \\"hallo\\"})" "(t {\:name 'hallo})" "(macroexpand '(t {\:name 'hallo}))" "(t {\:name \\"hallo\\"})" "(t {\:name 'hallo})" "(macroexpand '(t {\:name 'hallo}))" "(symbol? 'hallo)" "(defn g\\n  []\\n  (let [a \\"asd\\"]\\n    (+ 1 a)))" "(g)" "(def x 12)" "(add-watch x \:re-bind (fn [key r old new] (println old \\" -> \\" new)))" "x" "(add-watch\\n  (var x)\\n  \:re-bind\\n  (fn [key r old new]\\n    (println old \\" - \\" new)))" "(def x 13)" "(defmacro def-watched [name & value]\\n  `(do\\n     (def ~name ~@value)\\n     (add-watch (var ~name)\\n                \:re-bind\\n                (fn [~'key ~'r old\# new\#]\\n                  (println old\# \\" - \\" new\#)))))" "(macroexpand '(def-watched x 14))" "(def-watched y 12)" "(def y 13)" "(defmacro t\\n  [map]\\n  `(let [~'a (\:name ~map)]\\n     (defn ~'a [s] (+ 1 1))))" "(t {\:name 'bla})" "(macroexpand '(t {\:name 'bla}))" "(defmacro t\\r\\n     [map]\\r\\n     `(let [~'a (\:name ~map)]\\r\\n        (defn ~a [s] (+ 1 1))))" "(macroexpand '(t {\:name 'bla}))" "(t {\:name 'bla})" "(defmacro t\\r\\n        [map]\\r\\n        `(let [~'a (\:name ~map)]\\r\\n           (defn a [s] (+ 1 1))))" "(macroexpand '(t {\:name a}))" "(let [a 'b]\\n  (defn a [s] (+ 1 1)))" "(a 1)" "(defmacro g\\n  []\\n  `(println \\"test\: \\" (\:name {\:name \\"Hans\\"})))" "(g)" "(defmacro g\\r\\n     []\\r\\n     `(println \\"test\: \\" ~(\:name {\:name \\"Hans\\"})))" "(g)" "(def x 12)" "(def t 12)" "t" "(def map {\:var t})" "(\:var map)" "(defmacro g\\n  [map]\\n  `(println \\"bla\: \\" (\:var ~map)))" "(g)" "(g map)" "(defmacro g\\r\\n     [map]\\r\\n     `(println \\"bla\: \\" ~(\:var ~map)))" "(g map)" "(defmacro g\\r\\n     [map]\\r\\n     `(println \\"bla\: \\" ~(\:var map)))" "(g map)" "(defmacro with [binding]\\n  `(let ~binding\\n     (println ~(binding 0))))" "(with [a \\"hallo\\"])" "([a b c] 1)" "([1 2 3] 1)" "(defmacro with [binding]\\r\\n     `(let ~binding\\r\\n        (println (~binding 0))))" "(with [a \\"bla\\"])" "(defmacro with [binding]\\r\\n     `(let ~binding\\r\\n        (println (binding 0))))" "(with [a \\"asd\\"])" "(list* 1 [1 2 3])" "(defmacro anym\\n  [fname args body]\\n  `(defn ~fname ~args ~@body))" "(anym bla [a b] (+ a b))" "(bla 1 2)" "(macroexpand '(anym bla [a b] (+ a b)))" "(fn [a b] (+ a b))" "(def a (fn [a b] (+ a b)))" "(a 1 3)" "(def a (fn ([a b] + a b)))" "(a 1 3)" "(defmacro anym\\r\\n     [fname args body]\\r\\n     `(defn ~fname ~args ~body))" "(anym bla [a b] (+ a b))" "(bla 1 2)" "(macroexpand '(anym bla [a b] (+ a b)))" "(flatten [1 2 3])" "`(~'bla ~@(1 2 3))" "(make rule)" "(def a (make rule))" "a" "(def a (eval (make rule)))" "(eval (make rule))" "(make rule)" "(eval (make rule))" "(def a (eval (make rule)))" "(run* [q] (a '(and x y) q))" "(list \\"(1 2 3)\\")" "(make rule)" "(seq \\"`(and ~a ~b)\\")" "(eval (quote 1))" "(quote 1)" "(quote and)" "and" "(eval (quote and))" "(eval '(quote and))" "(quote `())" "(\= '(and a b) ('and a b))" "(\= '(and a b) ('and 'a 'b))" "`(and ~a ~b)" "(quote `(and ~a ~b))" "(quote (and ~a ~b))" "'(and '~a '~b)" "'(quote (and ~a ~b))" "(def a (fn [and a] (fresh [b] (\=\= and `(and ~a ~b)))))" "(run* [q] (a '(and x y) q))" "(run* [q] (and-e-l '(and x y) q))" "(run 1 [q] (and-e-l '(and x y) q))" "(run* [q] (and-e-l '(and x y) q))" "(run 1 [q] (and-e-l '(and x y) q))" "(run* [q] (ande1o '(a & b) q))" "(run* [q] (ande1o q '(a & b)))" "(run* [q] (and-e-l '(and x y) q))" "(def a (fn [and a] (fresh [b] (\=\= and `(~'and ~a ~b)))))" "(run* [q] (a '(and x y) q))" "(t)" "(def f1 12)" "'(and `~f1)" "`(and ~f1)" "`(~'and ~f1)" "(quote `(~'and ~f1))" "(eval (quote `(~'and ~f1)))" "(t)" "(run* [q] ((eval (t)) '(and x y) q))" "(eval (t))" "(quote `(~a))" "(t)" "(eval (t))" "(def a (eval (t)))" "(run* [q] (a '(and x y) q))" "(run* [q] (a q '(and x y)))" "(t)" "(def a (eval (t)))" "(run* [q] (a '(and x y) q))" "(run* [q] (a q '(and x y)))" "a" "(def a (eval (t)))" "(run* [q] (a q '(and x y)))" "(t)" "(def a (eval (t)))" "(run* [q] (a '(and x y) q))" "(t)" "(def a (eval (t)))" "(run* [q] (a '(and x y) q))" "(def a (eval (t)))" "(run* [q] (a '(and x y) q))" "(t)" "(run* [q]\\n      ((fn [and a] (fresh [b]\\n                          (\=\= and `(~'and ~a ~b)))) '(and x y) q))" "(run* [q] ((t) '(and y x) q))" "(t)" "(def a '(fn [q] (+ 1 q)))" "((a) 4)" "(a 4)" "((eval a) 4)" "(run* [q] ((eval (t)) '(and x y) q))" "(t)" "(run* [q] (t '(and y x) q))" "(run* [q] ((t) '(and x y) q))" "(let [x 19]\\n  `~x)" "(run* [q] ((t) '(and x y) q))" "((h) 12)" "((g) 10)" "(g)" "((h) 10)" "(run* [q] ((t) '(and x y) q))" "(run* [q] ((t) '(and) q))" "(run* [q] ((t) 'and q))" "(run* [q] ((t) '(and) q))" "'(and a)" "'(and)" "(run* [q] ((t) '(and) q))" "(run* [q] ((t) '(and x y) q))" "(run* [q] ((t) '(and a b) q))" "(let [a 12]\\n  '(and `~x))" "(let [x 12]\\n  '(and ~x))" "(let [x 12]\\n  '(and ~`(~x)))" "(let [x 12]\\n  '(and ~`~x))" "(unquote 12)" "(let [x 'b]\\n  '(and ~`~x))" "(run* [q] ((t) '(and x y) q))" "(let [x 'a]\\n  (fn [x] `(~'and ~x)))" "((let [x 'a]\\r\\n  (fn [x] `(~'and ~x))) \\"we\\")" "(run* [q] ((t) '(and x y) q))" "(run* [q] ((t) q '(and x y)))" "(run* [q] ((t) '(and a b) q))" "((let [x 'a]\\n   (fn [x] (+ 10 a))) 12)" "(run* [q] ((t) '(and x y) q))" "(run* [q] ((t) '(and a b) q))" "(let [a '[a]]\\n  (fn a (* 1 a)))" "(run* [q] ((t) '(and a b) q))" "(run* [q] ((eval (g)) '(and a b) q))" "(run* [q] ((eval (g)) '(and a) q))" "(run* [q] ((eval (g)) 'true q))" "(run* [q] ((eval (g)) '(and a) q))" "(g)" "(run* [q] ((eval (m)) '(and) q))" "(run* [q] ((eval (m)) '(and a) q))" "(run* [q] ((eval (m)) '(and a b) q))" "(run* [q] ((eval (m)) '(and x c) q))" "(run* [q] ((eval (m)) '(and hj hj) q))" "(conj [1] [1 2])" "(concat [1] [1 2])" "(concat 12 [1 2 ])" "(contains? [4 5 6] 6)" "(contains? (seq [4 5 6]) 6)" "(seq [4 5 6])" "(use 'clojure.set)" "(intersection (set [1 2]) (set [3 2]))" "(vec \#{1 2})" "(flatten [1 2 3])" "(run* [q] ((eval (make rule)) '(and a b) q))" "rule" "(make rule)" "(first (\:operator rule))" "(doall (concat (\:operator rule) (\:result rule)))" "(make rule)" "(vec (doall (concat (\:operator rule) (\:result rule))))" "(same (\:arguments rule) (\:result rule))" "(make rule)" "(same (\:arguments rule) (\:result rule))" "(make rule)" "(vec (doall (concat (\:operator rule) (\:result rule))))" "(into [] (concat (\:operator rule) (\:result rule)))" "(make rule)" "(run* [q] ((eval (make rule)) '(and a b) q))" "(run* [q] ((eval (make rule)) '(and x h) q))" "(run* [q] ((eval (make rule)) q '(and a b)))" "(let [a [1 2 3]]\\n  `(~'hallo ~@a))" "`(~'and `(~'and))" "`(~'and `(~'and 12 13))" "(run* [q] (and-i 'x 'b q))" "(run* [q] (and-i q 'x 'b))" "(run* [q] (and-e-l q 'x))" "(run* [q] ((eval (make rule)) '(and f g) q))" "(run* [q] (and-i 'a 'b q))" "(run* [q] (and-i 'x 'h q))" "(run* [q] (or-i-l 'a q))" "(run* [q] (or-i-r 'x q))" "(with-meta [ \\"asd\\" (with-meta \\"fgh\\" {\:test 2})] {\:test 1})" "(with-meta 1 \\"asd\\")" "(wff? '(forall [x] (and (P x y) (exist [y] (Q y)))) \\n      {\:P [\:pred 2]\\n       \:Q [\:pred 1]})" "(use [\:clojure.strin \:as s])" "(use '[clojure.string \:as s])" "(str '(forall [x] (P x y)))" "(quote (forall (with-meta 'a {\:test 1})))" "(def a (with-meta '(bla) {\:t 1}))" "a" "(meta a)" "(meta (unquote 'a))" "(meta (eval 'a))" "(def f '(forall [y] (P y x)))" "f" "(run* [q] (and-e-l '(and (forall [x] (P x)) (Q c)) q))" "(wff? '(forall [x] (and (P x) (P2 x c))) s)" "(wff? '(forall [x] (and (P x) (P2 x c c))) s)" "(run* [q] (and-e-l '(and x y) q))" "(run* [q] (and-e-l q 'x))" "(run* [q] (and-i 'x 'y q))" "(run* [q] (and-i q 'y '(and x y)))" "(subform nil)" "(wff? '(and (and) (or)) s)" "(and)" "(or)" "(run* [q]\\n      (fresh [a b]\\n             (\=\= '(or x f) `(~'or ~a ~b))\\n             (\=\= q 1)))" "(run* [q]\\n      (fresh [a b]\\n             (\=\= '(or x g) `(~'or ~a ~b))\\n             (\=\= q 2)))" "(run* [q]\\r\\n         (fresh [a b]\\r\\n                (\=\= '(nor x g) `(~'or ~a ~b))\\r\\n                (\=\= q 2)))" "(run* [q] (or-e '(or a b) '(infer a the) '(infer b the) q))" "(run* [q] (impl-i '(infer h g) q))" "(run* [q] (impl-e 'a '(impl a g) q))" "(run* [q] (not-i '(infer g contradiction) q))" "(run* [q] (not-e 'a '(not a) q))" "(run* [q] (raa '(infer (not phi) contradiction) q))" "(run* [q] (raa '(infer (not phi) contradictio) q))" "(run* [q] (raa '(infer (not phi) contradiction) q))" "(run* [q] (efq 'contradiction q))" "(run* [q] (efq 'hjasd q))" "(run* [q] (equal-e '(\= f g) '(substitution \\n                               (forall [x] (P x))\\n                               g\\n                               x) q))" "(run* [q] (equal-e '(\= f g)\\n                   '(substitution\\n                      (forall [x] (P x))\\n                      f\\n                      x)\\n                   q))" "(run* [q] (forall-i '(infer (actual i) (substitution\\n                                         (P x)\\n                                         (actual i)\\n                                         x)) q))" "(run* [q] (forall-i '(infer (actual i) (substitution\\r\\n                                            (P x)\\r\\n                                            (actual i)\\r\\n                                            x)) q))" "(run* [q] (forall-e '(forall [y] (P y)) q))" "(run* [q] (exists-i '(substitution (P x) t x) q))" "(run* [q] (exists-e '(exists [z] (P z))\\n                    '(infer \\n                       [t\\n                       (substitution\\n                         (P z)\\n                         t\\n                         z)]\\n                       X) q))" "(first '[a b])" "(create-argument '(and a b))" "(create-args '[(or a b)\\r\\n               (infer a X)\\r\\n               (infer b X)])" "(con [1 2 3] 1)" "(conj [1 2 3] 3)" "(conj [1 2 3] 5)" "(create-args '[(or a b)\\r\\n                  (infer a X)\\r\\n                  (infer b X)])" "(rest [1 2 3])" "(t '[(or a b)\\r\\n                     (infer a X)\\r\\n                     (infer b X)])" "(create-args [(or a b)\\r\\n               (infer a X)\\r\\n               (infer b X)])" " (create-args '[(or a b)\\r\\n                  (infer a X)\\r\\n                  (infer b X)])" "(t '[(or a b)\\r\\n                     (infer a X)\\r\\n                     (infer b X)])" "(t '[(or a b)\\r\\n                        (infer a X)\\r\\n                        (infer b X)])" "(g '[or and])" "(g '[or and with])" "(g '[and or infer])" "(create-args '[(or a b)\\r\\n               (infer a X)\\r\\n               (infer b X)])" "(frequencies '[(or a b)\\r\\n               (infer a X)\\r\\n               (infer b X)])" "(frequencies (map \#(create-arg %) '[(or a b)\\r\\n               (infer a X)\\r\\n               (infer b X)]))" "(create-body '[(or a b)\\r\\n               (infer a X)\\r\\n               (infer b X)])" "(create-body '[(or a b)\\r\\n                  (infer a X)\\r\\n                  (infer b X)])" "`(~'bla `(~'bla))" "keywords" "(m)" "(run* [q] ((eval (m)) '(and a g) q))" "(create-g '(or a b))" "(create-g '(or a contradiction))" "`(~'or ~a ~b)" "``(~'or ~a ~b)" "(m)" "``(~'or ~~a ~~b)" "(create-g '(or a))" "(defn h [q]\\n  (fresh []\\n         (\=\= q 12)))" "(run* [q] (h q))" "`(~'and (for [x (range 1 4)] x))" "`(~'and ~(for [x (range 1 4)] x))" "(create-g '[a b] '[(a bla) (b blub)])" "(c 'a '(or a b))" "(concat '(or) '(a) '(b))" "(m)" "(c 'a '(or a))" "`(a ~'b)" "(symbol \\"~'and\\")" "(c 'a '(or a))" "(c 'a '(or and))" "(m)" "(b 'or a b)" "(b '(or a b))" "(m)" "`(seq (concat (list (quote a)) (list (quote b))))" "`(seq (concat (list (quote (quote a))) (list (quote (quote b)))))" "`(seq (concat (list 'a)))" "`(seq (concat (list ~a)))" "`(seq (concat (list (quote \\"a\\"))))" "(quote \\"a\\")" "`(seq (concat (list (quote ~'a))))" "`(list ~'a)" "(b '(or a b))" "(m)" "(conj '((a) (b)) 'concat)" "(let [m (map \#(list 'list %) '(a b))]\\n  m)" "(let [m (map \#(list 'list %) '(a b))]\\r\\n     (conj m 'concat))" "(defn a\\n  [given]\\n  (let [m (map \#(list 'list %) (rest given))]\\n    (conj m 'concat)))" "(a '(or a b))" "(defn b\\n [given]\\n (let [m (a given)]\\n   `(~(first given) ~m)))" "(b '(or a b))" "m" "(m)" "(def c\\n  [given]\\n  (let [m (map \#(list 'list %) (rest given))\\n        m1 (concat m (list 'list (list 'quote (first given))))]\\n    m1))" "(defn c\\r\\n     [given]\\r\\n     (let [m (map \#(list 'list %) (rest given))\\r\\n           m1 (concat m (list 'list (list 'quote (first given))))]\\r\\n       m1))" "(c '(or a b))" "(defn c\\r\\n     [given]\\r\\n     (let [m (map \#(list 'list %) (rest given))\\r\\n           op (list 'quote (first given))\\n           op1 (list 'list op)]\\r\\n       op1))" "(c '(or a b))" "(defn c\\r\\n     [given]\\r\\n     (let [m (map \#(list 'list %) (rest given))\\r\\n           op (list 'quote (first given))\\r\\n           op1 (list 'list op)\\n           res (concat op1 m)]\\r\\n       res))" "(c '(or a b))" "(defn c\\r\\n     [given]\\r\\n     (let [m (map \#(list 'list %) (rest given))\\r\\n           op (list 'quote (first given))\\r\\n           op1 (list 'list op)\\r\\n           res (concat op1 m)]\\r\\n       op1))" "(c '(or a b))" "(defn c\\r\\n     [given]\\r\\n     (let [m (map \#(list 'list %) (rest given))\\r\\n           op (list 'quote (first given))\\r\\n           op1 (list 'list op)\\r\\n           res (concat (list op1) m)]\\r\\n       res))" "(c '(or a b))" "(defn c\\r\\n     [given]\\r\\n     (let [m (map \#(list 'list %) (rest given))\\r\\n           op (list 'quote (first given))\\r\\n           op1 (list 'list op)\\r\\n           res (concat (list op1) m)\\n           res1 (concat res 'concat)\\n           res2 (concat res1 'seq)]\\r\\n       res2))" "(c '(or a b))" "(defn c\\r\\n     [given]\\r\\n     (let [m (map \#(list 'list %) (rest given))\\r\\n           op (list 'quote (first given))\\r\\n           op1 (list 'list op)\\r\\n           res (concat (list op1) m)\\r\\n           res1 (concat res (list 'concat))\\r\\n           res2 (concat res1 (list 'seq))]\\r\\n       res2))" "(c '(or a b))" "(defn c\\r\\n     [given]\\r\\n     (let [m (map \#(list 'list %) (rest given))\\r\\n           op (list 'quote (first given))\\r\\n           op1 (list 'list op)\\r\\n           res (conj op1 m)]\\r\\n       res))" "(c '(or a b))" "(defn c\\r\\n     [given]\\r\\n     (let [m (map \#(list 'list %) (rest given))\\r\\n           op (list 'quote (first given))\\r\\n           op1 (list 'list op)\\r\\n           res (concat (list op1) m)\\r\\n           res1 (concat res (list 'concat))\\r\\n           res2 (concat res1 (list 'seq))]\\r\\n       res2))" "(c '(or a b))" "(conj '((a) (b)) 'concat)" "(defn c\\r\\n     [given]\\r\\n     (let [m (map \#(list 'list %) (rest given))\\r\\n           op (list 'quote (first given))\\r\\n           op1 (list 'list op)\\r\\n           res (concat (list op1) m)\\r\\n           res1 (conj res 'concat)]\\r\\n       res1))" "(c '(or a b))" "(defn c\\r\\n     [given]\\r\\n     (let [m (map \#(list 'list %) (rest given))\\r\\n           op (list 'quote (first given))\\r\\n           op1 (list 'list op)\\r\\n           res (concat (list op1) m)\\r\\n           res1 (conj res 'concat)\\r\\n           res2 (conj res1 'seq)]\\r\\n       res2))" "(c '(or a b))" "(defn c\\r\\n     [given]\\r\\n     (let [m (map \#(list 'list %) (rest given))\\r\\n           op (list 'quote (first given))\\r\\n           op1 (list 'list op)\\r\\n           res (concat (list op1) m)\\r\\n           res1 (conj res 'concat)\\r\\n           res2 (conj (list res1) 'seq)]\\r\\n       res2))" "(c '(or a b))" "(defn c\\r\\n     [given]\\r\\n     (let [m (map \#(list 'list %) (rest given))\\r\\n           op (list 'quote (first given))\\r\\n           op1 (list 'list op)\\r\\n           res (concat (list op1) m)\\r\\n           res1 (conj res 'concat)\\r\\n           res2 (conj (list res1) 'seq)]\\r\\n       res2))" "(defn b\\n  [arg]\\n  `(\=\= ~arg ~(c '(or a b))))" "(b 'a)" "(run* [q] (b q))" "(m)" "`(~(c '(or a b)))" "`(seq 'a 'b)" "(defn c\\r\\n        [given]\\r\\n        (let [m (map \#(list 'list %) (rest given))\\r\\n              op (list 'quote (first given))\\r\\n              op1 (list 'list op)\\r\\n              res (concat (list op1) m)\\r\\n              res1 (conj res `concat)\\r\\n              res2 (conj (list res1) `seq)]\\r\\n          res2))" "(c '(or a b))" "(defn c\\r\\n        [given]\\r\\n        (let [m (map \#(list 'list %) (rest given))\\r\\n              op (list `quote (first given))\\r\\n              op1 (list `list op)\\r\\n              res (concat (list op1) m)\\r\\n              res1 (conj res `concat)\\r\\n              res2 (conj (list res1) `seq)]\\r\\n          res2))" "(c '(or a b))" "(defn c\\r\\n        [given]\\r\\n        (let [m (map \#(list `list %) (rest given))\\r\\n              op (list `quote (first given))\\r\\n              op1 (list `list op)\\r\\n              res (concat (list op1) m)\\r\\n              res1 (conj res `concat)\\r\\n              res2 (conj (list res1) `seq)]\\r\\n          res2))" "(c '(or a b))" "(m)" "(b 'a)" "(run* [q] (b q))" "(defn c\\r\\n        [given]\\r\\n        (let [m (map \#(list `list %) (rest given))\\r\\n              op (list `quote (first given))\\r\\n              op1 (list `list op)\\r\\n              res (concat (list op1) m)\\r\\n              res1 (conj res `concat)\\r\\n              res2 (conj (list res1) `seq)]\\r\\n          res2))" "(defn b\\n  [q]\\n  `(\=\= ~q ~(c '(or a b))))" "(run* [q] (b q))" "(run* [q] ((eval (b q))))" "(defn b\\n  []\\n  `(fn [~'q]\\n     (\=\= ~'q ~(c '(or a b)))))" "(run* [q] ((eval (b)) q))" "(defn b\\n  []\\n  `(fn [~'q]\\n     (fresh [~'a ~'b]\\n            (\=\= ~'q ~(c '(or a b))))))" "(run* [q] ((eval (b)) q))" "(defn c\\r\\n        [given]\\r\\n        (let [m (map \#(list `list %) (rest given))\\r\\n              op (list `quote (first given))\\r\\n              op1 (list `list op)\\r\\n              res (concat (list op1) m)\\r\\n              res1 (conj res `concat)\\r\\n              res2 (conj (list res1) `seq)]\\r\\n          res2))" "(defn b\\n  [arg form]\\n  `(\=\= ~arg ~(c form)))" "(b 'or1 '(or a b))" "(f '[(and a b)])" "(f '[(and a b)] '[a])" "(q '[a])" "(q '[(and a b)])" "(c '(and a b))" "(defn bla^" "`(\=\= ~'q ~(c '(and a b)))" "(c 'a)" "(create-term 'a)" "`(\=\= ~'a ~(create-term 'a))" "`(\=\= ~'q ~(create-term '(and a b)))" "`(\=\= ~'q (create-term 'a))" "`(\=\= ~'q ~(create-term 'a))" "(create-result '[a])" "(f '[(and a b)] '[a])" "(create-body 'and1 '(and a b))" "(f '[(and a b)] '[a])" "(f '[(and a b)])" "(f '(and a b))" "(f '[(and a b)])" "(f '[(or a b)\\r\\n               (infer a X)\\r\\n               (infer b X)])" "(f '[(and a b)] '[a])" "(list (create-result '[a]))" "(f '[(and a b)] '[a])" "(conj [1 2 3] [ 3 45])" "(concat [1 3 4] [4 56])" "(create-fresh-args '[(or a b)\\r\\n               (infer a X)\\r\\n               (infer b X)] '[X])" "(create-fresh-args '[(or a b)\\r\\n                  (infer a X)\\r\\n                  (infer b X)] '[X])" "(concat [] 'a)" "(concat [] ['a])" "(create-fresh-args '[(or a b)\\r\\n                     (infer a X)\\r\\n                     (infer b X)] '[X])" "(f '[(or a b)\\r\\n               (infer a X)\\r\\n               (infer b X)] '[X])" "(f '[(or a b)\\r\\n                  (infer a X)\\r\\n                  (infer b X)] '[X])" "(run* [q] ((f '[(or a b)\\r\\n                  (infer a X)\\r\\n                  (infer b X)] '[X]) '(or x v) '(infer x G) '(infer v G) q))" "((f '[(or a b)\\r\\n                  (infer a X)\\r\\n                  (infer b X)] '[X]) )" "(f '[(or a b)\\r\\n                  (infer a X)\\r\\n                  (infer b X)] '[X])" "(f '[a b] '[(and a b)])" "(f '[(and a b)] '[a])" "(run* [q] ((eval (f '[(and a b)] '[a])) '(and g b) q))" "(run* [q] ((eval (f '[(or a b)\\r\\n                     (infer a X)\\r\\n                     (infer b X)] '[X])) '(or x v) '(infer x G) '(infer v G) q))" "(f '[a b] '[(and a b)])" "(create-args '[a b])" "(map \#(create-body %1 %2) '[a1 b2] '[a b])" "(empty? (map \#(create-body %1 %2) '[a1 b2] '[a b]))" "(empty? (flatten (map \#(create-body %1 %2) '[a1 b2] '[a b])))" "(list (create-result '[(and a b)]))" "(concat (map \#(create-body %1 %2) '[a1 b2] '[a b]) (list (create-result '[(and a b)])))" "(remove \#(empty? %) (map \#(create-body %1 %2) '[a1 b2] '[a b]))" "(concat () (list (create-result '[(and a b)])))" "(f '[a b] '[(and a b)])" "(def given '[a b])" "(def conc '[(and a b)])" "(create-args given)" "(remove \#(empty? %) (map \#(create-body %1 %2) args given))" "(remove \#(empty? %) (map \#(create-body %1 %2) '[a1 b2] given))" "(list (create-result conc))" "(concat (remove \#(empty? %) (map \#(create-body %1 %2) '[a1 b2] given)) (list (create-result conc)))" "(def ggg (concat (remove \#(empty? %) (map \#(create-body %1 %2) '[a1 b2] given)) (list (create-result conc))))" "(conj ggg (create-fresh-args given conc) `fresh)" "(create-fresh-args given conc)" "(reduce \#(concat %1 (if (symbol? %2)\\r\\n                         [%2]\\r\\n                         (rest %2))) [] given)" "(reduce \#(concat %1 (if (symbol %2)\\r\\n                                    [%2]\\r\\n                                    (rest %2))) [] conc)" "(reduce \#(concat %1 (if (symbol? %2)\\r\\n                                    [%2]\\r\\n                                    (rest %2))) [] conc)" "(f '[a b] '[(and a b)])" "(run* [q] ((eval (f '[a b] '[(and a b)])) 'a 'h q))" "(f '[a b] '[(and a b)])" "(run* [q] ((eval (clojure.core/fn [a b q] (clojure.core.logic/fresh [] (clojure.core.logic/\=\= q (clojure.core/seq (clojure.core/concat (clojure.core/list (quote and)) (clojure.core/list a) (clojure.core/list b))))))\\n                  ) 'h 'b q))" "(symbol 'a)" "(symbol 'and 4)" "(list `quote (first given))" "(list (list `quote (first [1 2 3])))" "(list `list (list `quote (first [1 2 3 ])))" "(list `list `quote (first (1 2 3)))" "(list `list `quote (first [1 2 3]))" "(gen-term '[(or a b)])" "(map \#(list `list %) (rest '(or a b)))" "(list `list (list `quote (first '(or a b))))" "(concat '(clojure.core/list (quote or)) '((clojure.core/list (quote (or a b)))))" "(gen-term '(or a d))" "(gen-term '(and or a))" "(gen-term '(or a b))" "(concat '(or) '(a) '(b))" "(gen-term '(or a b))" "(gen-logic-function '[a b] '[(and a b)])" "(gen-logic-function '[(and a b)] '[a])" " (gen-logic-function '[(and a b)] '[a])" "(gen-logic-function '[(and a b)] '[a])" "(run* [q] ((eval (gen-logic-function '[(and a b)] '[a])) '(and z t) q))" "(run* [q] ((eval (gen-logic-function '[a (impl a b)] '[b])) 'g '(impl g h) q))" "(run* [q] ((eval (gen-logic-function '[(infer a contradiction)] '[(not a)])) '(infer g contradiction) q))" "(run* [q] ((eval (gen-logic-function '[a (not a)] '[contradiction])) 'g '(not g) q))" "(run* [q] ((eval (gen-logic-function '[a b] '[(and a b)])) 'g '(not g) q))" "(run* [q] ((eval (gen-logic-function '[a b] '[(and a b)])) 'a 'b q))" "(gen-logic-function '[a b] '[(and a b)])" "(run* [q] ((eval (gen-logic-function '[(and a b)])) '(and a b) q))" "(run* [q] ((eval (gen-logic-function '[(and a b)] '[a])) '(and a b) q))" "(run* [q] ((eval (gen-logic-function '[(and a b)] '[b])) '(and a b) q))" "(run* [q] ((eval (gen-logic-function '[a] '[(or a b)])) 'a q))" "(gen-logic-function '[a] '[(or a b)])" "(apply vector \#{a b})" "(apply vector \#{1 2})" "(gen-logic-function '[a] '[(or a b)])" "(run* [q] ((eval (gen-logic-function '[a] '[(or a b)])) 'a q))" "(run* [q] ((eval (gen-logic-function '[a b] '[(and a b)])) 'f 'g q))" "(run* [q] ((eval (make-rule {\:name \\"and-i\\"\\r\\n \:given      '[a b]\\r\\n \:conclusion '[(and a b)]})) 'g 'h q))" "(run* [q] ((eval (make-rule {\:name \\"and-e1\\"\\r\\n \:given      '[(and a b)]\\r\\n \:conclusion '[a]})) '(and e r) q))" "(run* [q] ((eval (make-rule {\:name \\"and-e2\\"\\r\\n \:given      '[(and a b)]\\r\\n \:conclusion '[b]})) '(and e r) q))" "(run* [q] ((eval (make-rule {\:name \\"or-i1\\"\\r\\n \:given      '[a]\\r\\n \:conclusion '[(or a b)]})) 'k q))" "(run* [q] ((eval (make-rule {\:name \\"or-i2\\"\\r\\n \:given      '[a]\\r\\n \:conclusion '[(or b a)]})) 'k q))" "(run* [q] ((eval (make-rule {\:name \\"or-e\\"\\r\\n \:given      '[(or a b)\\r\\n               (infer a X)\\r\\n               (infer b X)]\\r\\n \:conclusion '[X]})) '(or a g) '(infer a b) '(infer g b) q))" "(run* [q] ((eval (make-rule {\:name \\"impl-i\\"\\r\\n \:given      '[(infer a b)]\\r\\n \:conclusion '[(impl a b)]})) '(infer g h) q))" "(run* [q] ((eval (make-rule {\:name \\"impl-e\\"\\r\\n \:given      '[a (impl a b)]\\r\\n \:conclusion '[b]})) 'a '(impl a g) q))" "(run* [q] ((eval (make-rule {\:name \\"not-i\\"\\r\\n \:given      '[(infer a contradiction)]\\r\\n \:conclusion '[(not a)]})) '(infer g contradiction) q))" "(run* [q] ((eval (make-rule {\:name \\"not-e\\"\\r\\n \:given      '[a (not a)]\\r\\n \:conclusion '[contradiction]})) 'g '(not g) q))" "(run* [q] ((eval (make-rule {\:name \\"raa\\"\\r\\n \:given      '[(infer (not a) contradiction)]\\r\\n \:conclusion '[a]})) '(infer (not f) contradiction) q))" "(run* [q] ((eval (make-rule {\:name \\"efq\\"\\r\\n \:given      '[contradiction]\\r\\n \:conclusion '[a]})) 'contradiction q))" "(run* [q] ((eval (make-rule {\:name \\"equal-i\\"\\r\\n \:given      '[]\\r\\n \:conclusion '[(\= t t)]}))  q))" "(run* [q] ((eval (make-rule {\:name \\"equal-e\\"\\r\\n \:given      '[(\= a b)\\r\\n               (substitution phi a x)]\\r\\n \:conclusion '[(substitution phi b x)]})) '(\= e f) '(substitution (forall [x] (P x)) e x) q))" "(run* [q] ((eval (make-rule {\:name \\"forall-i\\"\\r\\n \:given      '[(infer (actual x0)\\r\\n                      (substitution phi x0 x))]\\r\\n \:conclusion '[(forall [x] phi)]})) '(infer (actual g) (substitution (forall [x] (P x)) g x)) q))" "(run* [q] ((eval (make-rule {\:name \\"forall-e\\"\\r\\n \:given      '[(forall [x] phi)]\\r\\n \:conclusion '[(substitution phi t x)]})) '(forall [x] (P x)) q))" "(run* [q] ((eval (make-rule {\:name \\"exists-i\\"\\r\\n \:given      '[(substitution phi t x)]\\r\\n \:conclusion '[(exists [x] phi)]})) '(substitution (P x) f x) q))" "(run* [q] ((eval (make-rule {\:name \\"exists-e\\"\\r\\n \:given      '[(exists [x] phi)\\r\\n               (infer [(actual x0)\\r\\n                       (substitution phi x0 x)]\\r\\n                      X)]\\r\\n \:conclusion '[X]})) '(exists [x] (P x)) '(infer [(actual g)\\n                                                  (substitution (P x) g x)]\\n                                                 T) q))" "(gen-result '[contradiction])" "(gen-logic-function '[(infer a contradiction)] '[(not a)])" "(list `list (list `quote arg))" "(def arg a)" "(def arg 'a)" "(list `list (list `quote arg))" "(get-term-arg '(not a))" "(run* [q] ((eval (make-rule {\:name \\"not-e\\"\\r\\n \:given      '[a (not a)]\\r\\n \:conclusion '[contradiction]})) 'a '(not a) q))" "(gen-logic-function '[a (not a)] '[contradiction])" "(run* [q] ((eval (gen-logic-function '[a (not a)] '[contradiction])) 'a '(not a) q))" "(run* [q] ((eval (gen-logic-function '[(and a b)] '[a])) q '(and a b)))" "(defn and-e-l\\r\\n  [and q]\\r\\n  (fresh [b]\\r\\n         (\=\= and `(~'and ~q ~b))))" "(run* [q] (and-e-l q '(and a b)))" "(defn and-i\\r\\n  [a b q]\\r\\n  (\=\= q `(~'and ~a ~b)))" "(run* [q] (and-i 'a q 'b))"]
eclipse.preferences.version=1
