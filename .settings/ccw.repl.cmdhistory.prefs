cmdhistory=["(rename-var 'V6 'v)" "(step-f \\"always-e\\" 9 3)" "(step-f \\"rule-2\\" 10)" "(proof '(at x (impl (asap (not a)) (not (asap a)))))" "(step-b \\"impl-i\\" 2)" "(step-f \\"asap-e\\" 1)" "(rename-var 'V1 'x1)" "(step-b \\"not-e\\" 4)" "(step-b \\"not-i\\" 4)" "(rename-var 'V2 'x1)" "(rename-var 'V3 'a)" "(step-b \\"and-i\\" 5)" "(step-f \\"not-e\\" 3)" "(step-f \\"asap-e\\" 4)" "(rename-var 'V4 'x1)" "(deduction-playground.read-rules/export-theorem\\n  \\"resources/theorems.clj\\"\\n  @p\\n  \\"teo-5\\")" "(proof '(at x (and (always (impl a (asap a))) a))\\n       '(at x (always a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'x)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(step-f \\"and-e1\\" 1)" "(step-f \\"and-e2\\" 1)" "(step-f \\"temporal-7\\" 4)" "(step-f \\"temporal-9\\" 5)" "(step-f \\"c1\\")" "(rename-var 'V3 'x)" "(rename-var 'V4 'a)" "(step-f \\"generalisation\\" 7)" "(step-b \\"impl-e\\" 10)" "(rename-var 'V5 '(until true (not a)))" "(step-b \\"until-e\\" 10)" "(step-b \\"always-i\\" 10)" "(rename-var 'V6 'v)" "(step-f \\"always-e\\" 9 3)" "(step-f \\"rule-2\\" 10)" "(step-f \\"teo-5\\")" "(rename-var 'V7 'v)" "(rename-var 'V8 'a)" "(step-f \\"rule-3\\" 11 12)" "(proof '(at x (impl (and true (asap (not a))) (asap (not a)))))" "(step-b \\"impl-i\\" 2)" "(classical 1)" "(deduction-playground.read-rules/export-theorem\\n  \\"resources/theorems.clj\\"\\n  @p\\n  \\"teo-4\\")" "(proof '(at x (and (always (impl a (asap a))) a))\\n       '(at x (always a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'x)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(step-f \\"and-e1\\" 1)" "(step-f \\"and-e2\\" 1)" "(step-f \\"temporal-7\\" 4)" "(step-f \\"temporal-9\\" 5)" "(step-f \\"c1\\")" "(rename-var 'V3 'x)" "(rename-var 'V4 'a)" "(step-f \\"generalisation\\" 7)" "(step-b \\"impl-e\\" 10)" "(rename-var 'V5 '(until true (not a)))" "(step-b \\"until-e\\" 10)" "(step-b \\"always-i\\" 10)" "(rename-var 'V6 'v)" "(step-f \\"always-e\\" 3 9)" "(step-f \\"rule-2\\" 10)" "(step-f \\"teo-5\\")" "(rename-var 'V7 'v)" "(rename-var 'V8 'a)" "(step-f \\"rule-3\\" 11 12)" "(step-f \\"teo-4\\")" "(rename-var 'V9 'v)" "(rename-var 'V10 'a)" "(step-f \\"rule-3\\" 13 14)" "(proof '(at x (impl (and a (asap false)) false)))" "(classical 2)" "(deduction-playground.read-rules/export-theorem\\n  \\"resources/theorems.clj\\"\\n  @p\\n  \\"c8-1\\")" "(proof '(at x (impl false false)))" "(classical 2)" "(deduction-playground.read-rules/export-theorem\\n  \\"resources/theorems.clj\\"\\n  @p\\n  \\"c8-2\\")" "(proof '(at x (until a false))\\n       '(at x false))" "(step-b \\"impl-e\\" 3)" "(rename-var 'V1 '(until a false))" "(step-b \\"impl-i\\" 3)" "(undo)" "(step-b \\"until-e\\" 3)" "(step-f \\"c8-2\\")" "(rename-var 'V2 'x)" "(step-f \\"generalisation\\" 2)" "(step-f \\"c8-1\\")" "(rename-var 'V3 'x)" "(rename-var 'V4 'a)" "(proof '(and a b) '(and b a))" "(proof '(at x (and a b)) '(at x (and b a)))" "(step-f \\"and-e1\\" 1)" "(step-f \\"and-e2\\" 1)" "(step-f \\"and-i\\" 2 3)" "(choose-option 4 2)" "(export-theorem\\n  \\"resources/theorems.clj\\"\\n  \\"test1\\")" "(proof '(at x (and a b)) '(at x (and b a)))" "(step-f \\"test-1\\" 1^)" "(step-f \\"test-1\\" 1)" "(step-f \\"test1\\" 1)" "(read/@theorems)" "(deref read/theorems)" "(proof '(at x (and a b)) '(at x (and b a)))" "(step-f \\"and-e1\\" 1)" "(step-f \\"and-e2\\" 1)" "(step-f \\"and-i\\" 2 3)" "(choose-option 4 2)" "(export-theorem\\n  \\"resources/theorems.clj\\"\\n  \\"test2\\")" "(proof '(at x (and d f)) '(at x (and f d)))" "(step-f \\"test2\\" 1)" "(proof '(at x (and a b)) '(at x (and b a)))" "(step-f \\"and-e1\\" 1)" "(step-f \\"and-e2\\" 1)" "(step-f \\"and-i\\" 3 2)" "(choose-option 4 1)" "(proof '(at x (sometimes a))\\n       '(at x (until true a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'y)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(step-f \\"sometimes-e\\" 1)" "(rename-var 'V3 'y)" "(step-f \\"not-until\\" 4)" "(classical 5)" "(proof '(at x (not (until true a)))\\n       '(at x false))" "(classical 1)" "(proof '(and false true) \\n       'a )" "(classical 1)" "(proof '(and false true) 'a)" "(classical 1)" "(proof '(impl (or false a) (and true a)))" "(proof '(impl (or false a) (and true a))\\n       'a)" "(classical 1)" "(proof '(at x (and a e)) '(at x (and e a)))" "(step-f \\"and-e1\\" 1)" "(step-f \\"and-e2\\" 1)" "(step-f \\"and-i\\"  2 3)" "(choose-option 4 2)" "(export-theorem \\"resources/theorems-clj\\"\\n                \\"blabla\\")" "(export-theorem \\"resources/theorems.clj\\"\\r\\n                   \\"blabla\\")" "(clojure.java.io/writer\\n  \\"resources/theorems-clj\\")" "(.exists (clojure.java.io/as-file \\"resources/theorems-clj\\"))" "(.exists (clojure.java.io/as-file \\"resources/theorems\\"))" "(.exists (clojure.java.io/as-file \\"resources/theoremsasdasd\\"))" "(export-theorem \\"resources/bla.clj\\" \\"bla\\")" "(.exists (clojure.java.io/as-file \\"resources/cla.clj\\"))" "(read/read-rules \\"bla.clj\\")" "(export-theorem \\"bla.clj\\" \\"bla\\")" "(export-theorem \\"bla.clj\\" \\"cla\\")" "(proof '(at x a) '(at x (always a)))" "(step-b \\"always-i\\" 3)" "(rename-var 'V1 'x)" "(proof '[(impl a b) (not b)]\\n       '(not a))" "(step-b \\"not-i\\" 4)" "(proof '[(impl a b) (not b)]\\n       '(not a))" "(step-b \\"not-i\\" 4)" "(step-f \\"impl-e\\" 1 3)" "(step-f \\"not-e\\" 2 4)" "(export-theorem\\n  \\"resource/theorems.clj\\"\\n  \\"modus-tollens\\")" "(export-theorem\\r\\n     \\"resources/theorems.clj\\"\\r\\n     \\"modus-tollens\\")" "(proof '(impl p q)\\n       '(impl (not q) (not p)))" "(step-b \\"impl-i\\" 3)" "(step-f \\"modus-tollens\\" 1 2)" "(undo)" "(proof '(and true a))" "(classical 2)" "(proof '(and true a)\\n       'a)" "(classical 1)" "(proof '(and true a) 'b)" "(classical 1)" "(proof '(impl (and true a) (or false b))\\n       'b)" "(classical 1)" "(undo)" "(classical 1)" "(undo)" "(classical 3)" "(classical 1)" "(classical 4)" "(proof '(at x (impl (asap false) false))\\n       '(at x a))" "(classical 1)" "(undo)" "(classical 1)" "(proof '(at x (impl false false)))" "(classical 2)" "(proof '(and true a))" "(classical 2)" "(symbol? true)" "(classical 2)" "(show)" "@p" "(proof '(and true a))" "(classical 2)" "@p" "(proof '(and true a))" "(classical 2)" "@p" "(proof '(and true a))" "(classical 2)" "(proof '(at x (impl false true)))" "(classical 2)" "(proof '(and false a)\\n       'false)" "(classical 1)" "(proof '(and (impl false false) a))" "(classical 2)" "(proof '(impl a b))" "(step-b \\"impl-i\\" 2)" "(proof 'a \\n       '(and b c))" "(step-b \\"and-i\\" 3)" "(undo)" "(step-b \\"or-e\\" 3)" "(proof '(and (impl false false) a)\\n       'b)" "(classical 1)" "(def a [{\:id 1 \:body a \:rule \:premise}\\n        {\:id 2 \:body a \:rule \\"rule1\\"}\\n        [{\:id 3 \:body a \:rule \:assumption}\\n         {\:id 4 \:body \:todo \:rule nil}\\n         {\:id 5 \:body a \:rule nil}]\\n        {\:id 6 \:body a \:rule nil}])" "a" "(def a '[{\:id 1 \:body a \:rule \:premise}\\r\\n           {\:id 2 \:body a \:rule \\"rule1\\"}\\r\\n           [{\:id 3 \:body a \:rule \:assumption}\\r\\n            {\:id 4 \:body \:todo \:rule nil}\\r\\n            {\:id 5 \:body a \:rule nil}]\\r\\n           {\:id 6 \:body a \:rule nil}])" "a" "(remove-duplicates1 a)" "(map \:id (filter (set sub) (remove \:rule equals)))" "(remove-duplicates1 a)" "a" "(remove-duplicates1 a)" "a" "(remove-duplicates1 a)" "(clojure.set/union \#{{\:id 6, \:body a, \:rule nil}}\\r\\n\#{{\:id 5, \:body a, \:rule nil}})" "a" "(def a '[{\:id 1, \:body b, \:rule \:premise} \\n         {\:id 2, \:body b, \:rule \\"rule1\\"} \\n         [{\:id 3, \:body b, \:rule \:assumption} \\n          {\:id 4, \:body \:todo, \:rule nil} \\n          {\:id 5, \:body b, \:rule nil}] \\n         {\:id 6, \:body b, \:rule nil}])" "(remove-duplicates1 a)" "(clojure.set/union \#{{\:id 6, \:body b, \:rule nil}}\\r\\n\#{{\:id 5, \:body b, \:rule nil}})" "(remove-duplicates1 a)" "(find-duplicates1 a)" "a" "(find-duplicates1 a)" "(remove-duplicates a)" "(find-duplicates1 a)" "a" "(remove-duplicates1 a)" "(def b '[{\:id 1 \:body a \:premise}\\n         [{\:id 4 \:body a \:rule \:assumption}\\r\\n          {\:id 5 \:body \:todo \:rule nil}\\r\\n          {\:id 6 \:body b \:rule nil}]\\n         {\:id 2 \:body \:todo \:rule nil}\\n         {\:id 3 \:body a \:rule nil}\\n         {\:id 7 \:body b \:rule \\"bla ([4 6] 3)\\"}])" "(def b '[{\:id 1 \:body a \:rule \:premise}\\r\\n         [{\:id 4 \:body a \:rule \:assumption}\\r\\n          {\:id 5 \:body \:todo \:rule nil}\\r\\n          {\:id 6 \:body b \:rule nil}]\\r\\n         {\:id 2 \:body \:todo \:rule nil}\\r\\n         {\:id 3 \:body a \:rule nil}\\r\\n         {\:id 7 \:body b \:rule \\"bla ([4 6] 3)\\"}])" "(remove-duplicates1 b)" "(remove-duplicates1 a)" "(remove-duplicates1 b)" "b" "(remove-duplicates1 b)" "(deduction-playground.proof-new/check-duplicates\\n  (-> (proof '[(impl p q) (impl r s)]\\r\\n                   '(impl (or p r) (or q s)))\\r\\n          (step-b \\"impl-i\\" 4)\\r\\n          (step-b \\"or-e\\" 5 3)\\r\\n          (choose-option 5 1)\\r\\n          (step-f \\"impl-e\\" 2 4)\\r\\n          (step-f \\"or-i2\\" 5)\\r\\n          (rename-var 'V1 'q)))" "(def a (-> (proof '[(impl p q) (impl r s)]\\r\\n                   '(impl (or p r) (or q s)))\\r\\n          (step-b \\"impl-i\\" 4)\\r\\n          (step-b \\"or-e\\" 5 3)\\r\\n          (choose-option 5 1)\\r\\n          (step-f \\"impl-e\\" 2 4)\\r\\n          (step-f \\"or-i2\\" 5)\\r\\n          (rename-var 'V1 'q)))" "(deduction-playground.proof-new/check-duplicates\\n  a)" "(deduction-playground.proof-new/check-duplicates a)" "(merge nil {\:a 1})" "(deduction-playground.proof-new/check-duplicates a)" "(symbol? (first '(a b c)))" "(symbol? '(and a b))" "(meta (-> (proof '[(impl a b) (not b)] '(not a))\\r\\n          (step-b \\"not-i\\" 4)\\r\\n          (step-f \\"impl-e\\" 1 3)\\r\\n          (step-f \\"not-e\\" 2 4)))" "(meta (-> (proof '[(impl a b) (not b)] '(not a))\\r\\n             (step-b \\"not-i\\" 4)\\r\\n             (step-f \\"impl-e\\" 1 3)\\r\\n             (step-f \\"not-e\\" 2 4)))" "(meta (-> (proof '[(impl a b) (not b)] '(not a))\\r\\n                (step-b \\"not-i\\" 4)\\r\\n                (step-f \\"impl-e\\" 1 3)\\r\\n                (step-f \\"not-e\\" 2 4)))" "(meta (-> (proof 'p '(not (not p)))\\r\\n          (step-b \\"not-i\\" 3)\\r\\n          (step-f \\"not-e\\" 1 2)))" "(meta (-> (proof '[(impl p q) (not q)] '(not p))\\r\\n          (step-b \\"not-i\\" 4)\\r\\n          (step-f \\"impl-e\\" 1 3)\\r\\n          (step-f \\"not-e\\" 2 4)))" "(meta (-> (proof '(or p (not p)))\\r\\n          (step-b \\"raa\\" 2)\\r\\n          (step-b \\"not-e\\" 1 3)\\r\\n          (choose-option 3 2)\\r\\n          (step-b \\"or-i2\\" 3)\\r\\n          (step-b \\"not-i\\" 3)\\r\\n          (step-f \\"or-i1\\" 2)\\r\\n          (rename-var 'V1 '(not p))\\r\\n          (step-f \\"not-e\\" 1 3)\\r\\n          ))" "(proof 'p '(not (not p)))" "(def a (proof 'p '(not (not p))))" "(meta (step-b a \\"not-i\\" 3))" "(proof '[(impl a b) (not b)]\\n       '(not a))" "(step-b \\"not-e\\" 4)" "(step-b \\"not-i\\" 4)" "(step-f \\"impl-e\\" 3 1)" "(step-f \\"not-e\\" 2 4)" "(proof '(and e a) '(and a e))" "(step-f \\"and-e1\\" 1)" "(step-f \\"and-e2\\" 1)" "(step-f \\"and-i\\" 2 3)" "(choose-option 4 2)" "(proof '(or p (not p)))" "(step-b \\"raa\\" 2)" "(step-b \\"not-e\\" 1 3)" "(choose-option 3 2)" "1 + 1" "(+ 1 1)" "(+ (* 2 2) (* (+ 2 3) (- 5 2)))" "(+ 2 3 4 5 5)" "(proof '(at x a)\\n       '(at x (always a)))" "(step-b \\"always-i\\" 3)" "(rename-var 'V1 'a)" "(undo)" "(rename-var 'V1 'x)" "(undo)" "(deduction-playground.proof/get-scope\\n  [1 2 [3 4] [5 6 7] 8] 5)" "(proof '(at x (and a b))\\n       '(at x false))" "(step-f \\"and-e1\\" 1)" "(step-f \\"and-e2\\" 1)" "(proof '(at x a)\\n       '(at x (always a)))" "(step-b \\"always-i\\" 3)" "(rename-var 'V1 'x)" "(undo)" "(rename-var 'V1 'x)" "(undo)" "(rename-var 'V1 'x)" "(undo)" "(rename-var 'V1 'x)" "(map println {3 4 5 6})" "(map key {3 4 5 6})" "(key [2 3])" "(map class {3 4 5 6})" "(map first {3 4 5 6})" "(def a (fn [[a b]]\\n         (println a \\"\:\\" b)))" "(map a {3 4 5 6})" "(show)" "(undo)" "(rename-var 'V1 'x)" "(undo)" "(rename-var 'V1 'x)" "(get-term-arg (and (not a) b))" "(get-term-arg '(and (not a) b))" "`(and true a)" "(make-rule \\"and-i\\")" "(make-rule \\"and-e1\\")" "(make-rule \\"and-i\\")" "(proof '(at x a)\\n       '(at x (always a)))" "(step-b \\"always-i\\" 3)" "(rename-var 'V1 'x)" "(def a (make-rule \\"and-i\\"))" "(eval (make-rule \\"and-i\\"))" "(get-rule \\"and-i\\")" "(deduction-playground.rules/import-rules\\n  \\"resurces/rules-temporal.clj\\")" "(deduction-playground.io/import-rules\\n  \\"resources/rules-temporal.clj\\")" "@rules" "(make-rule \\"and-i\\")" "(get-term-arg '(and a i))" "(gen-term-arg '(and a i))" "(gen-term-arg (and a i))" "(sort [\\"1\\" \\"2\\"])" "(sort [\\"2\\" \\"1\\"])" "(sort [\\"4\\" \\"2\\" \\"6\\" \\"1\\" \\"b\\"])" "(sort [\\"1\\" \\"[2 3]\\" \\"[4 6]\\"])" "(sort [\\"[4 6]\\" \\"1\\" \\"[2 3]\\"])" "(proof '[(impl a b) (not b)]\\n       '(impl (not a) (not b)))" "(step-b \\"impl-i\\" 4)" "(proof '[(impl a b) (not b)]\\n       '(not a))" "(step-b \\"raa\\" 4)" "(classical 3)" "(step-b \\"impl-e\\" 1 4)" "(step-f \\"impl-e\\" 1 4)" "(step-f \\"not-i\\" 2 5)" "(step-f \\"not-e\\" 2 5)" "(subs \\"123\\" 1 1)" "(subs \\"123\\" 0 1)" "(subs \\"123\\" 1 2)" "(subs \\"[1 1]\\" 1 2)" "(subs \\"\\\\\\"hallo\\\\\\" ([1 2])\\" 10 15)" "(subs \\"\\\\\\"hallo\\\\\\" ([1 2])\\" 9 14)" "(class (subs \\"\\\\\\"hallo\\\\\\" ([1 2])\\" 9 14))" "(str [1 2])" "(sort \\"[15 21] [2 39 1\\")" "(drop-last [1 2 3])" "(proof '[(impl a b) (not b)]\\n       '(not a))" "(step-b \\"not-i\\" 4)" "(step-f \\"impl-e\\"1 3)" "(step-f \\"not-e\\" 2 4)" "(undo)" "@last_step" "(proof '[(impl a b) (not b)]\\n       '(not a))" "(step-b \\"not-i\\" 4)" "(step-f \\"impl-e\\" 3 1)" "@last_step" "(undo)" "@last_step" "(apply conj [1 2 3] [4 5])" "(proof '[(impl a b) (not b)]\\n       '(not a))" "(step-b \\"not-i\\" 4)" "(step-f \\"impl-e\\" 1 3)" "@last_step" "(step-f \\"not-e\\" 2 4)" "@last_step" "(swap\! last_step conj [\\"asd\\"])" "@p" "(proof '[(impl a b) (not b)]\\n       '(not a))" "@last_step" "(step-b \\"not-i\\" 4)" "@last_step" "(step-f \\"impl-e\\" 1 3)" "@last_step" "(undo)" "(proof '[(impl a b) (not b)]\\n       '(not a))" "@last_step" "(step-b \\"not-i\\" 4)" "@last_step" "(step-f \\"impl-e\\" 1 3)" "@last_step" "(step-f \\"not-e\\" 2 4)" "(undo)" "@last_step" "@p" "(proof '[(impl a b) (not b)]\\n       '(not a))" "(step-b \\"not-i\\" 4)" "(step-f \\"impl-e\\" 1 3)" "(step-f \\"not-e\\" 2 4)" "(undo)" "(proof '(not a)\\n       '(and (impl a b) (not b)))" "(step-b \\"and-i\\" 3)" "(step-b \\"impl-i\\" 4)" "(step-b \\"not-i\\" 6)" "(step-f \\"not-i\\" 1 2)" "(step-f \\"not-e\\" 1 2)" "(step-f \\"efq\\" 3 5)" "(step-f \\"efq\\" 3)" "(rename-var 'V1 'b)" "(-> (proof '(at x (impl (and true a) a)))\\r\\n          (classical 2))" "(proof '(and a (not a)) 'c)" "(step-f-inside \\"or-i1\\" 1)" "(proof '(and a contradiction) 'c)" "(step-f-inside \\"efq\\" 1)" "(proof '(or a (and b c)) 'c)" "(step-f-inside \\"and-e1\\" 1)" "(step-f \\"or-i1\\" 1)" "(undo)" "(step-f-inside \\"and-e1\\" 1)" "(proof '(or a (and b c)) 'c)" "(step-f-inside \\"and-e1\\" 1)" "(proof '[a b] 'c)" "(step-f \\"and-i\\" 1 2)" "(str \:asd)" "(rules)" "(show-rules)" "io/rules" "@io/rules" "io/@rules" "(let [r io/rules]\\n  @r)" "(show-rules)" "(proof '(forall [x] (and (P x) (Q x))) 'c)" "(step-f-inside \\"and-e1\\" 1)" "(proof '(and a b c) 'c)" "(step-f \\"test\\" 1)" "(step-f \\"and-e2\\" 2)" "(undo)" "(step-f \\"and-e2\\" 1)" "(use 'clojure.core.logic)" "(defn and-elim\\n  [and q]\\n  (fresh [a b]\\n         (\=\= and (and a b))\\n         (\=\= q a)))" "(run* [q] (and-elim '(and a b) q))" "(and a b)" "(defn and-elim\\r\\n     [and1 q]\\r\\n     (fresh [a b]\\r\\n            (\=\= and1 (and a b))\\r\\n            (\=\= q a)))" "(run* [q] (and-elim '(and a b) q))" "(run* [q] (and-elim '(and x y) q))" "`(and ~a ~b)" "(def a 1)" "(def b 2)" "`(and ~a ~b)" "(bla 1 2)" "(and a b)" "(and x y)" "(run* [q] (and-elim '(and x y) q))" "(defn and-elim\\r\\n        [and1 q]\\r\\n        (fresh [a b]\\r\\n               (\=\= and1 `(~'and ~a ~b))\\r\\n               (\=\= q a)))" "(run* [q] (and-elim '(and x y) q))" "(run* [q] (and-elim q '(and x y)))" "(defn impl-elim\\n  [impl1 a q1]\\n  (fresh [b]\\n         (\=\= impl1 `(~'impl ~a ~b))\\n         (\=\= q1 b)))" "(run* [q] (impl-elim '(impl a b) 'a q))" "(run* [q] (impl-elim 'a '(impl a b) q))" "(apply-rule \\"or-e\\" false '[(or a b) (infer a X) (infer b X)])" "(\:or-e @rules)" "(deduction-playground.io/import-rules \\"resources/rules-prop-prep.clj\\")" "(\:or-e @rules)" "(apply-rule \\"or-e\\" false '[(or a b) (infer a X) (infer b X)])" "(apply-rule \\"or-e\\" false '[X])" "(apply-rule \\"or-e\\" false '[X] '[(and x y)])" "(apply-rule \\"or-e\\" false '[X] '[(or x y)])" "(proof '(or a (and b c)) 'c)" "(step-f-inside \\"and-e1\\" 1)" "(proof '(and a (and b c)) 'c)" "(step-f-inside \\"and-e2\\" 1)" "(deduction-playground.io/import-rules \\"resources/rules-prop-prep.clj\\")" "(apply-rule \\"or-i1\\" '[a])" "(apply-rule \\"or-i1\\" true '[a])" "(deduction-playground.io/import-rules \\"resources/rules-prop-prep.clj\\")" "(apply-rule \\"and-e1\\" true '[(and Hans Peter)])" "(apply-rule \\"and-e1\\" true '[(and 1 2)])" "(deduction-playground.io/import-rules \\"resources/classical-theorems.clj\\")" "(apply-rule \\"classical-3\\" true '[(and Hans Peter)])" "(apply-rule \\"classical-3\\" true '[(and Hans true)])" "(pprint \\n  (deduction-playground.deduction/check-duplicates\\n    '[{\:id 1 \:body (at x a) \:rule \:premise}\\n      [{\:id 4 \:body (<\= x x) \:rule \:assumption}\\n       {\:id 5 \:body \:todo \:rule nil}\\n       {\:id 6 \:body (at x a) \:rule nil}]\\n      {\:id 3 \:body (at x (always a)) \:rule \\"\\\\\\"always-i\\\\\\" ([4-6])\\"}]))" "(deduction-playground.deduction/check-duplicates\\r\\n       '[{\:id 1 \:body (at x a) \:rule \:premise}\\r\\n         [{\:id 4 \:body (<\= x x) \:rule \:assumption}\\r\\n          {\:id 5 \:body \:todo \:rule nil}\\r\\n          {\:id 6 \:body (at x a) \:rule nil}]\\r\\n         {\:id 3 \:body (at x (always a)) \:rule \\"\\\\\\"always-i\\\\\\" ([4-6])\\"}])" "(def a (proof '(not (or a false))\\n              '(not a)))" "a" "(pprint (step-b a \\"not-i\\" 3))" "(pprint (-> (step-b a \\"not-i\\" 3)\\n          (classical 1)))" "(pprint (-> (proof 'a 'contradiction)\\n          (step-b \\"not-e\\" 3 1)))" "(proof '[(impl a b) (not b)]\\n       '(not a))" "(step-b \\"not-i\\" 4)" "(step-f \\"impl-e\\" 1 3)" "(step-f \\"not-e\\" 2 4)" "(proof '(or a (not a)))" "(step-b \\"raa\\" 2)" "(step-b \\"not-e\\" 1 3)" "(choose-option 3 2)" "(step-b \\"or-i2\\" 3)" "(step-b \\"not-i\\" 3)" "(step-f \\"or-i1\\" 2)" "(rename-var 'V1 '(not a))" "(step-f \\"not-e\\" 1 3)" "(proof '(not (and a b)) '(or (not a) (not b)))" "(step-b \\"raa\\" 3)" "(step-b \\"not-e\\" 4 1)" "(choose-option 4 2)" "(step-b \\"and-i\\" 4)" "(step-b \\"raa\\" 4)" "(step-b \\"raa\\" 8)" "(step-f \\"or-i2\\" 3)" "(rename-var 'V1 '(not a))" "(step-f \\"not-e\\" 4 2)" "(step-f \\"or-i1\\" 6)" "(rename-var 'V2 '(not b))" "(step-f \\"not-e\\" 2 7)" "(proof '(not (or a b)) '(and (not a) (not b)))" "(step-b \\"and-i\\" 3)" "(step-b \\"not-i\\" 3)" "(step-b \\"not-i\\" 6)" "(step-b \\"not-i\\" 7)" "(step-f \\"or-i2\\" 2)" "(rename-var 'V1 'a)" "(step-f \\"not-e\\" 1 3)" "(step-f \\"or-i1\\" 5)" "(rename-var 'V2 'b)" "(step-f \\"not-e\\" 1 6)" "(step-f \\"modus-tollens\\" 1)" "(proof '(impl a b) '(impl (not b) (not a)))" "(step-b \\"impl-i\\" 3)" "(step-f \\"modus-tollens\\" 1 2)" "(proof '(not (exists [x] (P x \:a)))\\n       '(forall [x] (not (P x \:a))))" "(step-b \\"forall-i\\" 3)" "(step-b \\"not-i\\" 4)" "(step-f \\"exists-i\\" 2 3)" "(step-b \\"not-e\\" 5 1)" "(choose-option 5 2)" "(step-b \\"exists-i\\" 5 2)" "(proof '(exists [x] (or (P x) (Q x)))\\n       '(or (exists [x] (P x)) (exists [x] (Q x))))" "(step-b \\"exists-e\\" 3 1)" "(step-b \\"or-e\\" 5 3)" "(choose-option 5 1)" "(step-b \\"or-i2\\" 6)" "(step-b \\"exists-i\\" 6 4)" "(step-b \\"exists-i\\" 6 2)" "(step-b \\"or-i1\\" 9)" "(step-b \\"exists-i\\" 9 2)" "(proof '(not (sometime a))\\n       '(always (not a)))" "(proof '(at i (not (sometime a)))\\n       '(at i (always (not a))))" "(step-b \\"always-i\\" 3)" "(rename-var 'V1 'j)" "(step-b \\"not-i\\" 4)" "(rename-var 'V2 'x)" "(rename-var 'V3 'a)" "(step-f \\"sometime-i\\" 2 3)" "(proof '(at i (not (sometime a)))\\n       '(at i (always (not a))))" "(step-b \\"always-i\\" 3)" "(rename-var 'V1 'j)" "(step-b \\"not-i\\" 4)" "(rename-var 'V2 'x)" "(undo)" "(rename-var 'V2 'i)" "(rename-var 'V3 '(sometime a))" "(step-b \\"and-i\\" 5)" "(step-f \\"sometime-i\\" 2 3)" "(proof '(at i (asap (sometime a)))\\n       '(at i (sometime a)))" "(step-f \\"asap-seriality\\")" "(rename-var 'V1 'i)" "(rename-var 'V2 'j)" "(step-f \\"asap-e\\" 1)" "(rename-var 'V3 'j)" "(step-f \\"asap/<\=\\" 2)" "(step-f \\"sometime-e\\" 3)" "(rename-var 'V4 'k)" "(step-f \\"transivity\\" 4 5)" "(step-f \\"transitivity\\" 4 5)" "(step-f \\"sometime-i\\" 6 7)" "(proof '[(impl a b) (not b)]\\n       '(not a))" "(step-b \\"impl-i\\" 4)" "(step-b \\"not-i\\" 4)" "(step-f \\"impl-e\\" 1 3)" "(undo)" "(step-f \\"impl-e\\" 3 1)" "(step-f \\"not-e\\" 2 4)" "(show-rules)" "(def a [1 0 1 2 3 0 4 5])" "a" "(partition-by sequential? a)" "(group-by sequential? a)" "(clojure.walk/postwalk-demo a)" "(for [x a]\\n  (rest a))" "(take-while \#() a)" "(reduce \#(if (\= (inc (last %1)) %2)\\n           (conj %1 %2))\\n        [0] [1 2 3 0 4 5])" "(reduce \#(if (\= (inc (last %1)) %2)\\r\\n              (conj %1 %2) %1)\\r\\n           [0] [1 2 3 0 4 5])" "(for [x (range 1 (inc (count a)))]\\n  (take x a))" "(filter sequential? (for [x (range 1 (inc (count a)))]\\r\\n     (take x a)))" "(sequential? '(1 0 1))" "(apply <\= a)" "(apply <\= [1 2 3 4 5])" "(filter \#(apply <\= %) (for [x (range 1 (inc (count a)))]\\n                        (take x a)))" "(for [x a]\\n  (filter \#(apply <\= %) (for [x (range 1 (inc (count a)))]\\r\\n                           (take x a))))" "(for [x (range 0 (count a))\\n      \:let [restv (drop x a)]]\\n  (apply \#(apply <\= %) \\n         (for [y (range 1 (inc (count restv)))]\\n           (take y restv))))" "(for [x (range 0 (count a))\\r\\n         \:let [restv (drop x a)]]\\r\\n     (filter \#(apply <\= %) \\r\\n            (for [y (range 1 (inc (count restv)))]\\r\\n              (take y restv))))" "(flatten (((1)) ((0) (0 1) (0 1 2) (0 1 2 3)) ((1) (1 2) (1 2 3)) ((2) (2 3)) ((3)) ((0) (0 4) (0 4 5)) ((4) (4 5)) ((5))))" "(flatten '(((1)) ((0) (0 1) (0 1 2) (0 1 2 3)) ((1) (1 2) (1 2 3)) ((2) (2 3)) ((3)) ((0) (0 4) (0 4 5)) ((4) (4 5)) ((5))))" "(for [x (range 0 (count a))\\r\\n            \:let [restv (drop x a)]]\\r\\n        (filter \#(apply <\= %) \\r\\n               (for [y (range 1 (inc (count restv)))]\\r\\n                 (flatten (take y restv)))))" "(map flatten '(((1)) ((0) (0 1) (0 1 2) (0 1 2 3)) ((1) (1 2) (1 2 3)) ((2) (2 3)) ((3)) ((0) (0 4) (0 4 5)) ((4) (4 5)) ((5))))" "(reduce conj '(((1)) ((0) (0 1) (0 1 2) (0 1 2 3)) ((1) (1 2) (1 2 3)) ((2) (2 3)) ((3)) ((0) (0 4) (0 4 5)) ((4) (4 5)) ((5))))" "(reduce concat '(((1)) ((0) (0 1) (0 1 2) (0 1 2 3)) ((1) (1 2) (1 2 3)) ((2) (2 3)) ((3)) ((0) (0 4) (0 4 5)) ((4) (4 5)) ((5))))" "(sort-by count (reduce concat '(((1)) ((0) (0 1) (0 1 2) (0 1 2 3)) ((1) (1 2) (1 2 3)) ((2) (2 3)) ((3)) ((0) (0 4) (0 4 5)) ((4) (4 5)) ((5)))))" "(let [p1 (reduce concat (for [x (range 0 (count a))\\r\\n                              \:let [restv (drop x a)]]\\r\\n                          (filter \#(apply <\= %) \\r\\n                                  (for [y (range 1 (inc (count restv)))]\\r\\n                                    (flatten (take y restv))))))\\n      p2 (remove \#(< (count %) 2) p1)]\\n  p2)" "(let [p1 (reduce concat (for [x (range 0 (count a))\\r\\n                                 \:let [restv (drop x a)]]\\r\\n                             (filter \#(apply <\= %) \\r\\n                                     (for [y (range 1 (inc (count restv)))]\\r\\n                                       (flatten (take y restv))))))\\r\\n         p2 (remove \#(< (count %) 2) p1)\\n         p3 (last (sort-by count p2))]\\r\\n     p3)" "(def a [0 1 2 5 6 7 9])" "(let [p1 (reduce concat (for [x (range 0 (count a))\\r\\n                                    \:let [restv (drop x a)]]\\r\\n                                (filter \#(apply <\= %) \\r\\n                                        (for [y (range 1 (inc (count restv)))]\\r\\n                                          (flatten (take y restv))))))\\r\\n            p2 (remove \#(< (count %) 2) p1)\\r\\n            p3 (last (sort-by count p2))]\\r\\n        p3)" "(loop [x (rest a)\\n       y (first a)\\n       temp [y]\\n       result []]\\n  (if (\= (inc y) (first x))\\n    (recur (rest x) (first x) (conj temp (first x)) result)\\n    (recur (rest x) (first x) [(first x)] (conj result temp))))" "(loop [x (rest a)\\r\\n       y (first a)\\r\\n       temp [y]\\r\\n       result []]\\n  (if (empty? x)\\n    result\\r\\n    (if (\= (inc y) (first x))\\r\\n      (recur (rest x) (first x) (conj temp (first x)) result)\\r\\n      (recur (rest x) (first x) [(first x)] (conj result temp)))))" "a" "(let [sorted-parts (loop [x (rest a)\\r\\n                          y (first a)\\r\\n                          temp [y]\\r\\n                          result []]\\r\\n                     (if (empty? x)\\r\\n                       result\\r\\n                       (if (\= (inc y) (first x))\\r\\n                         (recur (rest x) (first x) (conj temp (first x)) result)\\r\\n                         (recur (rest x) (first x) [(first x)] (conj result temp)))))\\n      filtered (sort-by count (remove \#(< (count %) 2) sorted-parts))]\\n  (last filtered))" "(let [sorted-parts (loop [x (rest a)\\r\\n                          y (first a)\\r\\n                          temp [y]\\r\\n                          result []]\\r\\n                     (if (empty? x)\\r\\n                       result\\r\\n                       (if (\= (inc y) (first x))\\r\\n                         (recur (rest x) (first x) (conj temp (first x)) result)\\r\\n                         (recur (rest x) (first x) [(first x)] (conj result temp)))))\\r\\n      filtered (group-by count (remove \#(< (count %) 2) sorted-parts))]\\r\\n  filtered)" "(def a [0 1 0 1 2 3 6 7 8 9])" "(let [sorted-parts (loop [x (rest a)\\r\\n                          y (first a)\\r\\n                          temp [y]\\r\\n                          result []]\\r\\n                     (if (empty? x)\\r\\n                       result\\r\\n                       (if (\= (inc y) (first x))\\r\\n                         (recur (rest x) (first x) (conj temp (first x)) result)\\r\\n                         (recur (rest x) (first x) [(first x)] (conj result temp)))))\\r\\n      filtered (group-by count (remove \#(< (count %) 2) sorted-parts))]\\r\\n  filtered)" "(loop [x (rest a)\\r\\n                             y (first a)\\r\\n                             temp [y]\\r\\n                             result []]\\r\\n                        (if (empty? x)\\r\\n                          result\\r\\n                          (if (\= (inc y) (first x))\\r\\n                            (recur (rest x) (first x) (conj temp (first x)) result)\\r\\n                            (recur (rest x) (first x) [(first x)] (conj result temp)))))" "(loop [x (rest a)\\r\\n       y (first a)\\r\\n       temp [y]\\r\\n       result []]\\r\\n  (if (empty? x)\\r\\n    (conj result temp)\\r\\n    (if (\= (inc y) (first x))\\r\\n      (recur (rest x) (first x) (conj temp (first x)) result)\\r\\n      (recur (rest x) (first x) [(first x)] (conj result temp)))))" "(let [sorted-parts (loop [x (rest a)\\r\\n                             y (first a)\\r\\n                             temp [y]\\r\\n                             result []]\\r\\n                        (if (empty? x)\\r\\n                          (conj result temp)\\r\\n                          (if (\= (inc y) (first x))\\r\\n                            (recur (rest x) (first x) (conj temp (first x)) result)\\r\\n                            (recur (rest x) (first x) [(first x)] (conj result temp)))))\\r\\n         filtered (group-by count (remove \#(< (count %) 2) sorted-parts))]\\r\\n     filtered)" "(let [sorted-parts (loop [x (rest a)\\r\\n                                y (first a)\\r\\n                                temp [y]\\r\\n                                result []]\\r\\n                           (if (empty? x)\\r\\n                             (conj result temp)\\r\\n                             (if (\= (inc y) (first x))\\r\\n                               (recur (rest x) (first x) (conj temp (first x)) result)\\r\\n                               (recur (rest x) (first x) [(first x)] (conj result temp)))))\\r\\n            filtered (sort-by count (remove \#(< (count %) 2) sorted-parts))]\\r\\n        filtered)" "(let [sorted-parts (loop [x (rest a)\\r\\n                                y (first a)\\r\\n                                temp [y]\\r\\n                                result []]\\r\\n                           (if (empty? x)\\r\\n                             (conj result temp)\\r\\n                             (if (\= (inc y) (first x))\\r\\n                               (recur (rest x) (first x) (conj temp (first x)) result)\\r\\n                               (recur (rest x) (first x) [(first x)] (conj result temp)))))\\r\\n            filtered (sort (group-by count (remove \#(< (count %) 2) sorted-parts)))]\\r\\n        (first (last filtered)))" "(let [sorted-parts (loop [x (rest a)\\r\\n                                   y (first a)\\r\\n                                   temp [y]\\r\\n                                   result []]\\r\\n                              (if (empty? x)\\r\\n                                (conj result temp)\\r\\n                                (if (\= (inc y) (first x))\\r\\n                                  (recur (rest x) (first x) (conj temp (first x)) result)\\r\\n                                  (recur (rest x) (first x) [(first x)] (conj result temp)))))\\r\\n               filtered (sort (group-by count (remove \#(< (count %) 2) sorted-parts)))]\\r\\n           (first (val (last filtered))))" "((fn [a]\\n  (let [sorted-parts (loop [x (rest a)\\r\\n                            y (first a)\\r\\n                            temp [y]\\r\\n                            result []]\\r\\n                       (if (empty? x)\\r\\n                         (conj result temp)\\r\\n                         (if (\= (inc y) (first x))\\r\\n                           (recur (rest x) (first x) (conj temp (first x)) result)\\r\\n                           (recur (rest x) (first x) [(first x)] (conj result temp)))))\\r\\n        filtered (sort (group-by count (remove \#(< (count %) 2) sorted-parts)))]\\r\\n    (first (val (last filtered))))) [2 3 3 4 5])" "((fn [a]\\r\\n     (let [sorted-parts (loop [x (rest a)\\r\\n                               y (first a)\\r\\n                               temp [y]\\r\\n                               result []]\\r\\n                          (if (empty? x)\\r\\n                            (conj result temp)\\r\\n                            (if (\= (inc y) (first x))\\r\\n                              (recur (rest x) (first x) (conj temp (first x)) result)\\r\\n                              (recur (rest x) (first x) [(first x)] (conj result temp)))))\\r\\n           filtered (sort (group-by count (remove \#(< (count %) 2) sorted-parts)))]\\r\\n       (first (val (last filtered))))) [7 6 5 4])" "(def a [7 6 5 4])" "(let [sorted-parts (loop [x (rest a)\\r\\n                          y (first a)\\r\\n                          temp [y]\\r\\n                          result []]\\r\\n                     (if (empty? x)\\r\\n                       (conj result temp)\\r\\n                       (if (\= (inc y) (first x))\\r\\n                         (recur (rest x) (first x) (conj temp (first x)) result)\\r\\n                         (recur (rest x) (first x) [(first x)] (conj result temp)))))\\r\\n      filtered (sort (group-by count (remove \#(< (count %) 2) sorted-parts)))]\\r\\n  (first (val (last filtered))))" "(loop [x (rest a)\\r\\n                             y (first a)\\r\\n                             temp [y]\\r\\n                             result []]\\r\\n                        (if (empty? x)\\r\\n                          (conj result temp)\\r\\n                          (if (\= (inc y) (first x))\\r\\n                            (recur (rest x) (first x) (conj temp (first x)) result)\\r\\n                            (recur (rest x) (first x) [(first x)] (conj result temp)))))" "(let [sorted-parts (loop [x (rest a)\\r\\n                          y (first a)\\r\\n                          temp [y]\\r\\n                          result []]\\r\\n                     (if (empty? x)\\r\\n                       (conj result temp)\\r\\n                       (if (\= (inc y) (first x))\\r\\n                         (recur (rest x) (first x) (conj temp (first x)) result)\\r\\n                         (recur (rest x) (first x) [(first x)] (conj result temp)))))\\r\\n      filtered (sort (group-by count (remove \#(< (count %) 2) sorted-parts)))]\\n  (if (empty? filtered)\\n    []\\r\\n    (first (val (last filtered)))))" "(proof '(and a b) '(and b a))" "(step-f \\"and-e1\\" 1)" "(step-f \\"and-e2\\" 1)" "(step-f \\"and-i\\" 2 3)" "(choose-option 4 2)" "(proof '[(impl a b) (not b)]\\n       '(not a))" "(step-b \\"not-i\\" 4)" "(step-f \\"impl-e\\" 1 3)" "(undo)" "(step-f \\"impl-e\\" 3 1)" "(step-f \\"not-e\\" 2 4)" "(export-theorem \\"resources/theorems.clj\\" \\"modus-tollens\\")" "(proof '[(impl a b) (not b)]\\n       '(not a))" "(step-f \\"modus-tollens\\" 1 2)" "(clojure.walk/postwalk-demo '(exists [x] (exists [y] (and (P y) (Q x)))))" "(clojure.walk/prewalk-demo '(exists [x] (exists [y] (and (P y) (Q x)))))" "(use 'clojure.zip)" "(seq-zip '(exists [x] (exists [y] (and (P y) (Q x)))))" "(def a (seq-zip '(exists [x] (exists [y] (and (P y) (Q x))))))" "(next a)" "(up a)" "(right a)" "(next (next a))" "(down (next (next a)))" "(down (next (next (next a))))" "(next (next (next a)))" "(node (down (next (next a))))" "(node a)" "(down a)" "(rigth (down a))" "(right (down a))" "(node (right (down a)))" "(right (right (right (down a))))" "(next (down a))" "(next a)" "(next (next (next (next a))))" "(def b (seq-zip '(exists [x] (P x))))" "b" "(next (next (next b)))" "(next (next (next (next b))))" "(next (next (next (next (next (next b))))))" "(next (next (next (next (next b)))))" "(path (next (next (next b))))" "(path (next (next (next (next (next b))))))" "(defn get-paths\\n  [formula old]\\n  (loop [zform (seq-zip formula)\\n         paths []]\\n    (cond\\n      (end? (next zform)) paths\\n      (\= (first (next zform)) old) (recur (next zform) (conj paths (path (next zform))))\\n      \:else (recur (next zform) paths))))" "b" "a" "(get-paths '(exists [x] (exists [y] (and (P y) (Q x)))) 'y)" "(get-paths '(exists [x] (exists [y] (and (P y) (exists [c] (Q c y))))) 'y)" "(get-paths '(exists [x] (and (exists [y] (P x)) (exists [z] (Q z)))) 'x)" "(get-paths '(and (exists [x] (P x)) (exists [y] (Q y))) 'x)" "(get-paths '(and (exists [x] (exists [y] (P x y))) (exists [z] (Q z))) 'y)" "(defn check-paths\\n  [paths new]\\n  (let [fn-path (fn [path]\\n                  (reduce \#(if (vector? (second %2))\\n                             (distinct (concat %1 (second %2)))\\n                             %1) [] path))\\n        vars (reduce \#(concat %1 %2) [] (map fn-path paths))\\n        dvars (distinct vars)]\\n    dvars))" "(check-paths (get-paths '(exists [x] (exists [y] (P x y))) 'y) 'x)" "(check-paths (get-paths '(and (exists [x] (exists [y] (P x y))) (exists [z] (Q z))) 'y) 'x)" "(check-paths (get-paths '(and (exists [x] (exists [y] (P x y))) (exists [z] (Q z y))) 'y) 'x)" "(check-paths (get-paths '(and (exists [x] (exists [y] (P x y)))\\n                              (exists [y] (Q y))) 'y) 'x)" "(next (seq-zip '(and (exists [x] (P x)) (exists [y] (P y)))))" "(next (next (seq-zip '(and (exists [x] (P x)) (exists [y] (P y))))))" "(defn substitution?\\n  [formula old new-vars]\\n  (let [paths (get-paths formula old)\\n        bounded-vars (check-paths paths 'x)]\\n    (if (empty? (clojure.set/intersection (set bounded-vars)\\n                                          (set new-vars)))\\n      true\\n      false)))" "(substitution? \\n  '(exists [x] (exists [y] (and (P y) (Q x y)))) 'y '[x (m x)])" "(clojure.walk/postwalk-demo '(m x))" "(clojure.walk/prewalk-demo '(m x))" "(defn get-vars\\n [form]\\n (cond\\n   (symbol? form) form\\n   (list? form) (reduce \#(concat %1 (get-vars %2)) [] (rest form))\\n   \:else (throw (Exception. \\"Invalid term\: A term can only contain symbols and lists.\\"))))" "(get-vars '(m x))" "(defn get-vars\\r\\n    [form]\\r\\n    (cond\\r\\n      (symbol? form) form\\r\\n      (list? form) (reduce \#(conj %1 (get-vars %2)) [] (rest form))\\r\\n      \:else (throw (Exception. \\"Invalid term\: A term can only contain symbols and lists.\\"))))" "(get-vars '(m x))" "(get-vars '(m x y))" "(get-vars '(m x (s y z)))" "(defn get-vars\\r\\n       [form]\\r\\n       (cond\\r\\n         (symbol? form) form\\r\\n         (list? form) (flatten (reduce \#(conj %1 (get-vars %2)) [] (rest form)))\\r\\n         \:else (throw (Exception. \\"Invalid term\: A term can only contain symbols and lists.\\"))))" "(get-vars '(m x (s y z)))" "(get-vars 'x)" "(set 'x)" "(defn get-vars\\r\\n\\t[form]\\r\\n    (cond\\r\\n    \\t(symbol? form) [form]\\r\\n    \\t(list? form) (reduce \#(conj %1 (get-vars %2)) [] (rest form))\\r\\n    \\t\:else (throw (Exception. \\"Invalid term\: A term can only contain symbols and lists.\\"))))" "(get-vars 'x)" "(get-vars '(m x (s y z)))" "(defn substitution?\\r\\n     [formula old new-vars]\\r\\n     (let [vars (set (flatten (get-vars new-vars)))\\n           paths (get-paths formula old)\\r\\n           bounded-vars (set (check-paths paths 'x))]\\r\\n       (if (empty? (clojure.set/intersection bounded-vars vars))\\r\\n         true\\r\\n         false)))" "(substitution? \\n  '(exists [x] (exists [y] (and (P x) (Q y))))\\n  'y '(m x))" "(substitution? \\r\\n     '(exists [x] (exists [y] (and (P x) (Q y))))\\r\\n     'y '(m z))" "(proof '(exists [x] (exists [y] (not (\= x y)))))" "(step-b \\"exists-i\\" 2)" "(step-b \\"not-i\\" 2)" "(proof '(and a b) '(and b a))" "(step-f \\"and-e1\\" 1)" "(step-f \\"and-e2\\" 1)" "(step-f \\"and-i\\" 2 3)" "(choose-option 4 2)" "(proof '[(impl a b) (not b)]\\n       '(not a))" "(step-b \\"not-i\\" 4)" "(step-f \\"impl-e\\" 1 3)" "(step-f \\"not-e\\" 2 4)" "(proof '(and a b) '(and b a))" "(step-f \\"and-e1\\" 1)" "(step-f \\"and-e2\\" 1)" "(step-f \\"and-i\\" 2 3)" "(choose-option 4 2)" "(export-theorem \\"resource/theorems.clj\\" \\"regel1\\")" "(export-theorem \\"resources/theorems.clj\\" \\"regel1\\")" "(proof '(and a b) '(and b a))" "(step-f \\"regel1\\" 1)" "(defn get-paths\\r\\n     [formula old]\\r\\n     (loop [zform (seq-zip formula)\\r\\n            paths []]\\r\\n       (cond\\r\\n         (end? (next zform)) paths\\r\\n         (\= (first (next zform)) old) (recur (next zform) (conj paths (path (next zform))))\\r\\n         \:else (recur (next zform) paths))))" "(use 'clojure.zip)" "(defn get-paths\\r\\n     [formula old]\\r\\n     (loop [zform (seq-zip formula)\\r\\n            paths []]\\r\\n       (cond\\r\\n         (end? (next zform)) paths\\r\\n         (\= (first (next zform)) old) (recur (next zform) (conj paths (path (next zform))))\\r\\n         \:else (recur (next zform) paths))))" "(defn check-paths\\r\\n     [paths new]\\r\\n     (let [fn-path (fn [path]\\r\\n                     (reduce \#(if (vector? (second %2))\\r\\n                                (distinct (concat %1 (second %2)))\\r\\n                                %1) [] path))\\r\\n           vars (reduce \#(concat %1 %2) [] (map fn-path paths))\\r\\n           dvars (distinct vars)]\\r\\n       dvars))" "(defn get-vars\\r\\n   \\t[form]\\r\\n       (cond\\r\\n       \\t(symbol? form) [form]\\r\\n       \\t(list? form) (reduce \#(conj %1 (get-vars %2)) [] (rest form))\\r\\n       \\t\:else (throw (Exception. \\"Invalid term\: A term can only contain symbols and lists.\\"))))" "(defn substitution?\\r\\n\\t[formula old new-vars]\\r\\n\\t(let [vars (set (flatten (get-vars new-vars)))\\r\\n          paths (get-paths formula old)\\r\\n          bounded-vars (set (check-paths paths 'x))]\\r\\n          (if (empty? (clojure.set/intersection bounded-vars vars))\\r\\n          \\ttrue\\r\\n            false)))" "(substitution? '(forall [x] (exists [y] (P x y))) 'y '(m s x))" "(substitution? '(forall [x] (exists [y] (P x y))) 'y '(m y s))" "(get-paths '(forall [x] (exists [y] (P x y))) 'y)" "(check-paths (get-paths '(forall [x] (exists [y] (P x y)))\\n                        'y) 'x)" "(get-vars '(m x s))" "(defn substitution?\\r\\n\\t[formula old new-vars]\\r\\n\\t(let [vars (set (flatten (get-vars new-vars)))\\r\\n        paths (get-paths formula old)\\r\\n        bounded-vars (set (check-paths paths 'x))]\\r\\n        (if (or (empty? (clojure.set/intersection bounded-vars vars))\\n                (and (\= (count bounded-vars) 1)\\n                     (contains? bounded-vars old)))\\r\\n         \\ttrue\\r\\n          false)))" "(substitution? '(forall [x] (exists [y] (P x y))) 'y '(m y x))" "(defn substitution?\\r\\n   \\t[formula old new-vars]\\r\\n   \\t(let [vars (set (flatten (get-vars new-vars)))\\r\\n           paths (get-paths formula old)\\r\\n           bounded-vars (set (check-paths paths 'x))\\n           intersec (clojure.set/intersection bounded-vars vars)]\\r\\n           (if (or (empty? intersec)\\r\\n                   (and (\= (count intersec) 1)\\r\\n                        (contains? intersec old)))\\r\\n            \\ttrue\\r\\n             false)))" "(substitution? '(forall [x] (exists [y] (P x y))) 'y '(m y x))" "(defn substitution?\\r\\n      \\t[formula old new-vars]\\r\\n      \\t(let [vars (set (flatten (get-vars new-vars)))\\r\\n              paths (get-paths formula old)\\r\\n              bounded-vars (set (check-paths paths 'x))\\r\\n              intersec (clojure.set/intersection bounded-vars vars)]\\r\\n              (if (or (empty? intersec)\\r\\n                      (and (\= (count intersec) 1)\\r\\n                           (contains? intersec old)))\\r\\n               \\ttrue\\r\\n                intersec)))" "(substitution? '(forall [x] (exists [y] (P x y))) 'y '(m y x))" "(substitution? '(forall [x] (exists [y] (P x y))) 'y '(m y s))" "(substitution? \\n  '(and (exists [x] (exists [y] (P x y))) (exists [z] (P z)))\\n  'y '(m y s))" "(substitution? \\r\\n     '(and (exists [x] (exists [y] (P x y))) (exists [z] (P z)))\\r\\n     'y '(m y z))" "(substitution? \\r\\n     '(and (exists [x] (exists [y] (P x y))) (exists [y] (P y)))\\r\\n     'y '(m x s))" "(defn get-paths\\r\\n     [formula old]\\r\\n     (loop [zform (next (seq-zip formula))\\r\\n            paths []]\\r\\n       (cond\\r\\n         (end? zform) paths\\r\\n         (\= (first zform) old) (recur (next zform) (conj paths (path zform)))\\r\\n         \:else (recur (next zform) paths))))" " (substitution? \\r\\n        '(and (exists [x] (exists [y] (P x y))) (exists [y] (P y)))\\r\\n        'y '(m x s))" "(substitution? \\r\\n        '(and (exists [x] (exists [y] (P x y))) (exists [z] (P z)))\\r\\n        'y '(m y z))" "(get-paths '(and (exists [x] (exists [y] (and x y))) (exists [z] (P z)))\\n           '(exists [z] (P z)))" "(get-paths '(and (exists [x] (exists [y] (and x y))) (exists [z] (P z)))\\r\\n              'y)" "(defn check-paths\\r\\n     [paths new]\\r\\n     (let [fn-path (fn [path]\\r\\n                     (reduce \#(if (vector? (second %2))\\r\\n                                (concat %1 (second %2))\\r\\n                                %1) [] path))\\r\\n           vars (reduce \#(concat %1 %2) [] (map fn-path paths))\\r\\n           dvars (distinct vars)]\\r\\n       dvars))" "(substitution? \\r\\n           '(and (exists [x] (exists [y] (P x y))) (exists [z] (P z)))\\r\\n           'y '(m y z))" "(substitution? \\r\\n           '(and (exists [x] (exists [y] (P x y))) (exists [y] (P y)))\\r\\n           'y '(m x s))" "(defn get-bvars\\r\\n     [paths]\\r\\n     (let [fn-bvars (fn [path]\\n                      (reduce \#(if (vector? (second %2))\\n                                 (concat %1 (second %2)) %1) [] path))\\r\\n           vars (reduce \#(concat %1 %2) [] (map fn-bvars paths))]\\r\\n       (set vars)))" "(defn substitution?\\r\\n\\t[formula old new-vars]\\r\\n\\t(let [vars (set (flatten (get-vars new-vars)))\\r\\n        paths (get-paths formula old)\\r\\n        bounded-vars (get-bvars paths)]\\r\\n        (if (empty? (clojure.set/intersection bounded-vars vars))\\r\\n         \\ttrue\\r\\n          false)))" "(substitution? \\r\\n              '(and (exists [x] (exists [y] (P x y))) (exists [z] (P z)))\\r\\n              'y '(m y z))" "(defn substitution?\\r\\n    [formula old new-vars]\\r\\n    (let [vars (set (flatten (get-vars new-vars)))\\r\\n          paths (get-paths formula old)\\r\\n          bounded-vars (get-bvars paths)\\n          intersec (clojure.set/intersection bounded-vars vars)]\\r\\n      (if (or (empty? intersec)\\n              (and (\= (count intersec) 1)\\n                   (contains? intersec old)))\\r\\n        true\\r\\n        false)))" "(substitution? \\r\\n                 '(and (exists [x] (exists [y] (P x y))) (exists [z] (P z)))\\r\\n                 'y '(m y z))" "(substitution? \\r\\n              '(and (exists [x] (exists [y] (P x y))) (exists [y] (P y)))\\r\\n              'y '(m x s))" "(conj \#{1} \#{2})" "(conj \#{1} 2)" "(defn get-vars\\r\\n   \\t[form]\\r\\n       (cond\\r\\n       \\t(symbol? form) [form]\\r\\n       \\t(list? form) (reduce \#(conj %1 (get-vars %2)) \#{} (rest form))\\r\\n       \\t\:else (throw (Exception. \\"Invalid term\: A term can only contain symbols and lists.\\"))))" "(get-vars '(m x y))" "(defn get-vars\\r\\n      \\t[form]\\r\\n          (cond\\r\\n          \\t(symbol? form) form\\r\\n          \\t(list? form) (reduce \#(conj %1 (get-vars %2)) \#{} (rest form))\\r\\n          \\t\:else (throw (Exception. \\"Invalid term\: A term can only contain symbols and lists.\\"))))" "(get-vars '(m x y))" "(get-vars 'x)" "(defn get-vars\\r\\n         \\t[form]\\r\\n             (cond\\r\\n             \\t(symbol? form) (set form)\\r\\n             \\t(list? form) (reduce \#(conj %1 (get-vars %2)) \#{} (rest form))\\r\\n             \\t\:else (throw (Exception. \\"Invalid term\: A term can only contain symbols and lists.\\"))))" "(get-vars '(m x y))" "(get-vars 'x)" "(set 'x)" "(defn get-vars\\r\\n            \\t[form]\\r\\n                (cond\\r\\n                \\t(symbol? form) \#{form}\\r\\n                \\t(list? form) (reduce \#(conj %1 (get-vars %2)) \#{} (rest form))\\r\\n                \\t\:else (throw (Exception. \\"Invalid term\: A term can only contain symbols and lists.\\"))))" "(get-vars 'x)" "(get-vars '(m x y))" "(flatten \#{1 \#{2}})" "(defn get-vars\\r\\n  [form]\\r\\n  (cond\\r\\n    (symbol? form) \#{form}\\r\\n    (list? form) (reduce \#(clojure.set/union %1 (get-vars %2)) \#{} (rest form))\\r\\n    \:else (throw (Exception. \\"Invalid term\: A term can only contain symbols and lists.\\"))))" "(get-vars '(m x y))" "(get-vars 'x)" "(defn substitution?\\r\\n       [formula old new]\\r\\n       (let [vars  (get-vars new)\\r\\n             paths (get-paths formula old)\\r\\n             bounded-vars (get-bvars paths)\\r\\n             intersec (clojure.set/intersection bounded-vars vars)]\\r\\n         (if (or (empty? intersec)\\r\\n                 (and (\= (count intersec) 1)\\r\\n                      (contains? intersec old)))\\r\\n           true\\r\\n           false)))" "(substitution? \\r\\n                 '(and (exists [x] (exists [y] (P x y))) (exists [y] (P y)))\\r\\n                 'y '(m x s))" "(substitution? \\r\\n                    '(and (exists [x] (exists [y] (P x y))) (exists [z] (P z)))\\r\\n                    'y '(m y z))" "(substitution? \\r\\n                    '(and (exists [x] (exists [y] (P x y))) (exists [z] (P z)))\\r\\n                    'y 'h)" "(run* [q]\\n      true)" "(run* [q]\\n      (\=\= true true))" "(run* [q] \\n      (\=\= (pos? 1) true))" "(def rule\\n  {\:name \\"equal-e\\"\\n   \:prereq [(substitution? phi x a)]\\n   \:given [(\= a b)]\\n   \:conclusion [(substitution phi x b)]\\n   \:forwards true})" "(def rule\\r\\n     {\:name \\"equal-e\\"\\r\\n      \:prereq '[(substitution? phi x a)]\\r\\n      \:given '[(\= a b)]\\r\\n      \:conclusion '[(substitution phi x b)]\\r\\n      \:forwards true})" "rule" "(defn equal-e\\n  [equal1 q1]\\n  (fresh [phi a b x]\\n         (\=\= equal1 `(~'\= ~a ~b))\\n         (\=\= q1 `(~'substitution ~phi ~x ~b))))" "(run* [q]\\n      (equal-e '(\= x y) q))" "(def rule\\r\\n  {\:name \\"equal-e\\"\\r\\n   \:prereq '[(substitution? phi _\:x a)]\\r\\n   \:given '[(\= a b) phi _\:x]\\r\\n   \:conclusion '[(substitution phi _\:x b)]\\r\\n   \:forwards true})" "(defn equal-e\\n  [equal1 phi _\:x q1]\\n  (fresh [a b]\\n         (\=\= `(substitution? ~phi ~_\:x ~a) true)\\n         (\=\= equal1 \u00B4(~'\= ~a ~b))\\n         (\=\= q1 `(~'substitution ~phi ~_\:x ~b))))" "(defn equal-e\\r\\n     [equal1 phi _\:x q1]\\r\\n     (fresh [a b]\\r\\n            (\=\= `(substitution? ~phi ~_\:x ~a) true)\\r\\n            (\=\= equal1 `(~'\= ~a ~b))\\r\\n            (\=\= q1 `(~'substitution ~phi ~_\:x ~b))))" "(defn substitution?\\n  [a b c]\\n  true)" "(run* [q]\\n      (equal-e '(\= a b) '(exists [x] (P x)) 'x q))" "(defn equal-e\\r\\n        [equal1 phi _\:x q1]\\r\\n        (fresh [a b]\\r\\n               (\=\= equal1 `(~'\= ~a ~b))\\r\\n               (\=\= q1 `(~'substitution ~phi ~_\:x ~b))))" "(run* [q]\\r\\n         (equal-e '(\= a b) '(exists [x] (P x)) 'x q))" "`(substitution?)" "(eval `(substitution? 1 2 3))" "(run* [q]\\n      (\=\= q `(substitution? 1 2 3)))" "(defn equal-e\\r\\n        [equal1 phi _\:x q1]\\r\\n        (fresh [a b]\\r\\n               (\=\= (substitution? phi _\:x a) true)\\r\\n               (\=\= equal1 `(~'\= ~a ~b))\\r\\n               (\=\= q1 `(~'substitution ~phi ~_\:x ~b))))" "(run* [q]\\n      (equal-e '(\= v t) '(exists [x] (P x)) 'x q))" "(gen-prereqs '[(substitution? phi _\:x a)])" "(deduction-playground.io/import-rules \\"resources/rules-prop-pred.clj\\")" "(make-rule \\"and-i\\")" "rule" "(make-rule rule)" "(apply-rule rule true\\n            '[(exists [x] (P x)) x (\= a b)])" "'1" "(number? '1)" "(number? 'x)" "(number? `1)" "(symbol? '1)" "rule" "(def rule \\n  {\:name \\"equal-e\\"\\n   \:given [(\= a b) phi _\:x]\\n   \:conclusion [(substitution phi _\:x b)]\\n   \:prereq [(substitution? phi _\:x a)\\n            (list? phi)]\\n   \:forwards true})" "(def rule \\r\\n     '{\:name \\"equal-e\\"\\r\\n      \:given [(\= a b) phi _\:x]\\r\\n      \:conclusion [(substitution phi _\:x b)]\\r\\n      \:prereq [(substitution? phi _\:x a)\\r\\n               (list? phi)]\\r\\n      \:forwards true})" "rule" "(apply-rule rule true\\r\\n               '[(exists [x] (P x)) x (\= a b)])" "(apply-rule rule true\\r\\n               '[(exists [x] (P x)) x (\= (m x y) b)])" "(apply-rule rule true\\r\\n               '[(exists [x] (P x)) x (\= a (m x y))])" "(defn rule \\n  '{\:name \\"equal-e\\"\\r\\n \:given      [(\= a b) phi _\:x]\\r\\n \:conclusion [(substitution phi _\:x b)]\\r\\n \:prereq     [(substitution? phi _\:x a)\\r\\n              (substitution? phi _\:x b) ;; ???\\r\\n               (list? phi)]\\r\\n \:forwards   true})" "(def rule \\r\\n     '{\:name \\"equal-e\\"\\r\\n    \:given      [(\= a b) phi _\:x]\\r\\n    \:conclusion [(substitution phi _\:x b)]\\r\\n    \:prereq     [(substitution? phi _\:x a)\\r\\n                 (substitution? phi _\:x b) ;; ???\\r\\n                  (list? phi)]\\r\\n    \:forwards   true})" "(apply-rule rule true \\n            '[(exists [x] (exists [y] (P y))) y (\= (m x) s)])" "(def rule \\r\\n        '{\:name \\"equal-e\\"\\r\\n       \:given      [(\= a b) phi _\:x]\\r\\n       \:conclusion [(substitution phi _\:x b)]\\r\\n       \:prereq     [(substitution? phi _\:x a)\\r\\n                     (list? phi)]\\r\\n       \:forwards   true})" "(apply-rule rule true \\r\\n               '[(exists [x] (exists [y] (P y))) y (\= (m x) s)])" "(apply-rule rule true \\r\\n                  '[(exists [x] (exists [y] (P y))) y (\= (m x) s)])" "(def rule\\n  '{\:name \\"equal-e\\"\\r\\n \:given      [(\= a b) phi _\:x]\\r\\n \:conclusion [(substitution phi _\:x b)]\\r\\n \:prereq     [(substitution? phi _\:x a)\\r\\n              (substitution? phi _\:x b) ;; ???\\r\\n              (list? phi)]\\r\\n \:forwards   true})" "(apply-rule rule true\\n            '[(exists [x] (exists [y] (P y))) y (\= (m x) s)])" "(apply-rule rule true\\r\\n               '[(exists [x] (exists [y] (P y))) y (\= (m x) s)])" "rule" "(apply-rule rule true\\r\\n               '[(exists [x] (exists [y] (P y))) y (\= (m x) s)])" "(make-rule rule)" "(def rule \\n  '{\:name \\"equal-e\\"\\r\\n \:given      [(\= a b) phi _\:x]\\r\\n \:conclusion [(substitution phi _\:x b)]\\r\\n \:prereq     [(list? phi)\\n              (substitution? phi _\:x a)\\r\\n              (substitution? phi _\:x b) ;; ???\\r\\n             ]\\r\\n \:forwards   true})" "(apply-rule rule true\\r\\n                  '[(exists [x] (exists [y] (P y))) y (\= (m x) s)])" "(run* [q]\\n      (fresh [a]\\n             (\=\= a 1)\\n             (\=\= (number? a) true)\\n             (\=\= q 2)))" "(run* [q]\\r\\n         (fresh [a]\\r\\n                (\=\= a 1)\\r\\n                (\=\= (number? ~a) true)\\r\\n                (\=\= q 2)))" "(run* [q]\\r\\n         (fresh [a]\\r\\n                (\=\= a 1)\\r\\n                (\=\= (number? a) true)\\n                (println a)\\r\\n                (\=\= q 2)))" "(run* [q]\\r\\n         (fresh [a]\\r\\n                (\=\= a 1)\\r\\n                (\=\= (number? `~a) true)\\r\\n                (\=\= q 2)))" "(run* [q]\\r\\n         (fresh [a]\\r\\n                (\=\= a '1)\\r\\n                (\=\= (number? a) true)\\r\\n                (\=\= q 2)))" "(run* [q]\\r\\n         (fresh [a]\\r\\n                (\=\= a '(1))\\r\\n                (\=\= (list? a) true)\\r\\n                (\=\= q 2)))" "(run* [q]\\r\\n         (fresh [a]\\r\\n                (\=\= a 1)\\n                (println (\:id a))\\r\\n                (\=\= (number? a) true)\\r\\n                (\=\= q 2)))" "(run* [q]\\r\\n         (fresh [a]\\r\\n                (\=\= a 1)\\n                (println (\:unique a))\\r\\n                (\=\= (number? a) true)\\r\\n                (\=\= q 2)))" "(run* [q]\\r\\n            (fresh [a]\\r\\n                   (\=\= a 1)\\r\\n                   (println (\:name a))\\r\\n                   (\=\= (number? a) true)\\r\\n                   (\=\= q 2)))" "(run* [q]\\r\\n            (fresh [a]\\r\\n                   (\=\= a 1)\\r\\n                   (println (\:oname a))\\r\\n                   (\=\= (number? a) true)\\r\\n                   (\=\= q 2)))" "(run* [q]\\r\\n            (fresh [a]\\r\\n                   (\=\= a 1)\\r\\n                   (println (\:hash a))\\r\\n                   (\=\= (number? a) true)\\r\\n                   (\=\= q 2)))" "(run* [q]\\r\\n            (fresh [a]\\r\\n                   (\=\= a 1)\\r\\n                   (println (\:meta a))\\r\\n                   (\=\= (number? a) true)\\r\\n                   (\=\= q 2)))" "(run* [q]\\r\\n            (fresh [a]\\r\\n\\r\\n                   (\=\= (number? a) true)\\r\\n                   (\=\= q 2)))" "(run* [q]\\r\\n            (fresh [a b ]\\r\\n                   (\=\= b 1)\\n                   (is a b inc)\\r\\n                   (\=\= q a)))" "(run* [q]\\r\\n               (fresh [a b ]\\r\\n                      (\=\= b 1)\\r\\n                      (is a b inc)\\n                      (println (number? a))\\r\\n                      (\=\= q a)))" "(run* [q]\\r\\n               (fresh [a b ]\\r\\n                      (\=\= b 1)\\r\\n                      (copy-term b a)\\n                      (println (number? a))\\r\\n                      (\=\= q a)))" "(run* [q]\\r\\n               (fresh [a b ]\\r\\n                      (\=\= b 1)\\r\\n                      (is a b number?)\\r\\n                      (\=\= q a)))" "(run* [q]\\n      (fresh [a]\\n             (\=\= a 1)\\n             (is a a number?)\\n             (\=\= q a)))" "(run* [q] \\n      (fresh [a b]\\n             (\=\= a 1)\\n             (is b a number?)\\n             (\=\= q b)))" "(run* [q]\\n      (pred q 1))" "(run* [q]\\n      (\=\= q 1)\\n      (pred q number?))" "(run* [q]\\n      (\=\= q 1)\\n      (pred q symbol?))" "(run* [q]\\n      (\=\= q 1)\\n      (project [q]\\n               (number? q)))" "(run* [q]\\r\\n         (\=\= q 1)\\r\\n         (project [q]\\r\\n                  (\=\= true (number? q))))" "rule" "(make-rule rule)" "(conj '(1 2 3) 1)" "(make-rule rule)" "(apply-rule rule true\\r\\n                  '[(exists [x] (exists [y] (P y))) y (\= (m x) s)])" "(coll? [1])" "(seq? '(1 2 3))" "(seq? (lazy-seq '(1 2 3)))" "(apply-rule rule true\\r\\n                     '[(exists [x] (exists [y] (P y))) y (\= (m x) s)])" "(apply-rule rule true\\r\\n            '[(exists [z] (exists [y] (P y))) y (\= (m x) s)])" "(apply-rule rule true\\r\\n               '[(exists [z] (exists [y] (P y))) y (\= (m x) s)])" "(sort '(1 2 3 x))" "(sort [4 3 6 4 2])" "(sort [3 67 4 12 4 'x])" "(pos? 0)" "(proof '[(\= (m x) s) (\= (m d) s)(exists [x] (exists [y] (P y)))]\\n       'a)" "(def p (proof '[(\= (m x) s) (\= (m d) s)(exists [x] (exists [y] (P y)))]\\r\\n          'a))" "(step-f p \\"equal-ee\\" 1 3 'y)" "(deduction-playground.io/import-rules \\"resources/rules-prop-pred.clj\\")" "(step-f p \\"equal-ee\\" 1 3 'x)" "(step-f p \\"equal-ee\\" 2 3 'x)" "(step-f p \\"equal-ee\\" 1 3 'x)" "(rules/make-rule \\"equal-ee\\")" "(rules/get-rule \\"equal-ee\\")" "(deduction-playground.io/import-rules \\"resources/rules-prop-pred.clj\\")" "(rules/make-rule \\"equal-ee\\")" "(step-f p \\"equal-ee\\" 1 3 'x)" "(rules/make-rule \\"equal-ee\\")" "(eval (rules/make-rule \\"equal-ee\\"))" "(use 'deduction-playground.prereqs)" "(eval (rules/make-rule \\"equal-ee\\"))" "(step-f p \\"equal-ee\\" 1 3 'x)" "(step-f p \\"equal-ee\\" 1 3 'y)" "(proof '[(\= (m x) s) (\= (m z) s) (exists [x] (exists [y] (P y)))]\\n       'a)" "(step-f \\"equal-ee\\" 1 3 'x)" "(proof '[(\= (m x) s) (\= (m z) s)\\n         (exists [x] (exists [y] (P y)))]\\n       'a)" "(step-f \\"equal-ee\\" 1 3 'y)" "(use 'deduction-playground.prereqs)" "(step-f \\"equal-ee\\" 1 3 'y)" "(step-f \\"equal-ee\\" 3 2 'y)" "(proof '[(\= (m x) s) (\= (m z) s) \\n         (exists [x] (exists [y] (P y)))]\\n       'a)" "(step-f \\"equal-ee\\" 1 3 'x)" "(step-f \\"equal-ee\\" 1 3 'y)" "(step-f \\"equal-ee\\" 2 3 'y)" "(proof '[(impl a b) (not b)]\\n       '(not a))" "(step-b \\"not-i\\" 4)" "(concat [1] [4 5] nil)" "(\:a a)" "(\:a {\:b 1})" "(proof '[(impl a b) (not b)]\\n       '(not a))" "(step-b \\"not-i\\" 4)" "(step-f \\"impl-e\\" 1 3)" "(step-f \\"not-e\\" 2 4)" "(proof '[(\= (m x) s) (\= (m z) s)\\n         (exists [x] (exists [y] (P y)))]\\n       'a)" "(step-f \\"equal-ee\\" 1 3 'y)" "(step-f \\"equal-ee\\" 2 3 'y)" "(step-f \\"equal-ee\\" 1 3 'z)" "(undo)" "(step-f \\"equal-ee\\" 2 3 'y)" "(step-f \\"equal-ee\\" 1 3 'z)" "(step-f \\"and-i\\" 1 2)" "(choose-option 6 1)" "(proof '(\= a b) '(\= b a))" "(step-f \\"equal-i\\")" "(rename-var 'V1 'a)" "(step-f \\"equal-ee\\" 1 2 'a)" "(choose-option 3 1)" "(proof '[(\= a b) (\= b c)]\\n       '(\= a c))" "(step-f \\"equal-ee\\" 2 1 'b)" "(choose-option 3 1)" "(undo)" "(step-f \\"equal-ee\\" 1 2 'b)" "(choose-option 3 2)" "(proof '(exists [x] (forall [y] (exists [z] \\n (or (and (P x) (P (f x))) \\n     (or (and (not (P (f y))) (not (P y)))\\n         (and (P z) (not (P (f z))))))))))" "(step-b \\"exists-i\\" 2)" "(step-b \\"forall-i\\" 2)" "(step-b \\"exists-i\\" 3)" "(proof '[(\= a b)\\n         (P b)\\n         (\= b c)\\n         (forall [x] (impl (P x) (P (f x))))]\\n       '(P (f (f c))))" "(step-f \\"equal-e\\" 2 3 'b)" "(proof '[(\= a b)\\n         (P b)\\n         (\= b c)\\n         (forall [x] (impl (P x)\\n                           (P (f x))))]\\n       '(P ( f (f c))))" "(step-f \\"equal-e\\" 2 3 'b)" "(step-f \\"forall-e-alt\\" 4 '(P c))" "(step-f \\"forward-e-alt\\" 4 '(P c))" "(undo)" "(step-f \\"forward-e-alt\\" 4 'c)" "(step-f \\"impl-e\\" 5 6)" "(step-f \\"forward-e-alt\\" 4 '(P c))" "(proof '[(\= a b)\\r\\n            (P b)\\r\\n            (\= b c)\\r\\n            (forall [x] (impl (P x)\\r\\n                              (P (f x))))]\\r\\n          '(P ( f (f c))))" "(step-f \\"equal-e\\" 3 4 'x)" "(step-f \\"equal-e\\" 2 3 'b)" "(proof '[(\= a b)\\n         (\= b c)\\n         (P b)\\n         (forall [x] (impl (P x) (P (f x))))]\\n       '(P (f (f c))))" "(step-f \\"equal-e\\" 2 3 'b)" "(step-f \\"forall-e-alt\\" 4 5)" "(step-f \\"equal-e\\" 2 4 'x)" "(proof '(not (forall [x] (P x)))\\n       '(exists [x] (not (P x))))" "(step-b \\"raa\\" 3)" "(step-b \\"not-e\\" 1 4)" "(choose-option 4 2)" "(step-b \\"forall-i\\" 4)" "(step-b \\"raa\\" 5)" "(step-b \\"not-e\\" 2 6)" "(choose-option 6 2)" "(step-b \\"exists-i-alt\\" 6 'V1)" "(proof '[(\= a b)\\n         (\= b c)\\n         (forall [x] (impl (P x) (P (f x))))\\n         (P b)]\\n       '(P (f (f c))))" "(step-f \\"equal-e\\" 2 3 'x)" "(step-f \\"equal-e\\" 2 4 'b)" "(proof '[(\= (m x) b)\\n         (\= (m c) b)\\n         (exists [x] (exists [y] (P y)))]\\n       'a)" "(step-f \\"equal-e\\" 1 3 'y)" "(step-f \\"equal-e\\" 2 3 'y)" "(proof '(and a b) 'a)" "(step-b \\"test\\" 3 'b)" "(choose-option 3 1)" "(undo)" "(step-b \\"test\\" 'b 'a 2)" "(proof '(and a b) 'c)" "(step-f-inside \\"test\\" 1)" "(step-f-inside \\"test\\" 'a)" "(step-f \\"test\\" 'a)" "(step-f-inside \\"test\\" 'a)" "(apply distinct? [])" "(step-f \\"test\\" 'a)" "(show)" "(step-f \\"test\\" 'a)" "(proof '(and a b) 'c)" "(step-f \\"test\\" 1 'g)" "(proof '[a b] 'c)" "(step-f \\"test\\" 2 1)" "(proof '[a b] '(and a b))" "(step-b \\"test\\" 4 'a)" "(undo)" "(step-b \\"and-i\\" 4)" "(proof 'a '(and a b))" "(step-b \\"test\\" 3 'x)" "(proof '[(and a true)\\n         (or b false)\\n         (impl a a)\\n         (and a (or b false))]\\n       'c)" "(trivial 1)" "(trivial 3)" "(trivial 5)" "(trivial 7)"]
eclipse.preferences.version=1
