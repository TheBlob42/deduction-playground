cmdhistory=["(step-b \\"impl-i\\" 2)" "(step-b \\"not-e\\" 2)" "(proof '(at x (impl (asap (not a)) (not (asap a)))))" "(step-b \\"impl-i\\" 2)" "(step-b \\"not-e\\" 2)" "(step-b \\"not-i\\" 2)" "(rename-var 'V1 'y)" "(rename-var 'V2 'a)" "(step-b \\"asap-e\\" 2)" "(rename-var 'V3 'x)" "(proof '(at x (impl (asap (not a)) (not (asap a)))))" "(step-b \\"impl-i\\" 2)" "(step-b \\"not-e\\" 2)" "(step-b \\"not-i\\" 2)" "(rename-var 'V1 'y)" "(rename-var 'V3 'x)" "(rename-var 'V2 'x)" "(proof '(at x (impl (asap (not a)) (not (asap a)))))" "(step-b \\"impl-i\\" 2)" "(step-b \\"not-e\\" 2)" "(step-b \\"not-i\\" 2)" "(rename-var 'V1 'y)" "(rename-var 'V2 'a)" "(step-f \\"asap-e\\" 7)" "(rename-var 'V3 'y)" "(step-f \\"not-e\\" 4)" "(step-f \\"asap-e\\" 2)" "(rename-var 'V4 y)" "(rename-var 'V4 'y)" "(proof '(at x (asap (not a))) '(at x (not (asap a))))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'x)" "(proof '(at x (asap (not a))) '(at x (not (asap a))))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3 1)" "(choose-option 3 1)" "(proof '(at x (asap (not a))) '(at x (not (asap a))))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'y)" "(rename-var 'V2 'a)" "(step-f \\"asap-e\\" 1)" "(rename-var 'V3 'y)" "(step-b \\"asap-e\\" 4)" "(rename-var 'V4 'x)" "(step-b \\"not-e\\" 4 )" "(proof '(at x (asap (not a))) '(at x (not (asap a))))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(concat [1 2 3] [4 5 6])" "(apply conj [1 2 3] [4 5 6])" "(apply conj [1 2 3] 'a [4 5])" "(deduction-playground.proof-new/infer\\n  'a '[b c])" "(deduction-playground.proof-new/infer \\n  '[a b] 'c)" "(deduction-playground.proof-new/infer\\r\\n     'a '[b c])" "(deduction-playground.proof-new/infer \\r\\n     '[a b] 'c)" "(deduction-playground.proof-new/infer \\r\\n     'a 'c)" "(deduction-playground.proof-new/infer \\r\\n     '[a b] '[c d])" "(proof '(at x (impl (asap (not a)) (not (asap a)))))" "(step-b \\"impl-i\\" 2)" "(step-f \\"asap-e\\" 1)" "(rename-var 'V1 'y)" "(step-b \\"not-e\\" 4)" "(step-b \\"not-i\\" 4)" "(rename-var 'V2 'y)" "(rename-var 'V3 'a)" "(step-f \\"not-e\\" 3)" "(step-f \\"asap-e\\" 4)" "(rename-var 'V4 'y)" "a" "(proof '(at x (impl (asap (not a)) (not (asap a)))))" "(step-b \\"impl-i\\" 2)" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'y)" "(rename-var 'V2 'a)" "(step-f \\"asap-e\\" 1)" "(rename-var 'V3 'y)" "(proof '(at x (impl (asap (not a)) (not (asap a)))))" "(step-b \\"impl-i\\" 2)" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'y)" "(rename-var 'V2 'a)" "(step-f \\"asap-e\\" 1)" "(rename-var 'V3 'y)" "(step-b \\"and-i\\" 5)" "(step-f \\"not-e\\" 3)" "(step-f \\"asap-e\\" 4)" "(rename-var 'V4 'y)" "(proof '(impl (sometimes a) (until true a)))" "(step-b \\"impl-i\\" 2)" "(proof '(at x (impl (sometimes a) (until true a))))" "(step-b \\"impl-i\\" 2)" "(step-f \\"sometimes-e\\" 1)" "(rename-var 'V1 'y)" "(step-b \\"not-e\\" 5)" "(step-b \\"not-i\\" 5)" "(rename-var 'V2 'y)" "(rename-var 'V3 'a)" "(step-b \\"and-i\\" 6)" "(step-f \\"until-e\\" 4)" "(proof '[(at i (or b a)) (at i (not a))] '(at i b))" "(step-f \\"or-e\\" 1 2)" "(proof '[(at i (or a b)) (at i (not a))] '(at i b))" "(step-f \\"or-e\\" 1 2)" "(proof '[(at i (or b a)) (at i (not a))] '(at i b))" "(step-b \\"or-e\\" 4)" "(rename-var 'V1 'a)" "(step-b \\"or-i1\\" 4)" "(proof '(at x (impl (asap (sometimes a)) (sometimes a))))" "(step-b \\"impl-i\\" 2)" "(step-f \\"seriality\\")" "(step-f \\"asap-seriality\\")" "(rename-var 'V3 'x)" "(rename-var 'V4 'y)" "(step-f \\"asap-e\\" 1)" "(rename-var 'V5 'y)" "(step-f \\"asap/<\=\\" 2)" "(step-f \\"sometimes-e\\" 3)" "(rename-var 'V6 'z)" "(step-f \\"transitivity\\" 4 5)" "(step-f \\"sometimes-i\\" 6 7)" "(proof '(impl (sometimes a) (until true a)))" "(step-b \\"impl-i\\" 2)" "(proof '(at x (impl (sometimes a) (until true a))))" "(step-b \\"impl-i\\" 2)" "(step-f \\"sometimes-e\\" 1)" "(rename-var 'V1 'y)" "(step-b \\"not-e\\" 5)" "(step-b \\"not-i\\" 5)" "(rename-var 'V2 y)" "(rename-var 'V2 'y)" "(rename-var 'V3 'a)" "(step-f \\"not-until\\" 4)" "(step-b \\"and-i\\" 7)" "(proof 'a 'b)" "(step-f \\"asap-seriality\\")" "(undo)" "(undO)" "(undo)" "(proof '(at x (impl (asap (not a)) (not (asap a)))))" "(step-b \\"impl-i\\" 2)" "(step-f \\"asap-e\\" 1)" "(rename-var 'V1 'y)" "(step-b \\"not-e\\" 4)" "(step-b \\"not-i\\" 4)" "(rename-var 'V2 'y)" "(rename-var 'V3 'a)" "(step-b \\"and-i\\" 5)" "(step-f \\"not-e\\" 3)" "(step-f \\"asap-e\\" 4)" "(rename-var 'V4 'y)" "(read/export-theorem\\n  \\"resources/theorems\\"\\n  @p\\n  \\"temporal-1\\")" "(proof '(at x (impl (not (sometimes a)) (always (not a)))))" "(step-b \\"impl-i\\" 2)" "(proof '(asap (not a)) '(not (asap a)))" "(step-b \\"not-e\\" 3)" "(proof '(at x (asap (not a)))\\n       '(at x (not (asap a))))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'y)" "(rename-var 'V2 'a)" "(step-f \\"not-e\\" 2)" "(step-b \\"and-i\\" 5)" "(step-f \\"asap-e\\" 1)" "(rename-var 'V3 'y)" "(step-f \\"asap-e\\" 4)" "(rename-var 'V4 'y)" "(read/export-theorem\\n  \\"resources/theorems.clj\\"\\n  @p\\n  \\"temporal-5\\")" "(proof '(at x (asap (not a))) '(at x (not (asap a))))" "(step-f \\"temporal-5\\" 1)" "(proof '(at x (asap (not a)))\\n       '(at x (not (asap a))))" "(step-f \\"temporal-5\\" 1)" "(show)" "(proof '(at x (asap (not a)))\\n       '(at x (not (asap a))))" "(step-f \\"temporal-5\\" 1)" "(show)" "@p" "(show)" "(proof '(at x (asap (not a)))\\n       '(at x (not (asap a))))" "(show)" "(step-b \\"not-e\\" 3)" "(usw 'clojure.string)" "(use 'clojure.string)" "(subs \\"\\\\\\"test\\\\\\" (1)\\"\\n     (.lastIndexOf  \\"\\\\\\"test\\\\\\" (1)\\" \\\\\\"))" "(subs \\"\\\\\\"test\\\\\\" (1)\\"\\r\\n        (.lastIndexOf  \\"\\\\\\"test\\\\\\" (1)\\" \\"\\\\\\"\\"))" "(subs \\"\\\\\\"test\\\\\\" (1)\\"\\r\\n        (inc (.lastIndexOf  \\"\\\\\\"test\\\\\\" (1)\\" \\"\\\\\\"\\")))" "(+ \\"asd\\" \\"asd\\")" "@p" "(proof '(at x (asap (not a)))\\n       '(at x (not (asap a))))" "(show)" "(step-f \\"temporal-5\\" 1)" "(show)" "(proof '(at x (not (sometimes a)))\\n       '(at x (always (not a))))" "(step-b \\"always-i\\" 3)" "(rename-var 'V1 'y)" "(step-b \\"not-i\\" 4)" "(undo)" "(step-b \\"not-i\\" 4)" "(rename-var 'V4 'x)" "(rename-var 'V5 '(sometimes a))" "(step-b \\"and-i\\" 5)" "(step-f \\"sometimes-i\\" 2 3)" "(read/export-theorem\\n  \\"resources/theorems.clj\\"\\n  @p\\n  \\"temporal-6\\")" "(proof '(at x (not (sometimes a)))\\n       '(at x (always (not a))))" "(step-f \\"temporal-6\\" 1)" "(proof '(at x (not (always a)))\\n       '(at x (sometimes (not a))))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'x)" "(rename-var 'V2 '(always a))" "(step-b \\"and-i\\" 4)" "(step-f \\"temporal-6\\" 2)" "(rename-var '(not (not a))\\n            'a)" "(read/export-theorem\\n  \\"resources/theorems.clj\\"\\n  @p\\n  \\"temporal-7\\")" "(proof '(at x (not (always a)))\\n       '(at x (sometimes (not a))))" "(step-f \\"temporal-7\\")" "(read/read-theorems \\"resources/theorems.clj\\")" "(step-f \\"temporal-7\\" 1)" "(clojure.walk/postwalk-demo [1 2 [3 4]5 ])" "(str \\"asd asd\\" 123)" "(proof '(at x (not (always a)))\\n       '(at x (sometimes (not a))))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'x)" "(rename-var 'V2 '(always a))" "(step-b \\"and-i\\" 4)" "(step-f \\"temporal-6\\" 2)" "(classical 3)" "@p" "(clojure.walk/postwalk (fn [node]\\n                         (if (\= node 2)\\n                           3\\n                           node))\\n                       [1 2 [1 2 [1 2] 3] 3])" "(clojure.walk/postwalk (fn [node]\\r\\n                                          (if (list? node)\\r\\n                                            (cond \\r\\n                                              (and (\= 'and (first node))\\r\\n                                                   (some false? (rest node))) false\\r\\n                                              (and (\= 'and (first node))\\r\\n                                                   (some true? (rest node))) (first (remove true? (rest node)))\\r\\n                                              (and (\= 'or (first node))\\r\\n                                                   (some true? (rest node))) true\\r\\n                                              (and (\= 'or (first node))\\r\\n                                                   (some false? (rest node))) (first (remove false? (rest node)))\\r\\n                                              (and (\= 'not (first node))\\r\\n                                                   (list? (second node))\\r\\n                                                   (\= 'not (first (second node)))) (second (second node))\\r\\n                                              (and (\= 'not (first node))\\r\\n                                                   (true? (second node))) false\\r\\n                                              (and (\= 'not (first node))\\r\\n                                                   (false? (second node))) true)\\r\\n                                            node))\\r\\n                                        '(at x (always (not (not a)))))" "(undo)" "(classical 3)" "@p" "(undo)" "(classical 3)" "(proof '(at x (until a false))\\n       'false)" "(proof '(at x (until a false))\\n       '(at x false))" "(step-b \\"impl-e\\" 3)" "(rename-var 'V1 '(until a false))" "(step-b \\"until-e\\" 3)" "(proof '(at x (until a false))\\n       '(at x false))" "(step-b \\"impl-e\\" 3)" "(rename-var 'V1 '(until a false))" "(step-b \\"until-e\\" 3)" "(classical 3)" "(undo)" "(classical 3)" "(undo)" "(classical 3)" "(undo)" "(proof '(at x (impl a b))\\n       '(at x (impl (not b) (not a))))" "(step-b \\"impl-i\\" 3)" "(step-b \\"not-i\\" 4)" "(rename-var 'V1 'x)" "(rename-var 'V2 'b)" "(step-b \\"and-i\\" 5)" "(step-f \\"impl-e\\" 1 3)" "(proof '(at x a)\\n       '(at x (always a)))" "(step-f \\"reflexivity\\")" "(rename-var 'V1 'x)" "(undo)" "(proof '(at x a)\\n       '(at x (always a)))" "(step-b \\"always-i\\" 3)" "(rename-var 'V1 'x)" "(read/export-theorem\\n  \\"resources/theorems.clj\\"\\n  @p \\n  \\"temporal-1\\")" "(read/read-theorems)" "(read/read-theorems \\"resources/theorems.clj\\")" "(proof '(at x (until a false))\\n       '(at x false))" "(step-b \\"impl-i\\" 3)" "(step-b \\"impl-e\\" 3)" "(rename-var 'V1 '(until a false))" "(step-b \\"until-e\\" 3)" "(step-b \\"temporal-1\\" 3)" "(step-f \\"temporal-1\\" 1)" "(proof '(at x (and true a)) '(at x a))" "(classical 1)" "(proof '(at x (sometimes a))\\n       '(until true a))" "(proof '(at x (sometimes a))\\n       '(at x (until true a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'y)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(step-f \\"sometimes-e\\" 1)" "(rename-var 'V3 'y)" "(step-f \\"not-until\\" 4)" "(classical 5)" "(step-f \\"temporal-8\\" 6)" "(proof '(until a false) 'false)" "(proof '(at x (sometimes a)) '(at x (until true a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'y)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(step-f \\"sometimes-e\\" 1)" "(rename-var 'V3 'y)" "(step-b \\"always-e\\" 6)" "(rename-var 'V4 'x)" "(step-f \\"not-until\\" 4)" "(classical 5)" "(proof '(or a (and b false)) 'a)" "(classical 1)" "(clojure.walk/postwalk-demo [1 2 [3 4] 5])" "(pr-str \\"hallo\\"\\n        '(1 2 3))" "(proof '(at x (sometimes a)) '(at x (until true a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'y)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(step-f \\"sometimes-e\\" 1)" "(rename-var 'V3 'y)" "(step-f \\"not-until\\" 4)" "(classical 5)" "(step-f-inside \\"temporal-8\\" 6)" "(list 1 '(2 3 4))" "(step-f-inside \\"temporal-8\\" 6)" "(deduction-playground.auto-logic/rule-givens\\n  \\"temporal-8\\")" "(deduction-playground.auto-logic/rule-givens\\r\\n     \\"temporal-8\\")" "(deduction-playground.auto-logic/rule-givens\\r\\n     \\"and-i\\")" "(deduction-playground.auto-logic/rule-givens\\r\\n     \\"temporal-8\\")" "(proof '(at x (sometimes a)) '(at x (until true a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'y)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(step-f \\"sometimes-e\\" 1)" "(rename-var 'V3 'y)" "(step-f \\"not-until\\" 4)" "(classical 5)" "(step-f-inside \\"temporal-8\\" 6)" "(conj '(1 2 3) (list \\"proof\\" \\"rule\\"))" "(conj '(1 2 3) \\"proof\\" \\"rule\\")" "(step-f-inside \\"temporal-8\\" 6)" "(symbol? false)" "(symbol? true)" "(step-f-inside \\"temporal-8\\" 6)" "@p" "(reset\! p bla)" "(show)" "(step-f-inside \\"temporal-8-in\\" 6)" "(classical 1)" "(proof '(at x (sometimes a)) '(at x (until true a)))" "(step-b \\"not-e\\" 3)" " (step-b \\"not-i\\" 3)" "(rename-var 'V1 'y)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(step-f \\"sometimes-e\\" 1)" "(rename-var 'V3 'y)" "(step-f \\"not-until\\" 4)" "(classical 5)" "(step-f-inside \\"temporal-8-in\\" 6)" "(classical 7)" "(step-f \\"always-e\\" 8 3)\#" "(show)" "@p" "(show)" "(undo)" "@p" "(proof '(at x (sometimes a)) '(at x (until true a)))" "(step-f \\"sometimes-e\\" 1)" "(rename-var 'V1 'y)" "(step-b \\"not-e\\" 5)" "(step-b \\"not-i\\" 5)" "(rename-var 'V2 'y)" "(rename-var 'V3 'a)" "(step-b \\"and-i\\" 6)" "(step-f \\"not-until\\" 4)" "(classical 5)" "(step-f-inside \\"temporal-8-in\\" 6)" "(show)" "@p" "(proof '(at x (sometimes a)) '(at x (until true a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'y)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(step-f \\"sometimes-e\\" 1)" "(rename-var 'V3 'y)" "(step-f \\"not-until\\" 4)" "(classical 5)" "(step-f-inside \\"temporal-8-in\\" 6)" "(classical 7)" "(step-f \\"always-e\\" 8 3)" "(deduction-playground.read-rules/export-theorem\\n  @p\\n  \\"temporal-9\\")" "(deduction-playground.read-rules/export-theorem\\n  \\"resources/theorems.clj\\"\\r\\n     @p\\r\\n     \\"temporal-9\\")" "(proof '(at x (asap (sometimes a))) '(at x (sometimes a)))" "(step-b \\"sometimes-i\\" 3)" "(rename-var 'V1 'z)" "(step-f \\"asap-e\\" 1)" "(rename-var 'V2 'x1)" "(step-f \\"asap-seriality\\")" "(rename-var 'V3 'x)" "(rename-var 'V4 'x1)" "(step-f \\"asap/<\=\\" 3)" "(step-f \\"sometimes-e\\" 2)" "(rename-var 'V5 'z)" "(step-f \\"transitivity\\" 4 5)" "(deduction-playground.read-rules/export-theorem\\n  \\"resources/theorems.clj\\"\\n  @p\\n  \\"temporal-10\\")" "(proof '(at x (and true (asap (sometimes a))))\\n       '(at x (sometimes a)))" "(proof '(at x (always (and (impl a (asap a)) a)))\\n       '(at x (always a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'x)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(proof '(at x (and (always (impl a (asap a))) a))\\n       '(at x (always a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'x)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(step-f \\"and-e1\\" 1)" "(step-f \\"and-e2\\" 1)" "(step-f \\"temporal-7\\" 4)" "(step-f \\"temporal-9\\" 5)" "(proof '(at x (and (always (impl a (asap a)))))\\n       '(at x (always a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'x)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(step-f \\"and-e1\\" 1)" "(proof  '(at x (and (always (impl a (asap a))) a))\\n        '(at x (always a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'x)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(step-f \\"and-e1\\" 1)" "(step-f \\"and-e2\\" 1)" "(step-f \\"temporal-7\\" 4)" "(step-f \\"temporal-9\\" 5)" "(step-b \\"impl-e\\" 8 6)" "(step-b \\"until-e\\" 8)" "(proof '(at x (until a false))\\n       'false)" "(step-b \\"impl-e\\" 3)" "(proof '(at x (until a false))\\n       '(at x false))" "(step-b \\"impl-e\\" 3)" "(rename-var 'V1 '(until a false))" "(step-b \\"until-e\\" 3)" "(step-f \\"classical-13\\")" "(proof '(at x (until a false))\\n       '(at x false))" "(step-b \\"impl-e\\" 3)" "(rename-var 'V1 '(until a false))" "(step-b \\"until-e\\" 3)" "(step-f \\"classical-13\\")" "(rename-var 'V2 false)" "(insert-formula '(impl (and a (asap false)) false))" "(is-valid? '(impl a false))" "(if (and (\= 'impl (first '(impl a false)))\\r\\n               (false? (first (rest node)))) true)" "(if (and (\= 'impl (first '(impl a false)))\\r\\n                  (false? (first (rest '(impl a false))))) true)" "(insert-formula (impl (and a false) false))" "'(insert-formula (impl (and a false) false))" "(is-valid? '(impl (and a false) false9))" "(def a {\:1 a\\n        \:2 b \:3 c})" "(def a {\:a 1 \:b 2 \:c 3})" "(map key a)" "(map str (map key a))" "(map str (map symbol (map key a)))" "(map symbol (map key a))" "(map \#(subs 1) (map str (map key a)))" "(map \#(subs 1 %) (map str (map key a)))" "(map \#(subs % 1) (map str (map key a)))" "(apply-classicals '(and false a))" "@classicals" "(apply-classicals '(and false a))" "(impl (and a false) false)" "(apply-classicals '(impl (and a false) false))" "(contains? \#{1 2 3} 3)" "(drop (drop '(at x (and a b))))" "(drop 2 '(at x (and a b)))" "(class (first (drop 2 '(at x (and a b)))))" "(def a (proof '(impl (and a true) false)\\n              'b))" "a" "(classical a 1)" "(def a (proof '(impl (and a false) false)\\n              'b))" "(classical a 1)" "(def a (proof '(impl (and a true) false)\\n              'b))" "(classical a 1)" "(def a (proof '(impl (and a true) false)\\n              'b))" "(classical a 1)" "(insert-formula\\n  a\\n  '(impl false false))" "(insert-formula a\\n                '(impl (or a true) true))" "(proof '(at x (until a false))\\n       '(at x false))" "(step-b \\"impl-e\\" 3)" "(rename-var 'V1 '(until a false))" "(step-b \\"until-e\\" 3)" "(insert-formula '(at x (impl false false)))" "@p" "(undo)" "(insert-formula '(at x (impl false false)))" "@p" "(undo)" "(insert-formula '(at x (impl false false)))" "(show)" "@p" "(undo)" "(insert-formula '(at x (impl false false)))" "(show)" "(insert-formula '(at x (impl (and a (asap false)) false)))" "(and 'a false)" "(and 'a true)" "(or 'a true)" "(or true 'b)" "(proof '(at x (sometimes a))\\n       '(at x (until true a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'y)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(step-f \\"sometimes-e\\" 1)" "(rename-var 'V3 'y)" "(step-f \\"not-until\\" 4)" "(classical 5)" "(step-f-inside \\"temporal-8\\" 6)" "(undo)" "(step-f-inside \\"temporal-8\\" 6)" "(undo)" "(step-f-inside \\"temporal-8\\" 6)" "(undo)" "(step-f-inside \\"temporal-8\\" 6)" "(undo)" "(step-f-inside \\"temporal-8\\" 6)" "(classical 7)" "(undo)" "(classical 7)" "(undo)" "(classical 7)" "(undo)" "(classical 7)" "(undo)" "(classical 7)" "(conj '(1 2 3) '(4 5))" "(reduce conj '(1 2 3) '(4 5))" "(proof '(at x (sometimes a))\\n       '(at x (until true a)))" "(step-b \\"not-e\\" 3)" "((keyword name) @rules)" "(step-b \\"not-e\\" 3)" "(proof '(at x (sometimes a))\\n       '(at x (until true a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'y)" "(rename-var 'V2 'a)" "(step-f \\"not-until\\" 2)" "(classical 3)" "(undo)" "(classical 3)" "(undo)" "(classical 3)" "(step-f-inside \\"temporal-8\\" 4)" "(classical 5)" "(proof '(at x (and (always (impl a (asap a))) a))\\n       '(at x (always a)))" "(step-f \\"and-e1\\" 1)" "(step-f \\"and-e2\\" 1)" "(step-b \\"not-e\\" 5)" "(step-b \\"not-i\\" 5)" "(rename-var 'V1 'x)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 6)" "(step-f \\"temporal-7\\" 4)" "(step-f \\"temporal-9\\" 5)" "(insert-formula '(at x (impl a a)))" "(proof '(at x (and (always (impl a (asap a))) a))\\n       '(at x (always a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'x)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(step-f \\"and-e1\\" 1)" "(step-f \\"and-e2\\" 1)" "(step-f \\"temporal-7\\" 4)" "(step-f \\"temporal-9\\" 5)" "(insert-formula '(at x (impl (not a) (not a))))" "(step-f \\"generalisation\\" 2)" "(step-b \\"impl-e\\" 10)" "(rename-var 'V3 '(not a))" "(undo)" "(rename-var 'V3 '(until true (not a)))" "(step-b \\"until-e\\" 10)" "(step-b \\"always-i\\" 10)" "(rename-var 'V4 'v)" "(step-f \\"always-e\\" 9 5)" "(proof '(at x (and a (asap false)))\\n       '(at x false))" "(classical 1)" "(apply list false)" "(proof '(at x false)\\n       '(at x false))" "(deduction-playground.read-rules/export-theorem\\n  \\"resources/theorems.clj\\"\\n  @p\\n  \\"blabla\\")" "(class (clojure.walk/postwalk-demo\\n         '(1 2 (3 4) 5)))" "(proof '(at x (and a (asap false)))\\n       '(at x false))" "(classical 1)" "(undo)" "(classical 1)" "(undo)" "(classical 1)" "(insert-theorem \\"temporal-8\\")" "(undo)" "(insert-theorem \\"temporal-8\\")" "(undo)" "(insert-theorem \\"temporal-8\\")" "(proof '(at x (or (always a) (until a false)))\\n       'b)" "(step-f-inside \\"temporal-8\\" 1)" "(deduction-playground.auto-logic/get-rule \\"temporal-8\\")" "(step-f-inside \\"temporal-8\\" 1)" "(deduction-playground.proof-new/prep-temporal\\n  {\:given [(at x (until a false))], \:conclusion [(at x false)], \:proof \\"not yet\\"})" "(deduction-playground.proof-new/prep-temporal\\r\\n     {\:given '[(at x (until a false))], \:conclusion '[(at x false)], \:proof \\"not yet\\"})" "(deduction-playground.proof-new/prep-temporal\\r\\n        {\:given '[(at x (until a false))], \:conclusion '[(at x false)], \:proof \\"not yet\\"})" "(step-f-inside \\"temporal-8\\" 1)" "(show)" "(step-f-inside \\"temporal-8\\" 1)" "(classical 2)" "(undo)" "(classical 2)" "(proof '(impl (and a false) false))" "(classical 2)" "(proof '(impl (and a false) false)\\n       'b)" "(deduction-playground.read-rules/read-rules\\n  \\"resources/classic-theorems.clj\\")" "(deduction-playground.read-rules/read-rules\\n  \\"resources/classical-theorems\\")" "(deduction-playground.read-rules/read-rules\\r\\n     \\"resources/classical-theorems.clj\\")" "(show)" "(step-f \\"classical-1\\" 1)" "(step-f-inside \\"classical-1\\" 1)" "(classical 1)" "(undo)" "(classical 1)" "(classical 3)" "(classical 2)" "(undo)" "(classical 5)" "(proof '(at x (sometimes a))\\n       '(at x (until true a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 y)" "(rename-var 'V1 'y)" "(rename-var 'V2 'a)" "(step-f \\"sometimes-e\\" 1)" "(rename-var 'V3 'y)" "(step-f \\"not-until\\" 4)" "(classical 5)" "(step-f-inside \\"temporal-8\\" 6)" "(classical 7)" "(step-b \\"and-i\\" 10)" "(step-f \\"always-e\\" 3 8)" "(proof '(at x (impl (not a) (not a))))" "(classical 2)" "@p" "(undo)" "(classical 2)" "(deduction-playground.read-rules/export-theorem\\n  \\"resources/theorems.clj\\"\\n  @p\\n  \\"c1\\")" "(step-f \\"c1\\" 1)" "(proof '(at x (and (always (impl a (asap a))) a))\\n       '(at x (always a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'x)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(step-f \\"and-e1\\" 1)" "(step-f \\"and-e2\\" 1)" "(step-f \\"temporal-7\\" 4)" "(step-f \\"temporal-9\\" 5)" "(step-f \\"c1\\")" "(rename-var 'V3 'x)" "(rename-var 'V4 'a)" "(step-f \\"generalisation\\" 7)" "(step-b \\"impl-e\\" 10)" "(rename-var 'V5 '(until true (not a)))" "(step-b \\"until-e\\" 10)" "(step-b \\"always-i\\" 10)" "(rename-var 'V6 'v)" "(step-f \\"always-e\\" 9 3)" "(proof '(at x (impl a b))\\n       '(at x (impl (not b) (not a))))" "(step-b \\"impl-i\\" 3)" "(step-b \\"not-i\\" 4)" "(rename-var 'V1 'x)" "(step-f \\"impl-e\\" 1 3)" "(rename-var 'V2 'b)" "(step-b \\"and-i\\" 6)" "(deduction-playground.read-rules/export-theorem\\n  \\"resources/theorems.clj\\"\\n  @p\\n  \\"rule-2\\")" "(proof '[(at x (impl a b)) (at x (impl b c))]\\n       '(at x (impl a c)))" "(step-b \\"impl-i\\" 4)" "(step-f \\"impl-e\\" 1 3)" "(step-f \\"impl-e\\" 2 4)" "(deduction-playground.read-rules/export-theorem\\n  \\"resources/theorems.clj\\"\\n  @p\\n  \\"rule-3\\")" "(proof '(at x (and (always (impl a (asap a))) a))\\n       '(at x (always a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'x)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(step-f \\"and-e1\\" 1)" "(step-f \\"and-e2\\" 1)" "(step-f \\"temporal-7\\" 4)" "(step-f \\"temporal-9\\" 5)" "(step-b \\"impl-e\\" 8)" "(rename-var 'V3 '(until true (not a)))" "(step-b \\"until-e\\" 8)" "(step-f \\"c1\\")" "(rename-var 'V5 'a)" "(step-f \\"generalisation\\" 7)" "(rename-var 'V4 'x)" "(step-b \\"always-i\\" 10)" "(rename-var 'V6 'v)" "(step-f \\"always-e\\" 9 3)" "(step-f \\"rule-2\\" 10)" "(proof '(at x (and (always (impl a (asap a))) a))\\n       '(at x (always a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'x)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(step-f \\"and-e1\\" 1)" "(step-f \\"and-e2\\" 1)" "(step-f \\"temporal-7\\" 4)" "(step-f \\"temporal-9\\" 5)" "(step-f \\"c1\\")" "(rename-var 'V3 'x)" "(rename-var 'V4 a)" "(rename-var 'V4 'a)" "(step-f \\"generalisation\\" 7)" "(step-b \\"impl-e\\" 10)" "(rename-var 'V5 '(until true (not a)))" "(step-b \\"until-e\\" 10)" "(step-b \\"always-i\\" 10)" "(rename-var 'V6 'v)" "(step-f \\"always-e\\" 9 3)" "(step-f \\"rule-2\\" 10)" "(proof '(at x (impl (asap (not a)) (not (asap a)))))" "(step-b \\"impl-i\\" 2)" "(step-f \\"asap-e\\" 1)" "(rename-var 'V1 'x1)" "(step-b \\"not-e\\" 4)" "(step-b \\"not-i\\" 4)" "(rename-var 'V2 'x1)" "(rename-var 'V3 'a)" "(step-b \\"and-i\\" 5)" "(step-f \\"not-e\\" 3)" "(step-f \\"asap-e\\" 4)" "(rename-var 'V4 'x1)" "(deduction-playground.read-rules/export-theorem\\n  \\"resources/theorems.clj\\"\\n  @p\\n  \\"teo-5\\")" "(proof '(at x (and (always (impl a (asap a))) a))\\n       '(at x (always a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'x)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(step-f \\"and-e1\\" 1)" "(step-f \\"and-e2\\" 1)" "(step-f \\"temporal-7\\" 4)" "(step-f \\"temporal-9\\" 5)" "(step-f \\"c1\\")" "(rename-var 'V3 'x)" "(rename-var 'V4 'a)" "(step-f \\"generalisation\\" 7)" "(step-b \\"impl-e\\" 10)" "(rename-var 'V5 '(until true (not a)))" "(step-b \\"until-e\\" 10)" "(step-b \\"always-i\\" 10)" "(rename-var 'V6 'v)" "(step-f \\"always-e\\" 9 3)" "(step-f \\"rule-2\\" 10)" "(step-f \\"teo-5\\")" "(rename-var 'V7 'v)" "(rename-var 'V8 'a)" "(step-f \\"rule-3\\" 11 12)" "(proof '(at x (impl (and true (asap (not a))) (asap (not a)))))" "(step-b \\"impl-i\\" 2)" "(classical 1)" "(deduction-playground.read-rules/export-theorem\\n  \\"resources/theorems.clj\\"\\n  @p\\n  \\"teo-4\\")" "(proof '(at x (and (always (impl a (asap a))) a))\\n       '(at x (always a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'x)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(step-f \\"and-e1\\" 1)" "(step-f \\"and-e2\\" 1)" "(step-f \\"temporal-7\\" 4)" "(step-f \\"temporal-9\\" 5)" "(step-f \\"c1\\")" "(rename-var 'V3 'x)" "(rename-var 'V4 'a)" "(step-f \\"generalisation\\" 7)" "(step-b \\"impl-e\\" 10)" "(rename-var 'V5 '(until true (not a)))" "(step-b \\"until-e\\" 10)" "(step-b \\"always-i\\" 10)" "(rename-var 'V6 'v)" "(step-f \\"always-e\\" 3 9)" "(step-f \\"rule-2\\" 10)" "(step-f \\"teo-5\\")" "(rename-var 'V7 'v)" "(rename-var 'V8 'a)" "(step-f \\"rule-3\\" 11 12)" "(step-f \\"teo-4\\")" "(rename-var 'V9 'v)" "(rename-var 'V10 'a)" "(step-f \\"rule-3\\" 13 14)" "(proof '(at x (impl (and a (asap false)) false)))" "(classical 2)" "(deduction-playground.read-rules/export-theorem\\n  \\"resources/theorems.clj\\"\\n  @p\\n  \\"c8-1\\")" "(proof '(at x (impl false false)))" "(classical 2)" "(deduction-playground.read-rules/export-theorem\\n  \\"resources/theorems.clj\\"\\n  @p\\n  \\"c8-2\\")" "(proof '(at x (until a false))\\n       '(at x false))" "(step-b \\"impl-e\\" 3)" "(rename-var 'V1 '(until a false))" "(step-b \\"impl-i\\" 3)" "(undo)" "(step-b \\"until-e\\" 3)" "(step-f \\"c8-2\\")" "(rename-var 'V2 'x)" "(step-f \\"generalisation\\" 2)" "(step-f \\"c8-1\\")" "(rename-var 'V3 'x)" "(rename-var 'V4 'a)" "(proof '(and a b) '(and b a))" "(proof '(at x (and a b)) '(at x (and b a)))" "(step-f \\"and-e1\\" 1)" "(step-f \\"and-e2\\" 1)" "(step-f \\"and-i\\" 2 3)" "(choose-option 4 2)" "(export-theorem\\n  \\"resources/theorems.clj\\"\\n  \\"test1\\")" "(proof '(at x (and a b)) '(at x (and b a)))" "(step-f \\"test-1\\" 1^)" "(step-f \\"test-1\\" 1)" "(step-f \\"test1\\" 1)" "(read/@theorems)" "(deref read/theorems)" "(proof '(at x (and a b)) '(at x (and b a)))" "(step-f \\"and-e1\\" 1)" "(step-f \\"and-e2\\" 1)" "(step-f \\"and-i\\" 2 3)" "(choose-option 4 2)" "(export-theorem\\n  \\"resources/theorems.clj\\"\\n  \\"test2\\")" "(proof '(at x (and d f)) '(at x (and f d)))" "(step-f \\"test2\\" 1)" "(proof '(at x (and a b)) '(at x (and b a)))" "(step-f \\"and-e1\\" 1)" "(step-f \\"and-e2\\" 1)" "(step-f \\"and-i\\" 3 2)" "(choose-option 4 1)" "(proof '(at x (sometimes a))\\n       '(at x (until true a)))" "(step-b \\"not-e\\" 3)" "(step-b \\"not-i\\" 3)" "(rename-var 'V1 'y)" "(rename-var 'V2 'a)" "(step-b \\"and-i\\" 4)" "(step-f \\"sometimes-e\\" 1)" "(rename-var 'V3 'y)" "(step-f \\"not-until\\" 4)" "(classical 5)" "(proof '(at x (not (until true a)))\\n       '(at x false))" "(classical 1)" "(proof '(and false true) \\n       'a )" "(classical 1)" "(proof '(and false true) 'a)" "(classical 1)" "(proof '(impl (or false a) (and true a)))" "(proof '(impl (or false a) (and true a))\\n       'a)" "(classical 1)" "(proof '(at x (and a e)) '(at x (and e a)))" "(step-f \\"and-e1\\" 1)" "(step-f \\"and-e2\\" 1)" "(step-f \\"and-i\\"  2 3)" "(choose-option 4 2)" "(export-theorem \\"resources/theorems-clj\\"\\n                \\"blabla\\")" "(export-theorem \\"resources/theorems.clj\\"\\r\\n                   \\"blabla\\")" "(clojure.java.io/writer\\n  \\"resources/theorems-clj\\")" "(.exists (clojure.java.io/as-file \\"resources/theorems-clj\\"))" "(.exists (clojure.java.io/as-file \\"resources/theorems\\"))" "(.exists (clojure.java.io/as-file \\"resources/theoremsasdasd\\"))" "(export-theorem \\"resources/bla.clj\\" \\"bla\\")" "(.exists (clojure.java.io/as-file \\"resources/cla.clj\\"))" "(read/read-rules \\"bla.clj\\")" "(export-theorem \\"bla.clj\\" \\"bla\\")" "(export-theorem \\"bla.clj\\" \\"cla\\")" "(proof '(at x a) '(at x (always a)))" "(step-b \\"always-i\\" 3)" "(rename-var 'V1 'x)" "(proof '[(impl a b) (not b)]\\n       '(not a))" "(step-b \\"not-i\\" 4)" "(proof '[(impl a b) (not b)]\\n       '(not a))" "(step-b \\"not-i\\" 4)" "(step-f \\"impl-e\\" 1 3)" "(step-f \\"not-e\\" 2 4)" "(export-theorem\\n  \\"resource/theorems.clj\\"\\n  \\"modus-tollens\\")" "(export-theorem\\r\\n     \\"resources/theorems.clj\\"\\r\\n     \\"modus-tollens\\")" "(proof '(impl p q)\\n       '(impl (not q) (not p)))" "(step-b \\"impl-i\\" 3)" "(step-f \\"modus-tollens\\" 1 2)" "(undo)" "(proof '(and true a))" "(classical 2)" "(proof '(and true a)\\n       'a)" "(classical 1)" "(proof '(and true a) 'b)" "(classical 1)" "(proof '(impl (and true a) (or false b))\\n       'b)" "(classical 1)" "(undo)" "(classical 1)" "(undo)" "(classical 3)" "(classical 1)" "(classical 4)" "(proof '(at x (impl (asap false) false))\\n       '(at x a))" "(classical 1)" "(undo)" "(classical 1)" "(proof '(at x (impl false false)))" "(classical 2)" "(proof '(and true a))" "(classical 2)" "(symbol? true)" "(classical 2)" "(show)" "@p" "(proof '(and true a))" "(classical 2)" "@p" "(proof '(and true a))" "(classical 2)" "@p" "(proof '(and true a))" "(classical 2)" "(proof '(at x (impl false true)))" "(classical 2)" "(proof '(and false a)\\n       'false)" "(classical 1)" "(proof '(and (impl false false) a))" "(classical 2)" "(proof '(impl a b))" "(step-b \\"impl-i\\" 2)" "(proof 'a \\n       '(and b c))" "(step-b \\"and-i\\" 3)" "(undo)" "(step-b \\"or-e\\" 3)" "(proof '(and (impl false false) a)\\n       'b)" "(classical 1)" "(def a [{\:id 1 \:body a \:rule \:premise}\\n        {\:id 2 \:body a \:rule \\"rule1\\"}\\n        [{\:id 3 \:body a \:rule \:assumption}\\n         {\:id 4 \:body \:todo \:rule nil}\\n         {\:id 5 \:body a \:rule nil}]\\n        {\:id 6 \:body a \:rule nil}])" "a" "(def a '[{\:id 1 \:body a \:rule \:premise}\\r\\n           {\:id 2 \:body a \:rule \\"rule1\\"}\\r\\n           [{\:id 3 \:body a \:rule \:assumption}\\r\\n            {\:id 4 \:body \:todo \:rule nil}\\r\\n            {\:id 5 \:body a \:rule nil}]\\r\\n           {\:id 6 \:body a \:rule nil}])" "a" "(remove-duplicates1 a)" "(map \:id (filter (set sub) (remove \:rule equals)))" "(remove-duplicates1 a)" "a" "(remove-duplicates1 a)" "a" "(remove-duplicates1 a)" "(clojure.set/union \#{{\:id 6, \:body a, \:rule nil}}\\r\\n\#{{\:id 5, \:body a, \:rule nil}})" "a" "(def a '[{\:id 1, \:body b, \:rule \:premise} \\n         {\:id 2, \:body b, \:rule \\"rule1\\"} \\n         [{\:id 3, \:body b, \:rule \:assumption} \\n          {\:id 4, \:body \:todo, \:rule nil} \\n          {\:id 5, \:body b, \:rule nil}] \\n         {\:id 6, \:body b, \:rule nil}])" "(remove-duplicates1 a)" "(clojure.set/union \#{{\:id 6, \:body b, \:rule nil}}\\r\\n\#{{\:id 5, \:body b, \:rule nil}})" "(remove-duplicates1 a)" "(find-duplicates1 a)" "a" "(find-duplicates1 a)" "(remove-duplicates a)" "(find-duplicates1 a)" "a" "(remove-duplicates1 a)" "(def b '[{\:id 1 \:body a \:premise}\\n         [{\:id 4 \:body a \:rule \:assumption}\\r\\n          {\:id 5 \:body \:todo \:rule nil}\\r\\n          {\:id 6 \:body b \:rule nil}]\\n         {\:id 2 \:body \:todo \:rule nil}\\n         {\:id 3 \:body a \:rule nil}\\n         {\:id 7 \:body b \:rule \\"bla ([4 6] 3)\\"}])" "(def b '[{\:id 1 \:body a \:rule \:premise}\\r\\n         [{\:id 4 \:body a \:rule \:assumption}\\r\\n          {\:id 5 \:body \:todo \:rule nil}\\r\\n          {\:id 6 \:body b \:rule nil}]\\r\\n         {\:id 2 \:body \:todo \:rule nil}\\r\\n         {\:id 3 \:body a \:rule nil}\\r\\n         {\:id 7 \:body b \:rule \\"bla ([4 6] 3)\\"}])" "(remove-duplicates1 b)" "(remove-duplicates1 a)" "(remove-duplicates1 b)" "b" "(remove-duplicates1 b)" "(deduction-playground.proof-new/check-duplicates\\n  (-> (proof '[(impl p q) (impl r s)]\\r\\n                   '(impl (or p r) (or q s)))\\r\\n          (step-b \\"impl-i\\" 4)\\r\\n          (step-b \\"or-e\\" 5 3)\\r\\n          (choose-option 5 1)\\r\\n          (step-f \\"impl-e\\" 2 4)\\r\\n          (step-f \\"or-i2\\" 5)\\r\\n          (rename-var 'V1 'q)))" "(def a (-> (proof '[(impl p q) (impl r s)]\\r\\n                   '(impl (or p r) (or q s)))\\r\\n          (step-b \\"impl-i\\" 4)\\r\\n          (step-b \\"or-e\\" 5 3)\\r\\n          (choose-option 5 1)\\r\\n          (step-f \\"impl-e\\" 2 4)\\r\\n          (step-f \\"or-i2\\" 5)\\r\\n          (rename-var 'V1 'q)))" "(deduction-playground.proof-new/check-duplicates\\n  a)" "(deduction-playground.proof-new/check-duplicates a)" "(merge nil {\:a 1})" "(deduction-playground.proof-new/check-duplicates a)" "(symbol? (first '(a b c)))" "(symbol? '(and a b))" "(meta (-> (proof '[(impl a b) (not b)] '(not a))\\r\\n          (step-b \\"not-i\\" 4)\\r\\n          (step-f \\"impl-e\\" 1 3)\\r\\n          (step-f \\"not-e\\" 2 4)))" "(meta (-> (proof '[(impl a b) (not b)] '(not a))\\r\\n             (step-b \\"not-i\\" 4)\\r\\n             (step-f \\"impl-e\\" 1 3)\\r\\n             (step-f \\"not-e\\" 2 4)))" "(meta (-> (proof '[(impl a b) (not b)] '(not a))\\r\\n                (step-b \\"not-i\\" 4)\\r\\n                (step-f \\"impl-e\\" 1 3)\\r\\n                (step-f \\"not-e\\" 2 4)))" "(meta (-> (proof 'p '(not (not p)))\\r\\n          (step-b \\"not-i\\" 3)\\r\\n          (step-f \\"not-e\\" 1 2)))" "(meta (-> (proof '[(impl p q) (not q)] '(not p))\\r\\n          (step-b \\"not-i\\" 4)\\r\\n          (step-f \\"impl-e\\" 1 3)\\r\\n          (step-f \\"not-e\\" 2 4)))" "(meta (-> (proof '(or p (not p)))\\r\\n          (step-b \\"raa\\" 2)\\r\\n          (step-b \\"not-e\\" 1 3)\\r\\n          (choose-option 3 2)\\r\\n          (step-b \\"or-i2\\" 3)\\r\\n          (step-b \\"not-i\\" 3)\\r\\n          (step-f \\"or-i1\\" 2)\\r\\n          (rename-var 'V1 '(not p))\\r\\n          (step-f \\"not-e\\" 1 3)\\r\\n          ))" "(proof 'p '(not (not p)))" "(def a (proof 'p '(not (not p))))" "(meta (step-b a \\"not-i\\" 3))" "(proof '[(impl a b) (not b)]\\n       '(not a))" "(step-b \\"not-e\\" 4)" "(step-b \\"not-i\\" 4)" "(step-f \\"impl-e\\" 3 1)" "(step-f \\"not-e\\" 2 4)"]
eclipse.preferences.version=1
